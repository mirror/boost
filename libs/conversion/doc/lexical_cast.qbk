[library Boost.Lexical_Cast
    [quickbook 1.5]
    [version 1.0]
    [copyright 2000-2005 Kevlin Henney]
    [copyright 2006-2010 Alexander Nasonov]
    [copyright 2011-2012 Antony Polukhin]
    [category String and text processing]
    [category Miscellaneous]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[def __numericcast__  [@boost:libs/numeric/conversion/doc/html/boost_numericconversion/improved_numeric_cast__.html `boost::numeric_cast`]]
[def __proposallong__ [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1973.html Lexical Conversion Library Proposal for TR2, N1973 by Kevlin Henney and Beman Dawes]]
[def __proposalshort__ [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1973.html Lexical Conversion Library Proposal for TR2, N1973]]

[section Motivation]
Sometimes a value must be converted to a literal text form, such as an [c++] `int` represented as a `std::string`, or vice-versa, when a `std::string` is interpreted as an `int`. Such examples are common when converting between data types internal to a program and representation external to a program, such as windows and configuration files.

The standard C and C++ libraries offer a number of facilities for performing such conversions. However, they vary with their ease of use, extensibility, and safety.

For instance, there are a number of limitations with the family of standard C functions typified by `atoi`:

* Conversion is supported in one direction only: from text to internal data type. Converting the other way using the C library requires either the inconvenience and compromised safety of the `sprintf` function, or the loss of portability associated with non-standard functions such as `itoa`.
* The range of types supported is only a subset of the built-in numeric types, namely `int`, `long`, and `double`.
* The range of types cannot be extended in a uniform manner. For instance, conversion from string representation to complex or rational.

The standard C functions typified by `strtol` have the same basic limitations, but offer finer control over the conversion process. However, for the common case such control is often either not required or not used. The `scanf` family of functions offer even greater control, but also lack safety and ease of use.

The standard C++ library offers `stringstream` for the kind of in-core formatting being discussed. It offers a great deal of control over the formatting and conversion of I/O to and from arbitrary types through text. However, for simple conversions direct use of `stringstream` can be either clumsy (with the introduction of extra local variables and the loss of infix-expression convenience) or obscure (where `stringstream` objects are created as temporary objects in an expression). Facets provide a comprehensive concept and facility for controlling textual representation, but their perceived complexity and high entry level requires an extreme degree of involvement for simple conversions, and excludes all but a few programmers.

The `lexical_cast` function template offers a convenient and consistent form for supporting common conversions to and from arbitrary types when they are represented as text. The simplification it offers is in expression-level convenience for such conversions. For more involved conversions, such as where precision or formatting need tighter control than is offered by the default behavior of `lexical_cast`, the conventional `std::stringstream` approach is recommended. Where the conversions are numeric to numeric, __numericcast__ may offer more reasonable behavior than `lexical_cast`.

For a good discussion of the options and issues involved in string-based formatting, including comparison of `stringstream`, `lexical_cast`, and others, see Herb Sutter's article, [@http://www.gotw.ca/publications/mill19.htm The String Formatters of Manor Farm]. Also, take a look at the [link boost_lexical_cast.performance Performance] section.
[endsect]

[section Examples]
The following example treats command line arguments as a sequence of numeric data:
``
    int main(int argc, char * argv[])
    {
        using boost::lexical_cast;
        using boost::bad_lexical_cast;

        std::vector<short> args;

        while(*++argv)
        {
            try
            {
                args.push_back(lexical_cast<short>(*argv));
            }
            catch(bad_lexical_cast &)
            {
                args.push_back(0);
            }
        }
        ...
    }
``
The following example uses numeric data in a string expression:
``
    void log_message(const std::string &);

    void log_errno(int yoko)
    {
        log_message("Error " + boost::lexical_cast<std::string>(yoko) + ": " + strerror(yoko));
    }
``
[endsect]

[section Synopsis]
Library features defined in [@boost:boost/lexical_cast.hpp boost/lexical_cast.hpp]:
``
    namespace boost
    {
        class bad_lexical_cast;
        template<typename Target, typename Source>
          Target lexical_cast(const Source& arg);
    }
``

[section lexical_cast]
``
    template<typename Target, typename Source>
      Target lexical_cast(const Source& arg);
``
Returns the result of streaming arg into a standard library string-based stream and then out as a Target object. Where Target is either `std::string` or `std::wstring`, stream extraction takes the whole content of the string, including spaces, rather than relying on the default `operator>>` behavior. If the conversion is unsuccessful, a `bad_lexical_cast` exception is thrown.

The requirements on the argument and result types are:

* Source is OutputStreamable, meaning that an `operator<<` is defined that takes a `std::ostream` or `std::wostream` object on the left hand side and an instance of the argument type on the right.
* Target is InputStreamable, meaning that an `operator>>` is defined that takes a `std::istream` or `std::wistream` object on the left hand side and an instance of the result type on the right.
* Target is CopyConstructible [20.1.3].
* Target is DefaultConstructible, meaning that it is possible to default-initialize an object of that type [8.5, 20.1.4].

The character type of the underlying stream is assumed to be `char` unless either the `Source` or the `Target` requires wide-character streaming, in which case the underlying stream uses `wchar_t`, `char16_t` or `char32_t`. Wide-character streaming is currently detected for:

* Single character: `wchar_t`, `char16_t`, `char32_t`
* Arrays of characters: `wchar_t *`, `char16_t *`, `char32_t *`, `const wchar_t *`, `const char16_t *`, `const char32_t *`
* Strings: `std::basic_string`, `boost::containers::basic_string`
* `boost::iterator_range<WideCharPtr>`, where `WideCharPtr` is a pointer to wide-character or pointer to const wide-character

[important Many compilers and runtime libraries fail to make conversions using new Unicode characters. Make shure that the following code compiles and outputs nonzero values, before using new types:
``
    std::cout
        << booat::lexical_cast<std::u32string>(1.0).size()
        << "  "
        << booat::lexical_cast<std::u16string>(1.0).size();
``
]

Where a higher degree of control is required over conversions, `std::stringstream` and `std::wstringstream` offer a more appropriate path. Where non-stream-based conversions are required, `lexical_cast` is the wrong tool for the job and is not special-cased for such scenarios.
[endsect]

[section bad_lexical_cast]
``
    class bad_lexical_cast : public std::bad_cast
    {
    public:
        ... // same member function interface as std::exception
    };
``
Exception used to indicate runtime lexical_cast failure.
[endsect]

[endsect]

[/ Commenting out bad advise (this will break the ability to get correct function pointers via &lexical_cast<Target, Source>)
[section Tuning classes for fast lexical conversions]
Because of `boost::lexical_cast` optimizations for `boost::iterator_range<character_type*>`, it is possibile to make very fast lexical conversions for non zero terminated strings, substrings and user-defined classes.

Consider the following example:
``
    class example_class {
        char non_zero_terminated_data[10];
        std::size_t data_length;

    public:
        example_class();
        void fill_data();

        const char* data() const {
            return non_zero_terminated_data;
        }

        std::size_t size() const {
            return data_length;
        }
    };

    inline std::ostream& operator << (std::ostream& ostr, const example_class& rhs) {
        return ostr << boost::make_iterator_range(rhs.data(), rhs.data() + rhs.size());
    }
``

This is a good generic solution for most use cases.
But we can make it even faster for some performance critical applications. During conversion, we loose speed at:

 * `std::ostream` construction     (it makes some heap allocations)
 * `operator <<`                   (it copyies one by one all the symbols to an instance of `std::ostream`)
 * `std::ostream` destruction      (it makes some heap deallocations)

We can avoid all of this, by specifieng an overload for `boost::lexical_cast`:
``
namespace boost {
    template <class OutT>
    OutT lexical_cast(const example_class& rhs) {
        return boost::lexical_cast<OutT>(
            boost::make_iterator_range(rhs.data(), rhs.data() + rhs.size())
        );
    }
}
``
Now `boost::lexical_cast<some_type>(example_class_instance)` conversions won't copy data and construct heavy STL stream objects. See [link boost_lexical_cast.performance Performance] section for info on `boost::iterator_range` conversion performance.
[endsect]
]

[section Frequently Asked Questions]

* [*Question:]    Why does `lexical_cast<int8_t>("127")` throw `bad_lexical_cast`?
  * [*Answer:]      The type `int8_t` is a `typedef` to `char` or `signed char`. Lexical conversion to these types is simply reading a byte from source but since the source has more than one byte, the exception is thrown.
Please use other integer types such as `int` or `short int`. If bounds checking is important, you can also
call __numericcast__:
`numeric_cast<int8_t>(lexical_cast<int>("127"));`

[pre
]

* [*Question:]    Why does `lexical_cast<unsigned char>("127")` throw `bad_lexical_cast`?
  * [*Answer:]      Lexical conversion to any char type is simply reading a byte from source. But since the source has more than one byte, the exception is thrown.
Please use other integer types such as `int` or `short int`. If bounds checking is important, you can also
call __numericcast__:
`numeric_cast<unsigned char>(lexical_cast<int>("127"));`

[pre
]

* [*Question:]    What does `lexical_cast<std::string>` of an `int8_t` or `uint8_t` not do what I expect?
  * [*Answer:]      As above, note that int8_t and uint8_t are actually chars and are formatted as such. To avoid
this, cast to an integer type first: `lexical_cast<std::string>(static_cast<int>(n));`

[pre
]

* [*Question:]    The implementation always resets the `ios_base::skipws` flag of an underlying stream object.
It breaks my `operator>>` that works only in presence of this flag. Can you remove code that resets the flag?
  * [*Answer:]      May be in a future version. There is no requirement in
__proposallong__ to reset the flag but
remember that __proposalshort__ is not yet accepted by the committee. By the way, it's a great opportunity to
make your `operator>>` conform to the standard.
Read a good C++ book, study `std::sentry` and [@boost:libs/io/doc/ios_state.html `ios_state_saver`].

[pre
]

* [*Question:]    Why `std::cout << boost::lexical_cast<unsigned int>("-1");` does not throw, but outputs 4294967295?
  * [*Answer:]      `boost::lexical_cast` has the behavior of `std::stringstream`, which uses `num_get` functions of
`std::locale` to convert numbers. If we look at the Programming languages â€” C++, we'll see, that `num_get` uses
the rules of `scanf` for conversions. And in the C99 standard for unsigned input value minus sign is optional, so
if a negative number is read, no errors will arise and the result will be the two's complement.

[pre
]

* [*Question:]    Why `boost::lexical_cast<int>(L'A');` outputs 65 and `boost::lexical_cast<wchar_t>(L"65");` does not throw?
  * [*Answer:]      If you are using an old version of Visual Studio or compile code with /Zc:wchar_t- flag,
`boost::lexical_cast` sees single `wchar_t` character as `unsigned short`. It is not a `boost::lexical_cast` mistake, but a
limitation of compiler options that you use.

[pre
]

* [*Question:]    Why `boost::lexical_cast<double>("-1.#IND");` throws `boost::bad_lexical_cast`?
  * [*Answer:]      `"-1.#IND"` is a compiler extension, that violates standard. You shall input `"-nan"`, `"nan"`, `"inf"`
, `"-inf"` (case insensitive) strings to get NaN and Inf values. `boost::lexical_cast<string>` outputs `"-nan"`, `"nan"`,
`"inf"`, `"-inf"` strings, when has NaN or Inf input values.

* [*Question:]    What is the fastest way to convert a non zero terminated string or a substring using `boost::lexical_cast`?
  * [*Answer:]      Use `boost::iterator_range` for conversion. For example, if you whant to convert to `int` two characters from a string `str`, you shall write `lexacal_cast<int>(make_iterator_range(str.c_str(), str.c_str() + 2));`.

[endsect]

[section Changes]
* [*boost 1.50.0 :]

    * `boost::bad_lexical_cast` exception is now globaly visible and can be catched even if code is compiled with -fvisibility=hidden.
    * Now it is possible to compile library with disabled exceptions.
    * Better performance, less memory usage and bugfixes for `boost::iterator_range<character_type*>` conversions.

* [*boost 1.49.0 :]

    * Restored work with typedefed wchar_t (compilation flag /Zc:wchar_t- for Visual Studio).
    * Better performance and less memory usage for `boost::container::basic_string` conversions.

* [*boost 1.48.0 :]

    * Added code to work with Inf and NaN on any platform.
    * Better performance and less memory usage for conversions to float type (and to double type, if `sizeof(double) < sizeof(long double)`).

* [*boost 1.47.0 :]

    * Optimizations for "C" and other locales without number grouping.
    * Better performance and less memory usage for unsigned char and signed char conversions.
    * Better performance and less memory usage for conversions to arithmetic types.
    * Better performance and less memory usage for conversions from arithmetic type to arithmetic type.
    * Directly construct Target from Source on some conversions (like conversions from string to string, from char array to string, from char to char and others).

* [*boost 1.34.0 :]

    * Better performance for many combinations of Source and Target types. For more details refer to Alexander Nasonovs article [@http://accu.org/index.php/journals/1375 Fine Tuning for lexical_cast, Overload #74, August 2006] [@http://www.accu.org/var/uploads/journals/overload74.pdf (PDF)].

* [*boost 1.33.0 :]

    * Call-by-const reference for the parameters. This requires partial specialization of class templates, so it doesn't work for MSVC 6, and it uses the original pass by value there.
    * The MSVC 6 support is deprecated, and will be removed in a future Boost version.

* [*Earlier :]

    * The previous version of lexical_cast used the default stream precision for reading and writing floating-point numbers. For numerics that have a corresponding specialization of `std::numeric_limits`, the current version now chooses a precision to match.
    * The previous version of lexical_cast did not support conversion to or from any wide-character-based types. For compilers with full language and library support for wide characters, `lexical_cast` now supports conversions from `wchar_t`, `wchar_t *`, and `std::wstring` and to `wchar_t` and `std::wstring`.
    * The previous version of `lexical_cast` assumed that the conventional stream extractor operators were sufficient for reading values. However, string I/O is asymmetric, with the result that spaces play the role of I/O separators rather than string content. The current version fixes this error for `std::string` and, where supported, `std::wstring`: `lexical_cast<std::string>("Hello, World")` succeeds instead of failing with a `bad_lexical_cast` exception.
    * The previous version of `lexical_cast` allowed unsafe and meaningless conversions to pointers. The current version now throws a `bad_lexical_cast` for conversions to pointers: `lexical_cast<char *>("Goodbye, World")` now throws an exception instead of causing undefined behavior.

[endsect]

[section Performance]

In most cases `boost::lexical_cast` is faster than `scanf`, `printf`, `std::stringstream`. For more detailed info you can look at the tables below.

[section Tests description]
All the tests measure execution speed in milliseconds for 10000 iterations of the following code blocks:
[table:legend Tests source code
[[Test name] [Code]]
[[lexical_cast]
  [``
            _out = boost::lexical_cast<OUTTYPE>(_in);
  ``]
  ]
[[std::stringstream with construction]
  [``
            std::stringstream ss;
            ss << _in;
            if (ss.fail()) throw std::logic_error(descr);
            ss >> _out;
            if (ss.fail()) throw std::logic_error(descr);
  ``]
  ]
[[std::stringstream without construction]
  [``
            ss << _in; // ss is an instance of std::stringstream
            if (ss.fail()) throw std::logic_error(descr);
            ss >> _out;
            if (ss.fail()) throw std::logic_error(descr);
            /* reseting std::stringstream to use it again */
            ss.str(std::string());
            ss.clear();
  ``]
  ]
[[scanf/printf]
  [``
            typename OUTTYPE::value_type buffer[500];
            sprintf( (char*)buffer, conv, _in);
            _out = buffer;
  ``]
  ]
]
Fastest results are highlitened with "!!! *x* !!!".
Do not use this results to compare compilers, because tests were taken on different hardware.

[endsect]

[/ BEGIN of section, generated by performance measuring program ]

[section Clang version 2.9 (tags/RELEASE_29/final)]
[table:id Performance Table ( Clang version 2.9 (tags/RELEASE_29/final))
[[From->To] [lexical_cast] [std::stringstream with construction] [std::stringstream without construction][scanf/printf]]
  [[ string->char ][ !!! *<1* !!! ][ 319 ][ 17 ][ 16 ]]
  [[ string->signed char ][ !!! *<1* !!! ][ 192 ][ 16 ][ 9 ]]
  [[ string->unsigned char ][ !!! *<1* !!! ][ 142 ][ 9 ][ 9 ]]
  [[ string->int ][ !!! *7* !!! ][ 109 ][ 21 ][ 16 ]]
  [[ string->short ][ !!! *6* !!! ][ 113 ][ 21 ][ 15 ]]
  [[ string->long int ][ !!! *7* !!! ][ 110 ][ 22 ][ 15 ]]
  [[ string->long long ][ !!! *7* !!! ][ 112 ][ 23 ][ 17 ]]
  [[ string->unsigned int ][ !!! *6* !!! ][ 107 ][ 19 ][ 14 ]]
  [[ string->unsigned short ][ !!! *6* !!! ][ 106 ][ 18 ][ 16 ]]
  [[ string->unsigned long int ][ !!! *7* !!! ][ 108 ][ 20 ][ 15 ]]
  [[ string->unsigned long long ][ !!! *7* !!! ][ 109 ][ 22 ][ 15 ]]
  [[ string->float ][ !!! *14* !!! ][ 204 ][ 81 ][ 43 ]]
  [[ string->double ][ !!! *24* !!! ][ 244 ][ 74 ][ 45 ]]
  [[ string->long double ][ 121 ][ 170 ][ 62 ][ !!! *38* !!! ]]
  [[ string->string ][ !!! *1* !!! ][ 124 ][ 25 ][ --- ]]
  [[ string->container::string ][ !!! *3* !!! ][ 121 ][ 28 ][ --- ]]
  [[ string->char ][ 6 ][ 115 ][ 26 ][ !!! *6* !!! ]]
  [[ string->signed char ][ !!! *6* !!! ][ 115 ][ 23 ][ 21 ]]
  [[ string->unsigned char ][ !!! *6* !!! ][ 113 ][ 25 ][ 22 ]]
  [[ int->string ][ !!! *12* !!! ][ 128 ][ 29 ][ 19 ]]
  [[ short->string ][ !!! *12* !!! ][ 128 ][ 29 ][ 21 ]]
  [[ long int->string ][ !!! *12* !!! ][ 132 ][ 29 ][ 21 ]]
  [[ long long->string ][ !!! *12* !!! ][ 127 ][ 29 ][ 22 ]]
  [[ unsigned int->string ][ !!! *12* !!! ][ 137 ][ 33 ][ 19 ]]
  [[ unsigned short->string ][ !!! *12* !!! ][ 137 ][ 31 ][ 20 ]]
  [[ unsigned long int->string ][ !!! *12* !!! ][ 136 ][ 30 ][ 21 ]]
  [[ unsigned long long->string ][ !!! *12* !!! ][ 128 ][ 27 ][ 23 ]]
  [[ float->string ][ 51 ][ 187 ][ 82 ][ !!! *44* !!! ]]
  [[ double->string ][ 56 ][ 190 ][ 83 ][ !!! *42* !!! ]]
  [[ long double->string ][ 69 ][ 208 ][ 90 ][ !!! *54* !!! ]]
  [[ char*->char ][ !!! *<1* !!! ][ 138 ][ 18 ][ 8 ]]
  [[ char*->signed char ][ !!! *8* !!! ][ 126 ][ 10 ][ 9 ]]
  [[ char*->unsigned char ][ !!! *<1* !!! ][ 98 ][ 9 ][ 9 ]]
  [[ char*->int ][ !!! *8* !!! ][ 113 ][ 22 ][ 15 ]]
  [[ char*->short ][ !!! *7* !!! ][ 113 ][ 22 ][ 17 ]]
  [[ char*->long int ][ !!! *8* !!! ][ 111 ][ 23 ][ 15 ]]
  [[ char*->long long ][ !!! *9* !!! ][ 112 ][ 24 ][ 18 ]]
  [[ char*->unsigned int ][ !!! *8* !!! ][ 113 ][ 20 ][ 15 ]]
  [[ char*->unsigned short ][ !!! *8* !!! ][ 113 ][ 20 ][ 15 ]]
  [[ char*->unsigned long int ][ !!! *8* !!! ][ 112 ][ 21 ][ 16 ]]
  [[ char*->unsigned long long ][ !!! *9* !!! ][ 110 ][ 23 ][ 14 ]]
  [[ char*->float ][ !!! *14* !!! ][ 149 ][ 54 ][ 32 ]]
  [[ char*->double ][ !!! *15* !!! ][ 166 ][ 59 ][ 33 ]]
  [[ char*->long double ][ 122 ][ 171 ][ 63 ][ !!! *38* !!! ]]
  [[ char*->string ][ !!! *7* !!! ][ 126 ][ 26 ][ --- ]]
  [[ char*->container::string ][ !!! *2* !!! ][ 124 ][ 27 ][ --- ]]
  [[ unsigned char*->char ][ !!! *<1* !!! ][ 99 ][ 10 ][ 8 ]]
  [[ unsigned char*->signed char ][ !!! *<1* !!! ][ 102 ][ 10 ][ 9 ]]
  [[ unsigned char*->unsigned char ][ !!! *<1* !!! ][ 98 ][ 10 ][ 9 ]]
  [[ unsigned char*->int ][ !!! *7* !!! ][ 115 ][ 24 ][ 15 ]]
  [[ unsigned char*->short ][ !!! *7* !!! ][ 115 ][ 25 ][ 17 ]]
  [[ unsigned char*->long int ][ !!! *8* !!! ][ 115 ][ 22 ][ 16 ]]
  [[ unsigned char*->long long ][ !!! *8* !!! ][ 116 ][ 23 ][ 16 ]]
  [[ unsigned char*->unsigned int ][ !!! *8* !!! ][ 113 ][ 20 ][ 14 ]]
  [[ unsigned char*->unsigned short ][ !!! *7* !!! ][ 114 ][ 21 ][ 15 ]]
  [[ unsigned char*->unsigned long int ][ !!! *8* !!! ][ 114 ][ 21 ][ 14 ]]
  [[ unsigned char*->unsigned long long ][ !!! *9* !!! ][ 112 ][ 23 ][ 16 ]]
  [[ unsigned char*->float ][ !!! *14* !!! ][ 149 ][ 52 ][ 32 ]]
  [[ unsigned char*->double ][ !!! *15* !!! ][ 165 ][ 59 ][ 33 ]]
  [[ unsigned char*->long double ][ 122 ][ 172 ][ 63 ][ !!! *37* !!! ]]
  [[ unsigned char*->string ][ !!! *8* !!! ][ 125 ][ 26 ][ --- ]]
  [[ unsigned char*->container::string ][ !!! *4* !!! ][ 119 ][ 26 ][ --- ]]
  [[ signed char*->char ][ !!! *<1* !!! ][ 98 ][ 10 ][ 8 ]]
  [[ signed char*->signed char ][ !!! *<1* !!! ][ 95 ][ 10 ][ 9 ]]
  [[ signed char*->unsigned char ][ !!! *<1* !!! ][ 98 ][ 9 ][ 9 ]]
  [[ signed char*->int ][ !!! *8* !!! ][ 111 ][ 21 ][ 15 ]]
  [[ signed char*->short ][ !!! *7* !!! ][ 114 ][ 22 ][ 16 ]]
  [[ signed char*->long int ][ !!! *8* !!! ][ 113 ][ 22 ][ 17 ]]
  [[ signed char*->long long ][ !!! *8* !!! ][ 116 ][ 24 ][ 17 ]]
  [[ signed char*->unsigned int ][ !!! *8* !!! ][ 109 ][ 20 ][ 15 ]]
  [[ signed char*->unsigned short ][ !!! *8* !!! ][ 111 ][ 20 ][ 14 ]]
  [[ signed char*->unsigned long int ][ !!! *8* !!! ][ 109 ][ 22 ][ 15 ]]
  [[ signed char*->unsigned long long ][ !!! *8* !!! ][ 111 ][ 23 ][ 15 ]]
  [[ signed char*->float ][ !!! *14* !!! ][ 150 ][ 53 ][ 32 ]]
  [[ signed char*->double ][ !!! *15* !!! ][ 168 ][ 59 ][ 30 ]]
  [[ signed char*->long double ][ 123 ][ 174 ][ 62 ][ !!! *37* !!! ]]
  [[ signed char*->string ][ !!! *8* !!! ][ 127 ][ 28 ][ --- ]]
  [[ signed char*->container::string ][ !!! *4* !!! ][ 124 ][ 27 ][ --- ]]
  [[ iterator_range<char*>->char ][ !!! *<1* !!! ][ 103 ][ 13 ][ 8 ]]
  [[ iterator_range<char*>->signed char ][ !!! *<1* !!! ][ 107 ][ 13 ][ 9 ]]
  [[ iterator_range<char*>->unsigned char ][ !!! *<1* !!! ][ 121 ][ 26 ][ 13 ]]
  [[ iterator_range<char*>->int ][ !!! *6* !!! ][ 165 ][ 33 ][ 23 ]]
  [[ iterator_range<char*>->short ][ !!! *8* !!! ][ 175 ][ 34 ][ 29 ]]
  [[ iterator_range<char*>->long int ][ !!! *14* !!! ][ 160 ][ 33 ][ 23 ]]
  [[ iterator_range<char*>->long long ][ !!! *10* !!! ][ 199 ][ 35 ][ 28 ]]
  [[ iterator_range<char*>->unsigned int ][ !!! *6* !!! ][ 131 ][ 24 ][ 16 ]]
  [[ iterator_range<char*>->unsigned short ][ !!! *7* !!! ][ 110 ][ 22 ][ 16 ]]
  [[ iterator_range<char*>->unsigned long int ][ !!! *7* !!! ][ 111 ][ 22 ][ 14 ]]
  [[ iterator_range<char*>->unsigned long long ][ !!! *8* !!! ][ 115 ][ 24 ][ 15 ]]
  [[ iterator_range<char*>->float ][ !!! *13* !!! ][ 134 ][ 40 ][ 33 ]]
  [[ iterator_range<char*>->double ][ !!! *15* !!! ][ 140 ][ 59 ][ 41 ]]
  [[ iterator_range<char*>->long double ][ 131 ][ 146 ][ 53 ][ !!! *38* !!! ]]
  [[ iterator_range<char*>->string ][ !!! *9* !!! ][ 121 ][ 31 ][ --- ]]
  [[ iterator_range<char*>->container::string ][ !!! *4* !!! ][ 115 ][ 25 ][ --- ]]
  [[ int->int ][ !!! *<1* !!! ][ 113 ][ 25 ][ --- ]]
  [[ float->double ][ !!! *<1* !!! ][ 234 ][ 117 ][ --- ]]
  [[ char->signed char ][ !!! *<1* !!! ][ 97 ][ 9 ][ --- ]]
]
[endsect]

[section GNU C++ version 4.6.1]
[table:id Performance Table ( GNU C++ version 4.6.1)
[[From->To] [lexical_cast] [std::stringstream with construction] [std::stringstream without construction][scanf/printf]]
  [[ string->char ][ !!! *<1* !!! ][ 140 ][ 17 ][ 13 ]]
  [[ string->signed char ][ !!! *<1* !!! ][ 129 ][ 8 ][ 10 ]]
  [[ string->unsigned char ][ !!! *<1* !!! ][ 91 ][ 8 ][ 10 ]]
  [[ string->int ][ !!! *6* !!! ][ 110 ][ 20 ][ 14 ]]
  [[ string->short ][ !!! *5* !!! ][ 106 ][ 20 ][ 14 ]]
  [[ string->long int ][ !!! *7* !!! ][ 107 ][ 22 ][ 14 ]]
  [[ string->long long ][ !!! *7* !!! ][ 112 ][ 21 ][ 14 ]]
  [[ string->unsigned int ][ !!! *6* !!! ][ 110 ][ 20 ][ 14 ]]
  [[ string->unsigned short ][ !!! *5* !!! ][ 107 ][ 18 ][ 14 ]]
  [[ string->unsigned long int ][ !!! *7* !!! ][ 108 ][ 23 ][ 14 ]]
  [[ string->unsigned long long ][ !!! *7* !!! ][ 108 ][ 21 ][ 14 ]]
  [[ string->float ][ !!! *12* !!! ][ 154 ][ 57 ][ 32 ]]
  [[ string->double ][ !!! *11* !!! ][ 151 ][ 61 ][ 33 ]]
  [[ string->long double ][ 109 ][ 187 ][ 79 ][ !!! *55* !!! ]]
  [[ string->string ][ !!! *2* !!! ][ 122 ][ 27 ][ --- ]]
  [[ string->container::string ][ !!! *3* !!! ][ 123 ][ 22 ][ --- ]]
  [[ string->char ][ !!! *7* !!! ][ 109 ][ 27 ][ 17 ]]
  [[ string->signed char ][ !!! *7* !!! ][ 110 ][ 25 ][ 22 ]]
  [[ string->unsigned char ][ !!! *7* !!! ][ 112 ][ 27 ][ 24 ]]
  [[ int->string ][ !!! *12* !!! ][ 187 ][ 48 ][ 37 ]]
  [[ short->string ][ !!! *18* !!! ][ 133 ][ 33 ][ 20 ]]
  [[ long int->string ][ !!! *12* !!! ][ 129 ][ 32 ][ 21 ]]
  [[ long long->string ][ !!! *12* !!! ][ 127 ][ 35 ][ 23 ]]
  [[ unsigned int->string ][ !!! *15* !!! ][ 133 ][ 31 ][ 21 ]]
  [[ unsigned short->string ][ !!! *12* !!! ][ 133 ][ 31 ][ 21 ]]
  [[ unsigned long int->string ][ !!! *12* !!! ][ 132 ][ 31 ][ 21 ]]
  [[ unsigned long long->string ][ !!! *12* !!! ][ 127 ][ 29 ][ 24 ]]
  [[ float->string ][ 53 ][ 215 ][ 103 ][ !!! *40* !!! ]]
  [[ double->string ][ 58 ][ 215 ][ 103 ][ !!! *41* !!! ]]
  [[ long double->string ][ 67 ][ 227 ][ 112 ][ !!! *45* !!! ]]
  [[ char*->char ][ !!! *<1* !!! ][ 132 ][ 12 ][ 8 ]]
  [[ char*->signed char ][ !!! *<1* !!! ][ 98 ][ 11 ][ 9 ]]
  [[ char*->unsigned char ][ !!! *<1* !!! ][ 96 ][ 10 ][ 9 ]]
  [[ char*->int ][ !!! *6* !!! ][ 109 ][ 22 ][ 14 ]]
  [[ char*->short ][ !!! *5* !!! ][ 109 ][ 26 ][ 14 ]]
  [[ char*->long int ][ !!! *7* !!! ][ 111 ][ 23 ][ 14 ]]
  [[ char*->long long ][ !!! *8* !!! ][ 112 ][ 25 ][ 16 ]]
  [[ char*->unsigned int ][ !!! *6* !!! ][ 113 ][ 19 ][ 14 ]]
  [[ char*->unsigned short ][ !!! *6* !!! ][ 111 ][ 20 ][ 14 ]]
  [[ char*->unsigned long int ][ !!! *7* !!! ][ 109 ][ 21 ][ 14 ]]
  [[ char*->unsigned long long ][ !!! *7* !!! ][ 111 ][ 22 ][ 14 ]]
  [[ char*->float ][ !!! *12* !!! ][ 156 ][ 62 ][ 32 ]]
  [[ char*->double ][ !!! *13* !!! ][ 156 ][ 65 ][ 33 ]]
  [[ char*->long double ][ 108 ][ 156 ][ 59 ][ !!! *36* !!! ]]
  [[ char*->string ][ !!! *7* !!! ][ 123 ][ 29 ][ --- ]]
  [[ char*->container::string ][ !!! *2* !!! ][ 116 ][ 24 ][ --- ]]
  [[ unsigned char*->char ][ !!! *<1* !!! ][ 96 ][ 12 ][ 8 ]]
  [[ unsigned char*->signed char ][ !!! *<1* !!! ][ 97 ][ 9 ][ 9 ]]
  [[ unsigned char*->unsigned char ][ !!! *<1* !!! ][ 93 ][ 10 ][ 9 ]]
  [[ unsigned char*->int ][ !!! *6* !!! ][ 110 ][ 22 ][ 14 ]]
  [[ unsigned char*->short ][ !!! *6* !!! ][ 111 ][ 22 ][ 15 ]]
  [[ unsigned char*->long int ][ !!! *8* !!! ][ 110 ][ 23 ][ 14 ]]
  [[ unsigned char*->long long ][ !!! *7* !!! ][ 111 ][ 25 ][ 14 ]]
  [[ unsigned char*->unsigned int ][ !!! *6* !!! ][ 111 ][ 21 ][ 16 ]]
  [[ unsigned char*->unsigned short ][ !!! *6* !!! ][ 110 ][ 21 ][ 15 ]]
  [[ unsigned char*->unsigned long int ][ !!! *8* !!! ][ 114 ][ 21 ][ 14 ]]
  [[ unsigned char*->unsigned long long ][ !!! *8* !!! ][ 108 ][ 23 ][ 15 ]]
  [[ unsigned char*->float ][ !!! *12* !!! ][ 154 ][ 62 ][ 33 ]]
  [[ unsigned char*->double ][ !!! *14* !!! ][ 157 ][ 65 ][ 32 ]]
  [[ unsigned char*->long double ][ 107 ][ 154 ][ 56 ][ !!! *36* !!! ]]
  [[ unsigned char*->string ][ !!! *9* !!! ][ 122 ][ 28 ][ --- ]]
  [[ unsigned char*->container::string ][ !!! *4* !!! ][ 118 ][ 26 ][ --- ]]
  [[ signed char*->char ][ !!! *<1* !!! ][ 94 ][ 10 ][ 8 ]]
  [[ signed char*->signed char ][ !!! *<1* !!! ][ 94 ][ 12 ][ 9 ]]
  [[ signed char*->unsigned char ][ !!! *<1* !!! ][ 95 ][ 12 ][ 9 ]]
  [[ signed char*->int ][ !!! *7* !!! ][ 109 ][ 22 ][ 14 ]]
  [[ signed char*->short ][ !!! *5* !!! ][ 108 ][ 22 ][ 14 ]]
  [[ signed char*->long int ][ !!! *7* !!! ][ 110 ][ 23 ][ 14 ]]
  [[ signed char*->long long ][ !!! *7* !!! ][ 110 ][ 25 ][ 15 ]]
  [[ signed char*->unsigned int ][ !!! *6* !!! ][ 109 ][ 20 ][ 15 ]]
  [[ signed char*->unsigned short ][ !!! *6* !!! ][ 107 ][ 21 ][ 14 ]]
  [[ signed char*->unsigned long int ][ !!! *8* !!! ][ 111 ][ 21 ][ 14 ]]
  [[ signed char*->unsigned long long ][ !!! *7* !!! ][ 109 ][ 23 ][ 14 ]]
  [[ signed char*->float ][ !!! *12* !!! ][ 156 ][ 61 ][ 31 ]]
  [[ signed char*->double ][ !!! *13* !!! ][ 156 ][ 68 ][ 33 ]]
  [[ signed char*->long double ][ 109 ][ 159 ][ 56 ][ !!! *36* !!! ]]
  [[ signed char*->string ][ !!! *9* !!! ][ 123 ][ 28 ][ --- ]]
  [[ signed char*->container::string ][ !!! *4* !!! ][ 125 ][ 25 ][ --- ]]
  [[ iterator_range<char*>->char ][ !!! *<1* !!! ][ 100 ][ 13 ][ 8 ]]
  [[ iterator_range<char*>->signed char ][ !!! *<1* !!! ][ 98 ][ 14 ][ 9 ]]
  [[ iterator_range<char*>->unsigned char ][ !!! *<1* !!! ][ 99 ][ 12 ][ 10 ]]
  [[ iterator_range<char*>->int ][ !!! *6* !!! ][ 108 ][ 21 ][ 16 ]]
  [[ iterator_range<char*>->short ][ !!! *5* !!! ][ 110 ][ 22 ][ 17 ]]
  [[ iterator_range<char*>->long int ][ !!! *7* !!! ][ 107 ][ 22 ][ 15 ]]
  [[ iterator_range<char*>->long long ][ !!! *7* !!! ][ 110 ][ 27 ][ 15 ]]
  [[ iterator_range<char*>->unsigned int ][ !!! *6* !!! ][ 107 ][ 24 ][ 15 ]]
  [[ iterator_range<char*>->unsigned short ][ !!! *5* !!! ][ 106 ][ 21 ][ 15 ]]
  [[ iterator_range<char*>->unsigned long int ][ !!! *7* !!! ][ 110 ][ 21 ][ 16 ]]
  [[ iterator_range<char*>->unsigned long long ][ !!! *7* !!! ][ 109 ][ 23 ][ 16 ]]
  [[ iterator_range<char*>->float ][ !!! *11* !!! ][ 137 ][ 46 ][ 33 ]]
  [[ iterator_range<char*>->double ][ !!! *11* !!! ][ 131 ][ 50 ][ 33 ]]
  [[ iterator_range<char*>->long double ][ 107 ][ 136 ][ 44 ][ !!! *39* !!! ]]
  [[ iterator_range<char*>->string ][ !!! *8* !!! ][ 117 ][ 32 ][ --- ]]
  [[ iterator_range<char*>->container::string ][ !!! *3* !!! ][ 111 ][ 23 ][ --- ]]
  [[ int->int ][ !!! *<1* !!! ][ 110 ][ 33 ][ --- ]]
  [[ float->double ][ !!! *<1* !!! ][ 241 ][ 152 ][ --- ]]
  [[ char->signed char ][ !!! *<1* !!! ][ 90 ][ 8 ][ --- ]]
]
[endsect]

[section GNU C++ version 4.5.4]
[table:id Performance Table ( GNU C++ version 4.5.4)
[[From->To] [lexical_cast] [std::stringstream with construction] [std::stringstream without construction][scanf/printf]]
  [[ string->char ][ !!! *<1* !!! ][ 147 ][ 12 ][ 8 ]]
  [[ string->signed char ][ !!! *<1* !!! ][ 138 ][ 13 ][ 10 ]]
  [[ string->unsigned char ][ !!! *<1* !!! ][ 86 ][ 12 ][ 9 ]]
  [[ string->int ][ !!! *7* !!! ][ 103 ][ 20 ][ 15 ]]
  [[ string->short ][ !!! *5* !!! ][ 103 ][ 20 ][ 15 ]]
  [[ string->long int ][ !!! *7* !!! ][ 103 ][ 22 ][ 15 ]]
  [[ string->long long ][ !!! *7* !!! ][ 104 ][ 22 ][ 16 ]]
  [[ string->unsigned int ][ !!! *6* !!! ][ 108 ][ 19 ][ 15 ]]
  [[ string->unsigned short ][ !!! *5* !!! ][ 104 ][ 19 ][ 15 ]]
  [[ string->unsigned long int ][ !!! *7* !!! ][ 103 ][ 20 ][ 16 ]]
  [[ string->unsigned long long ][ !!! *7* !!! ][ 101 ][ 22 ][ 14 ]]
  [[ string->float ][ !!! *13* !!! ][ 148 ][ 58 ][ 35 ]]
  [[ string->double ][ !!! *13* !!! ][ 147 ][ 60 ][ 34 ]]
  [[ string->long double ][ 103 ][ 149 ][ 56 ][ !!! *38* !!! ]]
  [[ string->string ][ !!! *2* !!! ][ 127 ][ 27 ][ --- ]]
  [[ string->container::string ][ !!! *3* !!! ][ 101 ][ 24 ][ --- ]]
  [[ string->char ][ !!! *7* !!! ][ 108 ][ 35 ][ 17 ]]
  [[ string->signed char ][ !!! *7* !!! ][ 112 ][ 26 ][ 23 ]]
  [[ string->unsigned char ][ !!! *7* !!! ][ 113 ][ 25 ][ 25 ]]
  [[ int->string ][ !!! *11* !!! ][ 183 ][ 47 ][ 40 ]]
  [[ short->string ][ !!! *14* !!! ][ 153 ][ 35 ][ 23 ]]
  [[ long int->string ][ !!! *12* !!! ][ 135 ][ 32 ][ 22 ]]
  [[ long long->string ][ !!! *11* !!! ][ 131 ][ 30 ][ 24 ]]
  [[ unsigned int->string ][ !!! *12* !!! ][ 137 ][ 31 ][ 22 ]]
  [[ unsigned short->string ][ !!! *11* !!! ][ 137 ][ 33 ][ 22 ]]
  [[ unsigned long int->string ][ !!! *11* !!! ][ 136 ][ 36 ][ 23 ]]
  [[ unsigned long long->string ][ !!! *11* !!! ][ 127 ][ 29 ][ 23 ]]
  [[ float->string ][ 56 ][ 218 ][ 107 ][ !!! *44* !!! ]]
  [[ double->string ][ 63 ][ 223 ][ 106 ][ !!! *44* !!! ]]
  [[ long double->string ][ 69 ][ 229 ][ 118 ][ !!! *49* !!! ]]
  [[ char*->char ][ !!! *<1* !!! ][ 91 ][ 12 ][ 9 ]]
  [[ char*->signed char ][ !!! *<1* !!! ][ 100 ][ 11 ][ 11 ]]
  [[ char*->unsigned char ][ !!! *<1* !!! ][ 97 ][ 12 ][ 10 ]]
  [[ char*->int ][ !!! *7* !!! ][ 112 ][ 23 ][ 16 ]]
  [[ char*->short ][ !!! *6* !!! ][ 116 ][ 23 ][ 16 ]]
  [[ char*->long int ][ !!! *8* !!! ][ 113 ][ 23 ][ 16 ]]
  [[ char*->long long ][ !!! *8* !!! ][ 122 ][ 28 ][ 16 ]]
  [[ char*->unsigned int ][ !!! *6* !!! ][ 117 ][ 21 ][ 15 ]]
  [[ char*->unsigned short ][ !!! *6* !!! ][ 113 ][ 21 ][ 16 ]]
  [[ char*->unsigned long int ][ !!! *7* !!! ][ 118 ][ 22 ][ 16 ]]
  [[ char*->unsigned long long ][ !!! *8* !!! ][ 113 ][ 22 ][ 17 ]]
  [[ char*->float ][ !!! *11* !!! ][ 164 ][ 67 ][ 34 ]]
  [[ char*->double ][ !!! *13* !!! ][ 163 ][ 66 ][ 35 ]]
  [[ char*->long double ][ 110 ][ 164 ][ 63 ][ !!! *39* !!! ]]
  [[ char*->string ][ !!! *8* !!! ][ 130 ][ 30 ][ --- ]]
  [[ char*->container::string ][ !!! *2* !!! ][ 113 ][ 24 ][ --- ]]
  [[ unsigned char*->char ][ !!! *<1* !!! ][ 98 ][ 11 ][ 10 ]]
  [[ unsigned char*->signed char ][ !!! *<1* !!! ][ 97 ][ 12 ][ 10 ]]
  [[ unsigned char*->unsigned char ][ !!! *<1* !!! ][ 97 ][ 11 ][ 10 ]]
  [[ unsigned char*->int ][ !!! *7* !!! ][ 112 ][ 23 ][ 16 ]]
  [[ unsigned char*->short ][ !!! *6* !!! ][ 115 ][ 22 ][ 20 ]]
  [[ unsigned char*->long int ][ !!! *8* !!! ][ 112 ][ 23 ][ 15 ]]
  [[ unsigned char*->long long ][ !!! *8* !!! ][ 115 ][ 29 ][ 17 ]]
  [[ unsigned char*->unsigned int ][ !!! *6* !!! ][ 114 ][ 21 ][ 14 ]]
  [[ unsigned char*->unsigned short ][ !!! *7* !!! ][ 112 ][ 22 ][ 15 ]]
  [[ unsigned char*->unsigned long int ][ !!! *7* !!! ][ 115 ][ 23 ][ 14 ]]
  [[ unsigned char*->unsigned long long ][ !!! *8* !!! ][ 112 ][ 24 ][ 15 ]]
  [[ unsigned char*->float ][ !!! *12* !!! ][ 161 ][ 66 ][ 34 ]]
  [[ unsigned char*->double ][ !!! *13* !!! ][ 162 ][ 66 ][ 36 ]]
  [[ unsigned char*->long double ][ 112 ][ 161 ][ 63 ][ !!! *39* !!! ]]
  [[ unsigned char*->string ][ !!! *9* !!! ][ 127 ][ 29 ][ --- ]]
  [[ unsigned char*->container::string ][ !!! *4* !!! ][ 111 ][ 25 ][ --- ]]
  [[ signed char*->char ][ !!! *<1* !!! ][ 104 ][ 11 ][ 8 ]]
  [[ signed char*->signed char ][ !!! *<1* !!! ][ 98 ][ 11 ][ 11 ]]
  [[ signed char*->unsigned char ][ !!! *<1* !!! ][ 98 ][ 11 ][ 11 ]]
  [[ signed char*->int ][ !!! *7* !!! ][ 112 ][ 23 ][ 16 ]]
  [[ signed char*->short ][ !!! *7* !!! ][ 113 ][ 23 ][ 15 ]]
  [[ signed char*->long int ][ !!! *8* !!! ][ 112 ][ 22 ][ 14 ]]
  [[ signed char*->long long ][ !!! *8* !!! ][ 115 ][ 25 ][ 16 ]]
  [[ signed char*->unsigned int ][ !!! *8* !!! ][ 114 ][ 21 ][ 18 ]]
  [[ signed char*->unsigned short ][ !!! *6* !!! ][ 112 ][ 22 ][ 15 ]]
  [[ signed char*->unsigned long int ][ !!! *8* !!! ][ 116 ][ 22 ][ 15 ]]
  [[ signed char*->unsigned long long ][ !!! *8* !!! ][ 113 ][ 23 ][ 16 ]]
  [[ signed char*->float ][ !!! *13* !!! ][ 161 ][ 65 ][ 34 ]]
  [[ signed char*->double ][ !!! *12* !!! ][ 172 ][ 67 ][ 34 ]]
  [[ signed char*->long double ][ 110 ][ 164 ][ 63 ][ !!! *38* !!! ]]
  [[ signed char*->string ][ !!! *9* !!! ][ 131 ][ 30 ][ --- ]]
  [[ signed char*->container::string ][ !!! *4* !!! ][ 112 ][ 24 ][ --- ]]
  [[ iterator_range<char*>->char ][ !!! *<1* !!! ][ 103 ][ 12 ][ 8 ]]
  [[ iterator_range<char*>->signed char ][ !!! *<1* !!! ][ 101 ][ 13 ][ 9 ]]
  [[ iterator_range<char*>->unsigned char ][ !!! *<1* !!! ][ 103 ][ 13 ][ 10 ]]
  [[ iterator_range<char*>->int ][ !!! *7* !!! ][ 113 ][ 26 ][ 14 ]]
  [[ iterator_range<char*>->short ][ !!! *5* !!! ][ 115 ][ 21 ][ 16 ]]
  [[ iterator_range<char*>->long int ][ !!! *7* !!! ][ 115 ][ 22 ][ 15 ]]
  [[ iterator_range<char*>->long long ][ !!! *7* !!! ][ 116 ][ 25 ][ 16 ]]
  [[ iterator_range<char*>->unsigned int ][ !!! *6* !!! ][ 115 ][ 24 ][ 23 ]]
  [[ iterator_range<char*>->unsigned short ][ !!! *5* !!! ][ 113 ][ 22 ][ 16 ]]
  [[ iterator_range<char*>->unsigned long int ][ !!! *7* !!! ][ 117 ][ 20 ][ 16 ]]
  [[ iterator_range<char*>->unsigned long long ][ !!! *7* !!! ][ 114 ][ 21 ][ 16 ]]
  [[ iterator_range<char*>->float ][ !!! *11* !!! ][ 145 ][ 51 ][ 34 ]]
  [[ iterator_range<char*>->double ][ !!! *11* !!! ][ 139 ][ 53 ][ 35 ]]
  [[ iterator_range<char*>->long double ][ 109 ][ 147 ][ 44 ][ !!! *38* !!! ]]
  [[ iterator_range<char*>->string ][ !!! *9* !!! ][ 123 ][ 36 ][ --- ]]
  [[ iterator_range<char*>->container::string ][ !!! *3* !!! ][ 113 ][ 20 ][ --- ]]
  [[ int->int ][ !!! *<1* !!! ][ 117 ][ 23 ][ --- ]]
  [[ float->double ][ !!! *<1* !!! ][ 262 ][ 150 ][ --- ]]
  [[ char->signed char ][ !!! *<1* !!! ][ 97 ][ 9 ][ --- ]]
]
[endsect]

[section GNU C++ version 4.4.6]
[table:id Performance Table ( GNU C++ version 4.4.6)
[[From->To] [lexical_cast] [std::stringstream with construction] [std::stringstream without construction][scanf/printf]]
  [[ string->char ][ !!! *<1* !!! ][ 162 ][ 17 ][ 8 ]]
  [[ string->signed char ][ !!! *<1* !!! ][ 103 ][ 9 ][ 9 ]]
  [[ string->unsigned char ][ !!! *<1* !!! ][ 91 ][ 9 ][ 9 ]]
  [[ string->int ][ !!! *6* !!! ][ 104 ][ 21 ][ 14 ]]
  [[ string->short ][ !!! *5* !!! ][ 107 ][ 22 ][ 14 ]]
  [[ string->long int ][ !!! *7* !!! ][ 106 ][ 23 ][ 15 ]]
  [[ string->long long ][ !!! *7* !!! ][ 104 ][ 21 ][ 16 ]]
  [[ string->unsigned int ][ !!! *6* !!! ][ 100 ][ 20 ][ 16 ]]
  [[ string->unsigned short ][ !!! *5* !!! ][ 102 ][ 20 ][ 16 ]]
  [[ string->unsigned long int ][ !!! *7* !!! ][ 106 ][ 25 ][ 16 ]]
  [[ string->unsigned long long ][ !!! *7* !!! ][ 109 ][ 25 ][ 14 ]]
  [[ string->float ][ !!! *13* !!! ][ 142 ][ 48 ][ 32 ]]
  [[ string->double ][ !!! *13* !!! ][ 162 ][ 62 ][ 33 ]]
  [[ string->long double ][ 119 ][ 164 ][ 62 ][ !!! *37* !!! ]]
  [[ string->string ][ !!! *2* !!! ][ 122 ][ 27 ][ --- ]]
  [[ string->container::string ][ !!! *2* !!! ][ 107 ][ 23 ][ --- ]]
  [[ string->char ][ !!! *6* !!! ][ 110 ][ 24 ][ 15 ]]
  [[ string->signed char ][ !!! *6* !!! ][ 107 ][ 24 ][ 21 ]]
  [[ string->unsigned char ][ !!! *6* !!! ][ 106 ][ 27 ][ 21 ]]
  [[ int->string ][ !!! *12* !!! ][ 122 ][ 31 ][ 21 ]]
  [[ short->string ][ !!! *12* !!! ][ 136 ][ 29 ][ 20 ]]
  [[ long int->string ][ !!! *12* !!! ][ 127 ][ 32 ][ 19 ]]
  [[ long long->string ][ !!! *12* !!! ][ 121 ][ 32 ][ 21 ]]
  [[ unsigned int->string ][ !!! *12* !!! ][ 133 ][ 32 ][ 19 ]]
  [[ unsigned short->string ][ !!! *12* !!! ][ 126 ][ 33 ][ 20 ]]
  [[ unsigned long int->string ][ !!! *11* !!! ][ 126 ][ 34 ][ 19 ]]
  [[ unsigned long long->string ][ !!! *12* !!! ][ 125 ][ 28 ][ 21 ]]
  [[ float->string ][ 47 ][ 183 ][ 86 ][ !!! *43* !!! ]]
  [[ double->string ][ 57 ][ 184 ][ 90 ][ !!! *42* !!! ]]
  [[ long double->string ][ 64 ][ 199 ][ 87 ][ !!! *46* !!! ]]
  [[ char*->char ][ !!! *<1* !!! ][ 95 ][ 10 ][ 8 ]]
  [[ char*->signed char ][ !!! *<1* !!! ][ 90 ][ 12 ][ 9 ]]
  [[ char*->unsigned char ][ !!! *<1* !!! ][ 93 ][ 12 ][ 9 ]]
  [[ char*->int ][ !!! *6* !!! ][ 108 ][ 24 ][ 14 ]]
  [[ char*->short ][ !!! *6* !!! ][ 106 ][ 23 ][ 14 ]]
  [[ char*->long int ][ !!! *7* !!! ][ 107 ][ 24 ][ 17 ]]
  [[ char*->long long ][ !!! *7* !!! ][ 109 ][ 25 ][ 17 ]]
  [[ char*->unsigned int ][ !!! *6* !!! ][ 104 ][ 23 ][ 17 ]]
  [[ char*->unsigned short ][ !!! *6* !!! ][ 102 ][ 22 ][ 17 ]]
  [[ char*->unsigned long int ][ !!! *7* !!! ][ 107 ][ 23 ][ 17 ]]
  [[ char*->unsigned long long ][ !!! *7* !!! ][ 115 ][ 26 ][ 14 ]]
  [[ char*->float ][ !!! *12* !!! ][ 150 ][ 56 ][ 30 ]]
  [[ char*->double ][ !!! *12* !!! ][ 165 ][ 66 ][ 32 ]]
  [[ char*->long double ][ 116 ][ 173 ][ 66 ][ !!! *37* !!! ]]
  [[ char*->string ][ !!! *7* !!! ][ 120 ][ 28 ][ --- ]]
  [[ char*->container::string ][ !!! *2* !!! ][ 108 ][ 26 ][ --- ]]
  [[ unsigned char*->char ][ !!! *<1* !!! ][ 90 ][ 12 ][ 8 ]]
  [[ unsigned char*->signed char ][ !!! *<1* !!! ][ 91 ][ 11 ][ 9 ]]
  [[ unsigned char*->unsigned char ][ !!! *<1* !!! ][ 91 ][ 12 ][ 9 ]]
  [[ unsigned char*->int ][ !!! *6* !!! ][ 106 ][ 24 ][ 14 ]]
  [[ unsigned char*->short ][ !!! *6* !!! ][ 108 ][ 24 ][ 14 ]]
  [[ unsigned char*->long int ][ !!! *7* !!! ][ 116 ][ 23 ][ 14 ]]
  [[ unsigned char*->long long ][ !!! *7* !!! ][ 108 ][ 28 ][ 14 ]]
  [[ unsigned char*->unsigned int ][ !!! *6* !!! ][ 107 ][ 22 ][ 14 ]]
  [[ unsigned char*->unsigned short ][ !!! *6* !!! ][ 105 ][ 21 ][ 16 ]]
  [[ unsigned char*->unsigned long int ][ !!! *7* !!! ][ 106 ][ 25 ][ 16 ]]
  [[ unsigned char*->unsigned long long ][ !!! *7* !!! ][ 105 ][ 24 ][ 17 ]]
  [[ unsigned char*->float ][ !!! *14* !!! ][ 150 ][ 57 ][ 33 ]]
  [[ unsigned char*->double ][ !!! *14* !!! ][ 171 ][ 72 ][ 34 ]]
  [[ unsigned char*->long double ][ 118 ][ 171 ][ 73 ][ !!! *38* !!! ]]
  [[ unsigned char*->string ][ !!! *8* !!! ][ 120 ][ 29 ][ --- ]]
  [[ unsigned char*->container::string ][ !!! *3* !!! ][ 114 ][ 26 ][ --- ]]
  [[ signed char*->char ][ !!! *<1* !!! ][ 92 ][ 12 ][ 8 ]]
  [[ signed char*->signed char ][ !!! *<1* !!! ][ 92 ][ 12 ][ 9 ]]
  [[ signed char*->unsigned char ][ !!! *<1* !!! ][ 91 ][ 14 ][ 9 ]]
  [[ signed char*->int ][ !!! *6* !!! ][ 109 ][ 22 ][ 15 ]]
  [[ signed char*->short ][ !!! *6* !!! ][ 106 ][ 24 ][ 17 ]]
  [[ signed char*->long int ][ !!! *7* !!! ][ 107 ][ 24 ][ 16 ]]
  [[ signed char*->long long ][ !!! *7* !!! ][ 106 ][ 24 ][ 14 ]]
  [[ signed char*->unsigned int ][ !!! *6* !!! ][ 106 ][ 22 ][ 14 ]]
  [[ signed char*->unsigned short ][ !!! *6* !!! ][ 104 ][ 20 ][ 14 ]]
  [[ signed char*->unsigned long int ][ !!! *7* !!! ][ 105 ][ 22 ][ 16 ]]
  [[ signed char*->unsigned long long ][ !!! *7* !!! ][ 108 ][ 24 ][ 15 ]]
  [[ signed char*->float ][ !!! *14* !!! ][ 147 ][ 54 ][ 32 ]]
  [[ signed char*->double ][ !!! *14* !!! ][ 170 ][ 68 ][ 37 ]]
  [[ signed char*->long double ][ 133 ][ 167 ][ 66 ][ !!! *37* !!! ]]
  [[ signed char*->string ][ !!! *8* !!! ][ 119 ][ 30 ][ --- ]]
  [[ signed char*->container::string ][ !!! *3* !!! ][ 108 ][ 24 ][ --- ]]
  [[ iterator_range<char*>->char ][ !!! *<1* !!! ][ 98 ][ 13 ][ 8 ]]
  [[ iterator_range<char*>->signed char ][ !!! *<1* !!! ][ 98 ][ 15 ][ 9 ]]
  [[ iterator_range<char*>->unsigned char ][ !!! *<1* !!! ][ 97 ][ 15 ][ 9 ]]
  [[ iterator_range<char*>->int ][ !!! *6* !!! ][ 107 ][ 27 ][ 14 ]]
  [[ iterator_range<char*>->short ][ !!! *5* !!! ][ 109 ][ 23 ][ 14 ]]
  [[ iterator_range<char*>->long int ][ !!! *7* !!! ][ 109 ][ 22 ][ 14 ]]
  [[ iterator_range<char*>->long long ][ !!! *7* !!! ][ 107 ][ 24 ][ 14 ]]
  [[ iterator_range<char*>->unsigned int ][ !!! *6* !!! ][ 120 ][ 23 ][ 14 ]]
  [[ iterator_range<char*>->unsigned short ][ !!! *5* !!! ][ 104 ][ 21 ][ 17 ]]
  [[ iterator_range<char*>->unsigned long int ][ !!! *8* !!! ][ 108 ][ 25 ][ 16 ]]
  [[ iterator_range<char*>->unsigned long long ][ !!! *7* !!! ][ 106 ][ 25 ][ 15 ]]
  [[ iterator_range<char*>->float ][ !!! *13* !!! ][ 132 ][ 41 ][ 32 ]]
  [[ iterator_range<char*>->double ][ !!! *12* !!! ][ 136 ][ 45 ][ 32 ]]
  [[ iterator_range<char*>->long double ][ 113 ][ 138 ][ 50 ][ !!! *36* !!! ]]
  [[ iterator_range<char*>->string ][ !!! *7* !!! ][ 114 ][ 33 ][ --- ]]
  [[ iterator_range<char*>->container::string ][ !!! *2* !!! ][ 105 ][ 24 ][ --- ]]
  [[ int->int ][ !!! *<1* !!! ][ 112 ][ 31 ][ --- ]]
  [[ float->double ][ !!! *<1* !!! ][ 233 ][ 199 ][ --- ]]
  [[ char->signed char ][ !!! *<1* !!! ][ 129 ][ 10 ][ --- ]]
]
[endsect]

[/ END of section, generated by performance measuring program ]
[endsect]

