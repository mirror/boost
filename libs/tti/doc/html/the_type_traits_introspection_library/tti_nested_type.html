<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Nested Types</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.0">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;The Type Traits Introspection Library 1.5">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;The Type Traits Introspection Library 1.5">
<link rel="prev" href="tti_detail.html" title="Macro Metafunctions">
<link rel="next" href="tti_usingMM.html" title="Using the Macro Metafunctions">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="tti_detail.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="tti_usingMM.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="the_type_traits_introspection_library.tti_nested_type"></a><a class="link" href="tti_nested_type.html" title="Nested Types">Nested
    Types</a>
</h2></div></div></div>
<div class="toc"><dl><dt><span class="section"><a href="tti_nested_type.html#the_type_traits_introspection_library.tti_nested_type.tti_func_sig">Nested
      Types and Function Signatures</a></span></dt></dl></div>
<a name="the_type_traits_introspection_library.tti_nested_type.the_problem"></a><h4>
<a name="the_type_traits_introspection_library.tti_nested_type.h0"></a>
      <a class="link" href="tti_nested_type.html#the_type_traits_introspection_library.tti_nested_type.the_problem">The
      problem</a>
    </h4>
<p>
      The goal of the TTI library is never to produce a compiler error by just using
      the functionality in the library, whether it is invoking its function-like
      macros or instantiating the macro metafunctions created by them, and whether
      the inner element exists or not. In this sense The TTI library macros for introspecting
      an enclosing type for an inner element work well. But there is one exception
      to this general case. That exception is the crux of the discussion regarding
      nested types which follows.
    </p>
<p>
      The metafunctions generated by the TTI macros all work with types, whether
      in specifying an enclosing type or in specifying the type of some inner element,
      which may also involve types in the signature of that element, such as a parameter
      or return type of a function. The C++ notation for a nested type, given an
      enclosing type 'T' and an inner type 'InnerType', is 'T::InnerType'. If either
      the enclosing type 'T' does not exist, or the inner type 'InnerType' does not
      exist within 'T', the expression 'T::InnerType' will give a compiler error
      if we attempt to use it in our template instantiation of one of TTI's macro
      metafunctions.
    </p>
<p>
      We want to be able to introspect for the existence of inner elements to an
      enclosing type without producing compiler errors. Of course if we absolutely
      know what types we have and that a nested type exists, and these declarations
      are within our scope, we can always use an expression like T::InnerType without
      error. But this is often not the case when doing template programming since
      the type being passed to us at compile-time in a class or function template
      is chosen at instantiation time and is created by the user of a template.
    </p>
<p>
      One solution to this is afforded by the library itself. Given an enclosing
      type 'T' which we know must exist, either because it is a top-level type we
      know about or it is passed to us in some template as a 'class T' or 'typename
      T', and given an inner type named 'InnerType' whose existence we would like
      ascertain, we can use a <code class="computeroutput"><span class="identifier">BOOST_TTI_HAS_TYPE</span><span class="special">(</span><span class="identifier">InnerType</span><span class="special">)</span></code> macro and it's related <code class="computeroutput"><span class="identifier">has_type_InnerType</span></code>
      metafunction to determine if the nested type 'InnerType' exists. This solution
      is perfectly valid and, with Boost MPL's selection metafunctions, we can do
      compile-time selection to generate the correct template code.
    </p>
<p>
      However this does not ordinarily scale that well syntactically if we need to
      drill down further from a top-level enclosing type to a deeply nested type,
      or even to look for some deeply nested type's inner elements. We are going
      to be generating a great deal of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">if_</span></code> and/or <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">eval_if</span></code> type selection statements to get
      to some final condition where we know we can generate the compile-time code
      which we want.
    </p>
<a name="the_type_traits_introspection_library.tti_nested_type.one_solution"></a><h4>
<a name="the_type_traits_introspection_library.tti_nested_type.h1"></a>
      <a class="link" href="tti_nested_type.html#the_type_traits_introspection_library.tti_nested_type.one_solution">One
      solution</a>
    </h4>
<p>
      The TTI library offers a solution in the form of a construct which works with
      a nested type without producing a compiler error if the nested type does not
      exist, but still is able to do the introspecting for inner elements that our
      TTI macro metafunctions do.
    </p>
<p>
      This is a metafunction created by the macro <code class="computeroutput"><a class="link" href="../BOOST_TTI_MEMBER_TYPE.html" title="Macro BOOST_TTI_MEMBER_TYPE">BOOST_TTI_MEMBER_TYPE</a></code>.
      Its general explanation is given as:
    </p>
<div class="table">
<a name="the_type_traits_introspection_library.tti_nested_type.tbmacronested"></a><p class="title"><b>Table&#160;1.2.&#160;TTI Nested Type Macro Metafunction</b></p>
<div class="table-contents"><table class="table" summary="TTI Nested Type Macro Metafunction">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Inner Element
              </p>
            </th>
<th>
              <p>
                Macro
              </p>
            </th>
<th>
              <p>
                Template
              </p>
            </th>
<th>
              <p>
                Specific Header File
              </p>
            </th>
</tr></thead>
<tbody><tr>
<td>
              <p>
                Type
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../BOOST_TTI_MEMBER_TYPE.html" title="Macro BOOST_TTI_MEMBER_TYPE">BOOST_TTI_MEMBER_TYPE</a></code>(name)
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">member_type_</span><span class="char">'name'</span></code>
              </p>
              <p>
                class T = enclosing type
              </p>
              <p>
                returns = the type of 'name' if it exists, else an unspecified type,
                as the typedef 'type'.
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../header/boost/tti/member_type_hpp.html" title="Header &lt;boost/tti/member_type.hpp&gt;">member_type.hpp</a></code>
              </p>
            </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break"><p>
      Instead of telling us whether an inner type of a particular name exists, as
      the metafunction generated by BOOST_TTI_HAS_TYPE does, the BOOST_TTI_MEMBER_TYPE
      macro generates a metafunction which, passed an enclosing type as its single
      template parameter, returns a typedef 'type' which is that inner type if it
      exists, else it is an unspecified marker 'type' if it does not. In this way
      we have created a metafunction, very similar in functionality to boost::mpl::identity,
      but which still returns some unspecified marker 'type' if our nested type is
      invalid.
    </p>
<p>
      We can use the functionality of <code class="computeroutput"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span></code>
      to construct nested types for our other macro metafunctions, without having
      to use the T::InnerType syntax and produce a compiler error if no such type
      actually exists within our scope. We can even do this in deeply nested contexts
      by stringing together, so to speak, a series of these macro metafunction results.
    </p>
<p>
      As an example, given a type T, let us create a metafunction where there is
      a nested type FindType whose enclosing type is eventually T, as represented
      by the following structure:
    </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">T</span>
  <span class="special">{</span>
  <span class="keyword">struct</span> <span class="identifier">AType</span>
    <span class="special">{</span>
    <span class="keyword">struct</span> <span class="identifier">BType</span>
      <span class="special">{</span>
      <span class="keyword">struct</span> <span class="identifier">CType</span>
        <span class="special">{</span>
        <span class="keyword">struct</span> <span class="identifier">FindType</span>
          <span class="special">{</span>
          <span class="special">};</span>
        <span class="special">}</span>
      <span class="special">};</span>
    <span class="special">};</span>
  <span class="special">};</span>
</pre>
<p>
      In our TTI code we first create a series of member type macros for each of
      our nested types:
    </p>
<pre class="programlisting"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">FindType</span><span class="special">)</span>
<span class="identifier">BOOST_TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">AType</span><span class="special">)</span>
<span class="identifier">BOOST_TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">BType</span><span class="special">)</span>
<span class="identifier">BOOST_TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">CType</span><span class="special">)</span>
</pre>
<p>
      Next we can create a typedef to reflect a nested type called FindType which
      has the relationship as specified above by instantiating our macro metafunctions.
    </p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="keyword">typename</span>
<span class="identifier">member_type_FindType</span>
  <span class="special">&lt;</span>
  <span class="keyword">typename</span> <span class="identifier">member_type_CType</span>
    <span class="special">&lt;</span>
    <span class="keyword">typename</span> <span class="identifier">member_type_BType</span>
      <span class="special">&lt;</span>
      <span class="keyword">typename</span> <span class="identifier">member_type_AType</span>
        <span class="special">&lt;</span>
        <span class="identifier">T</span>
        <span class="special">&gt;::</span><span class="identifier">type</span>
      <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="special">&gt;::</span><span class="identifier">type</span>
  <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">MyFindType</span><span class="special">;</span>
</pre>
<p>
      We can use the above typedef to pass the type as FindType to one of our macro
      metafunctions. FindType may not actually exist but we will not generate a compiler
      error when we use it, but will only generate, if it does not exist, a failure
      by having our meteafunction return a false value at compile-time.
    </p>
<p>
      As one example, let's ask whether FindType has a static member data called
      MyData of type 'int'. We add:
    </p>
<pre class="programlisting"><span class="identifier">BOOST_TTI_HAS_STATIC_MEMBER_DATA</span><span class="special">(</span><span class="identifier">MyData</span><span class="special">)</span>
</pre>
<p>
      Next we create our metafunction:
    </p>
<pre class="programlisting"><span class="identifier">has_static_member_data_MyData</span>
  <span class="special">&lt;</span>
  <span class="identifier">MyFindType</span><span class="special">,</span>
  <span class="keyword">int</span>
  <span class="special">&gt;</span>
</pre>
<p>
      and use this in our metaprogramming code. Our metafunction now tells us whether
      the nested type FindType has a static member data called MyData of type 'int',
      even if FindType does not actually exist as we have specified it as a type.
      If we had tried to do this using normal C++ nested type notation our metafunction
      code above would be:
    </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">has_static_member_data_MyData</span>
  <span class="special">&lt;</span>
  <span class="keyword">typename</span> <span class="identifier">T</span><span class="special">::</span><span class="identifier">AType</span><span class="special">::</span><span class="identifier">BType</span><span class="special">::</span><span class="identifier">CType</span><span class="special">::</span><span class="identifier">FindType</span><span class="special">,</span>
  <span class="keyword">int</span>
  <span class="special">&gt;</span>
</pre>
<p>
      But this fails with a compiler error if there is no such nested type, and that
      is exactly what we do not want in our compile-time metaprogramming code.
    </p>
<p>
      in the above metafunction we are asking whether or not FindType has a static
      member data element called 'MyData', and the result will be 'false' if either
      FindType does not exist or if it does exist but does not have a static member
      data of type 'int' called 'MyData'. In neither situation will we produce a
      compiler error.
    </p>
<p>
      Somewhere else we may also be interested in ascertaining whether the deeply
      nested type 'FindType' actually exists. Our metafunction, using BOOST_TTI_MEMBER_TYPE
      and repeating our macros from above, would be:
    </p>
<pre class="programlisting"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">FindType</span><span class="special">)</span>
<span class="identifier">BOOST_TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">AType</span><span class="special">)</span>
<span class="identifier">BOOST_TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">BType</span><span class="special">)</span>
<span class="identifier">BOOST_TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">CType</span><span class="special">)</span>

<span class="identifier">BOOST_TTI_HAS_TYPE</span><span class="special">(</span><span class="identifier">FindType</span><span class="special">)</span>

<span class="identifier">has_type_FindType</span>
  <span class="special">&lt;</span>
  <span class="keyword">typename</span>
  <span class="identifier">member_type_CType</span>
    <span class="special">&lt;</span>
    <span class="keyword">typename</span>
    <span class="identifier">member_type_BType</span>
      <span class="special">&lt;</span>
      <span class="keyword">typename</span>
      <span class="identifier">member_type_AType</span>
        <span class="special">&lt;</span>
        <span class="identifier">T</span>
        <span class="special">&gt;::</span><span class="identifier">type</span>
      <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="special">&gt;::</span><span class="identifier">type</span>
  <span class="special">&gt;</span>
</pre>
<p>
      But this duplicates much of our code when we generated the 'MyFindType' typedef,
      so it would be much better if we could simply pass our 'MyFindType' type to
      some other metafunction which would tell us directly if 'MyFindType' actually
      exists. And so we can ! The TTI library has a named metafunction called 'boost::tti::valid_member_type'
      which takes a type and determines if it 'actually exists', returning the compile-time
      boolean constant called 'value' of 'true' if it does or 'false' if it does
      not. The meaning of 'actually exists', as far as 'boost::tti::valid_member_type'
      is concerned, is that the type does not equal the unspecified type which BOOST_TTI_MEMBER_TYPE
      returns when its nested type does not exist, and therefore 'boost::tti::valid_member_type'
      is meant to be used with the return 'type' of BOOST_TTI_MEMBER_TYPE, which
      is what 'MyFindType' represents.
    </p>
<p>
      The general explanation of 'boost::tti::valid_member_type' is given as:
    </p>
<div class="table">
<a name="the_type_traits_introspection_library.tti_nested_type.existtbmacronested"></a><p class="title"><b>Table&#160;1.3.&#160;TTI Nested Type Macro Metafunction Existence</b></p>
<div class="table-contents"><table class="table" summary="TTI Nested Type Macro Metafunction Existence">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Inner Element
              </p>
            </th>
<th>
              <p>
                Macro
              </p>
            </th>
<th>
              <p>
                Template
              </p>
            </th>
<th>
              <p>
                Specific Header File
              </p>
            </th>
</tr></thead>
<tbody><tr>
<td>
              <p>
                Type
              </p>
            </td>
<td>
              <p>
                None
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/tti/valid_member_type.html" title="Struct template valid_member_type">boost::tti::valid_member_type</a></code>
              </p>
              <p>
                class T = a type
              </p>
              <p>
                returns = true if the type exists, false if it does not. 'Existence'
                is determined by whether the type does not equal the unspecified
                type of BOOST_TTI_MEMBER_TYPE when the type does not exist.
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../header/boost/tti/member_type_hpp.html" title="Header &lt;boost/tti/member_type.hpp&gt;">member_type.hpp</a></code>
              </p>
            </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break"><p>
      Using this functionality with our 'MyFindType' type above we could create the
      nullary metafunction:
    </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">valid_member_type</span>
  <span class="special">&lt;</span>
  <span class="identifier">MyFindType</span>
  <span class="special">&gt;</span>
</pre>
<p>
      directly instead of replicating the same functionality with our 'boost::tti::has_type_FindType'
      metafunction.
    </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="the_type_traits_introspection_library.tti_nested_type.tti_func_sig"></a><a class="link" href="tti_nested_type.html#the_type_traits_introspection_library.tti_nested_type.tti_func_sig" title="Nested Types and Function Signatures">Nested
      Types and Function Signatures</a>
</h3></div></div></div>
<p>
        The strength of <code class="computeroutput"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span></code>
        to represent a type which may or may not exist, and which then can be subsequently
        used in other macro metafunctions whenever a type is needed as a template
        parameter, without producing a compiler error, should not be underestimated.
        It is one of the reasons why we have two different versions of metafunctions
        for introspecting a member function or static member function of a type.
      </p>
<p>
        In the more general case, when using <code class="computeroutput"><span class="identifier">BOOST_TTI_HAS_MEMBER_FUNCTION_WITH_SIG</span></code>
        and <code class="computeroutput"><span class="identifier">BOOST_TTI_HAS_STATIC_MEMBER_FUNCTION_WITH_SIG</span></code>,
        the signature for the member function and the static member function is a
        composite type. This makes for a syntactical notation which is natural to
        specify, but because of that composite type notation we can not use the nested
        type functionality in <code class="computeroutput"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span></code>
        very easily.
      </p>
<p>
        But in the more specific case, when we use <code class="computeroutput"><span class="identifier">BOOST_TTI_HAS_MEMBER_FUNCTION</span></code>
        and <code class="computeroutput"><span class="identifier">BOOST_TTI_HAS_STATIC_MEMBER_FUNCTION</span></code>,
        the composite types in our signatures are broken down into their individual
        types so that using <code class="computeroutput"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span></code>,
        if necessary, for any one of the individual types is easy and natural.
      </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2010, 2011 Tropic Software East Inc</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="tti_detail.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="tti_usingMM.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
