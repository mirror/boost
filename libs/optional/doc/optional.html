<!DOCTYPE HTML PUBLIC "-//SoftQuad Software//DTD HoTMetaL PRO 5.0::19981217::extensions to HTML 4.0//EN" "hmpro5.dtd">

<HTML>

<HEAD>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<LINK REL="stylesheet" TYPE="text/css" HREF="../../../boost.css">
<TITLE>Header </TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080">
<H2><IMG SRC="../../../boost.png" WIDTH="276" HEIGHT="86">Header &lt;<A
HREF="../../../boost/optional/optional.hpp">boost/optional/optional.hpp</A>&gt; </H2>

<H2>Contents</H2>
<DL CLASS="page-index">
  <DT><A HREF="#mot">Motivation</A></DT>
  <DT><A HREF="#dev">Development</A></DT>
  <DT><A HREF="#synopsis">Synopsis</A></DT>
  <DT><A HREF="#semantics">Semantics</A></DT>
  <DT><A HREF="#examples">Examples</A></DT>
  <DT><A HREF="#ref">Optional references</A></DT>
  <DT><A HREF="#refassign">Rebinding semantics for assignment of optional references</A></DT>
  <DT><A HREF="#none">none_t and none</A></DT>
  <DT><A HREF="#inplace">In-Place Factories</A></DT>
  <DT><A HREF="#bool">A note about optional&lt;bool&gt;</A></DT>
  <DT><A HREF="#exsafety">Exception Safety Guarantees</A></DT>
  <DT><A HREF="#requirements">Type requirements</A></DT>
  <DT><A HREF="#impl">Implementation Notes</A></DT>
  <DT><A HREF="#porta">Dependencies and Portability</A></DT>
  <DT><A HREF="#credits">Acknowledgment</A></DT>
</DL>

<HR>

<H2><A NAME="mot"></A>Motivation</H2>

<P>Consider these functions which should return a value but which might not have
  a value to return:</P>
<pre>(A) double sqrt(double n );
(B) char get_async_input();
(C) point polygon::get_any_point_effectively_inside();</pre>
<P>There are different approaches to the issue of not having a value to return.</P>
<P>A typical approach is to consider the existence of a valid return value as
  a postcondition, so that if the function cannot compute the value to return,
  it has either undefined behavior (and can use assert in a debug build)
  or uses a runtime check and throws an exception if the postcondition is violated.
  This is a reasonable choice for example, for function (A), because the
  lack of a proper return value is directly related to an invalid parameter (out
  of domain argument), so it is appropriate to require the callee to supply only
  parameters in a valid domain for execution to continue normally.</P>
<P>However, function (B), because of its asynchronous nature, does not fail just
  because it can't find a value to return; so it is incorrect to consider
  such a situation an error and assert or throw an exception. This function must
  return, and somehow, must tell the callee that it is not returning a meaningful
  value.</P>
<P>A similar situation occurs with function (C): it is conceptually an error to
  ask a <i>null-area</i> polygon to return a point inside itself, but in many
  applications, it is just impractical for performance reasons to treat this as
  an error (because detecting that the polygon has no area might be too expensive
  to be required to be tested previously), and either an arbitrary point (typically
  at infinity) is returned, or some efficient way to tell the callee that there
  is no such point is used.</P>
<P>There are various mechanisms to let functions communicate that the returned
  value is not valid. One such mechanism, which is quite common since it has zero
  or negligible overhead, is to use a special value which is reserved to communicate
  this. Classical examples of such special values are EOF, string::npos, points
  at infinity, etc...</P>
<P>When those values exist, i.e. the return type can hold all meaningful values
  <i>plus</i> the <i>signal</i> value, this mechanism is quite appropriate and
  well known. Unfortunately, there are cases when such values do not exist. In
  these cases, the usual alternative is either to use a wider type, such as 'int'
  in place of 'char'; or a compound type, such as std::pair&lt;point,bool&gt;.
</P>
<P>Returning a std::pair&lt;T,bool&gt;, thus attaching a boolean flag to the result
  which indicates if the result is meaningful, has the advantage that can be turned
  into a consistent idiom since the first element of the pair can be whatever
  the function would conceptually return. For example, the last two functions
  could have the following interface:</P>
<pre>std::pair&lt;char,bool&gt; get_async_input();
std::pair&lt;point,bool&gt; polygon::get_any_point_effectively_inside();</pre>
<p>These functions use a consistent interface for dealing with possibly inexistent
  results:</p>
<pre>std::pair&lt;point,bool&gt; p = poly.get_any_point_effectively_inside();
if ( p.second )
  flood_fill(p.first);
</pre>

<P>However, not only is this quite a burden syntactically, it is also error
  prone since the user can easily use the function result (first element of the
  pair) without ever checking if it has a valid value.</P>
<P>Clearly, we need a better idiom.</P>

<H2><A NAME="dev"></A>Development</H2>

<h3><u>The models:</u></h3>
<P>In C++, we can <i>declare</i> an object (a variable) of type T, and we can give this variable
  an <i>initial value</i> (through an <i>initializer</i>. (c.f. 8.5)).<br>
  When a declaration includes a non-empty initializer (an initial value is given), it is said that
  the object has been <i><b>initialized</b></i>.<br>
  If the declaration uses an empty initializer (no initial value is given),
  and neither default nor value initialization applies, it is said that the object is
  <i><b>uninitialized</b></i>. Its actual value exist but has an
  <i>indeterminate initial value</i> (c.f. 8.5.9).<br>
  <code>optional&lt;T&gt;</code> intends to formalize the notion of initialization 
(or lack of it)
  allowing a program to test whether an object has been initialized and stating that access to
  the value of an uninitialized object is undefined behavior. That is,
  when a variable is declared as optional&lt;T&gt; and no initial value is given,
  the variable is <i>formally</i> uninitialized. A formally uninitialized optional object has conceptually
  no value at all and this situation can be tested at runtime. It is formally <i>
undefined behavior</i>
  to try to access the value of an uninitialized optional. An uninitialized optional can be <i>assigned</i> a      value, in which case its initialization state changes to initialized. Furthermore, given the formal
  treatment of initialization states in optional objects, it is even possible to reset an optional to <i>uninitialized</i>.</P>
<P>In C++ there is no formal notion of uninitialized objects, which
  means that objects always have an initial value even if indeterminate.<br>
  As discussed on the previous section, this has a drawback because you need additional
  information to tell if an object has been effectively initialized.<br>
  One of the typical ways in which this has been historically
  dealt with is via a special value: EOF,npos,-1, etc... This is equivalent to adding
  the special value to the set of possible values of a given type. This super set of
  T plus some <i>nil_t</i>&mdash;were nil_t is some stateless POD-can be modeled in modern
  languages as a <b>discriminated union</b> of <code>T</code> and <code>nil_t</code>.
  Discriminated unions are often called <i>variants</i>. A variant has a <i>current type</i>,
  which in our case is either <code>T</code> or <code>nil_t</code>.<br>
  Using the <a href="../../../doc/html/variant.html">Boost.Variant</a> library, this model can be implemented
  in terms of <code>boost::variant&lt;T,nil_t&gt;</code>.<br>
  There is precedent for a discriminated union as a model for an optional value: the
  <a href="http://www.haskell.org/"><u>Haskell</u></a> <b>Maybe</b> built-in type constructor. 
Thus, a discriminated union <code>T+nil_t</code> serves as a conceptual foundation.</p>
<p>A <code>variant&lt;T,nil_t&gt;</code> follows naturally from the traditional idiom of extending
the range of possible values adding an additional sentinel value with the special meaning of <i>Nothing. </i>
However, this additional <i>Nothing</i> value is largely irrelevant for our purpose
 since our goal is to formalize the notion of uninitialized objects and, while a special extended value <i>can</i> be used to convey that meaning, it is not strictly 
necessary in order to do so.</p>
<p>The observation made in the last paragraph about the irrelevant nature of the additional <code>nil_t</code> with respect to
<u>purpose</u> of optional&lt;T&gt; suggests
an alternative model: a <i>container</i> that either has a value of T or nothing.
</p>
<p>As of this writing I don't know of any precedent for a variable-size fixed-capacity (of 1)
stack-based container model for optional values, yet I believe this is the consequence of
the lack of practical implementations of such a container rather than an inherent shortcoming
of the container model.</p>
<p>In any event, both the discriminated-union or the single-element container models serve as a conceptual
ground for a class representing optional&mdash;i.e. possibly uninitialized&mdash;objects.<br>
For instance, these models show the <i>exact</i> semantics required for a wrapper of optional values:</p>
<p>Discriminated-union:</p>
<blockquote>
<li><b>deep-copy</b> semantics:  copies of the variant implies copies of the value.</li>
<li><b>deep-relational</b> semantics: comparisons between variants matches both current types and values</li>
<li>If the variant's current type is T, it is modeling an <i>initialized</i> optional.</li>
<li>If the variant's current type is not T, it is modeling an <i>uninitialized</i> optional.</li>
<li>Testing if the variant's current type is T models testing if the optional is initialized</li>
<li>Trying to extract a T from a variant when its current type is not T, models the undefined 
behavior
of trying to access the value of an uninitialized optional</li>
</blockquote>
<p>Single-element container:</p>
<blockquote>
<li><b>deep-copy</b> semantics:  copies of the container implies copies of the value.</li>
<li><b>deep-relational</b> semantics: comparisons between containers compare container size and if match, contained value</li>
<li>If the container is not empty (contains an object of type T), it is modeling an <i>initialized</i> optional.</li>
<li>If the container is empty, it is modeling an <i>uninitialized</i> optional.</li>
<li>Testing if the container is empty models testing if the optional is initialized</li>
<li>Trying to extract a T from an empty container models the undefined behavior
of trying to access the value of an uninitialized optional</li>
</blockquote>

<h3><u>The semantics:</u></h3>
<p>Objects of type <code>optional&lt;T&gt;</code> are intended to be used in places where objects of type T would
but which might be uninitialized. Hence, <code>optional&lt;T&gt;</code>'s purpose is to formalize the
additional possibly uninitialized state.<br>
From the perspective of this role, <code>optional&lt;T&gt;</code> can have the same operational semantics of T
plus the additional semantics corresponding to this special state.<br>
As such, <code>optional&lt;T&gt;</code> could be thought of as a <i>supertype</i> of T. Of course,
we can't do that in C++, so we need to compose the desired semantics using a different mechanism.<br>
Doing it the other way around, that is, making <code>optional&lt;T&gt;</code> a <i>subtype</i> of T is not only
conceptually wrong but also impractical: it is not allowed to derive from a non-class type, such as a 
built-in type.</p>

<p>We can draw from the purpose of optional&lt;T&gt; the required basic semantics:</p>

<blockquote>
<p><b>Default Construction:</b> To introduce a formally uninitialized wrapped
object.</p>

<p><b>Direct Value Construction via copy:</b> To introduce a formally
initialized wrapped object whose value is obtained as a copy of some object.</p>

<p><b>Deep Copy Construction:</b> To obtain a new yet equivalent wrapped
object.</p>

<p><b>Direct Value Assignment (upon initialized):</b> To assign a value to the wrapped object.</p>

<p><b>Direct Value Assignment (upon uninitialized):</b> To initialize the wrapped object
with a value obtained
as a copy of some object.</p>

<p><b>Assignment (upon initialized):</b> To assign to the wrapped object the value 
of another wrapped object.</p>

<p><b>Assignment (upon uninitialized):</b> To initialize the wrapped object
with value of another wrapped object.</p>

<p><b>Deep Relational Operations (when supported by the type T):</b> To compare
wrapped object values taking into account the presence of uninitialized
states.</p>

<p><b>Value access:</b> To unwrap the wrapped object.</p>

<p><b>Initialization state query:</b> To determine if the object is formally
initialized or not.</p>

<p><b>Swap:</b> To exchange wrapped objects. (with whatever exception safety
guarantees are provided by T's swap).</p>

<p><b>De-initialization:</b> To release the wrapped object (if any) and leave
the wrapper in the uninitialized state.</p>

</blockquote>

<p>Additional operations are useful, such as converting constructors and
converting assignments, in-place construction and assignment, and safe value
access via a pointer to the wrapped object or null.</p>
<h3><u>The Interface:</u></h3>
<p>Since the purpose of optional is to allow us to use objects with a formal
uninitialized additional state, the interface could try to follow the interface
of the underlying T type as much as possible. In order to choose the proper
degree of adoption of the native T interface, the following must be noted: <br>
Even if all the operations supported by an instance of type T are defined for
the entire range of values for such a type, an optional&lt;T&gt; extends such a set of
values with a new value for which most (otherwise valid) operations are not
defined in terms of T.<br>
Furthermore, since optional&lt;T&gt; itself is merely a T wrapper (modeling a T
supertype), any attempt to define such operations upon uninitialized optionals
will be totally artificial w.r.t. T.<br>
This library chooses an interface which follows from T's interface only for
those operations which are well defined (w.r.t the type T) even if any of the
operands are uninitialized. These operations include: construction,
copy-construction, assignment, swap and relational operations.<br>
For the value access operations, which are undefined (w.r.t the type T) when the
operand is uninitialized, a different interface is chosen (which will be
explained next).<br>
Also, the presence of the possibly uninitialized state requires additional
operations not provided by T itself which are supported by a special interface.</p>
<h3>Lexically-hinted Value Access in the presence of possibly untitialized
optional objects: The operators * and -&gt;</h3>
<p>A relevant feature of a pointer is that it can have a <b>null
  pointer value</b>. This is a <i>special</i> value which is used to indicate that the
  pointer is not referring to any object at all. In other words, null pointer
  values convey the notion of inexistent objects.</P>
<P>This meaning of the null pointer value allowed pointers to became a <i>de facto</i> standard
  for handling optional objects because all you have to do to refer to a value which you
  don't really have is to use a null pointer value of the appropriate type.
  Pointers have been used for decades&mdash;from the days of C APIs to modern C++ libraries&mdash;to
  <i>refer</i> to optional (that is, possibly inexistent) objects; particularly
  as optional arguments to a function, but also quite often as optional data members.</P>
<P>The possible presence of a null pointer value makes the operations that access the
  pointee's value possibly undefined, therefore, expressions which use dereference
  and access operators, such as: <code>( *p = 2 )</code> and <code>( p-&gt;foo())</code>,
  implicitly convey the notion of optionality, and this information is tied to
  the <i>syntax</i> of the expressions. That is, the presence of operators * and -&gt; tell by
  themselves&mdash;without any additional context&mdash;that the expression will be undefined unless
  the implied pointee actually exist.</P>
<P>Such a <i>de facto</i> idiom for referring to optional objects can be formalized in the form of a
concept: the <a href="../../utility/OptionalPointee.html">OptionalPointee</a> concept.<br>
This concept captures the syntactic usage of operators *, -> and conversion to bool to convey
the notion of optionality.</P>
<P>However, pointers are good to <u>refer</u> to optional objects, but not particularly good
to handle the optional objects in all other respects, such as initializing or moving/copying
them. The problem resides in the shallow-copy of pointer semantics: if you need to
  effectively move or copy the object, pointers alone are not enough. The problem
  is that copies of pointers do not imply copies of pointees. For example, as
  was discussed in the motivation, pointers alone cannot be used to return optional
  objects from a function because the object must move outside from the function and
  into the caller's context.<br>
  A solution to the shallow-copy problem that is often used is to resort to dynamic
  allocation and use a smart pointer to automatically handle the details of this.
  For example, if a function is to optionally return an object X, it can use shared_ptr&lt;X&gt;
  as the return value. However, this requires dynamic allocation of X. If X is
  a built-in or small POD, this technique is very poor in terms of required resources.
  Optional objects are essentially values so it is very convenient to be able to use automatic
  storage and deep-copy semantics to manipulate optional values just as we do with ordinary
  values. Pointers do not have this semantics, so are inappropriate for the initialization and
  transport of optional values, yet are quite convenient for handling the access to the
  possible undefined value because of the idiomatic aid present in the OptionalPointee
  concept incarnated by pointers.
</p>
<h4>Optional&lt;T&gt; as a model of OptionalPointee</h4>
<P>For value access operations optional&lt;&gt; uses operators * and -&gt; to lexically
warn about the possibly uninitialized state appealing to the familiar pointer
semantics w.r.t. to null pointers.<br>
<u><b>However, it is particularly important to note that optional<> objects are not pointers. optional&lt;&gt;
is not, and does not model, a pointer</b></u><b>.</b>
<P>For instance, optional&lt;&gt; does not have shallow-copy so does not alias: two different optionals
  never refer to the <i>same</i> value unless T itself is a reference (but may have <i>equivalent</i> values).<br>
  The difference between an optional&lt;T&gt; and a pointer must be kept in mind, particularly
  because the semantics of relational operators are different: since optional&lt;T&gt;
  is a value-wrapper, relational operators are deep: they compare optional values;
  but relational operators for pointers are shallow:  they do not compare pointee values.<br>
  As a result, you might be able to replace optional&lt;T&gt; by T* on some situations but
  not always. Specifically, on generic code written for both, you cannot use relational
  operators directly, and must use the template functions
  <a href="../../utility/OptionalPointee.html#equal">equal_pointees()</a> and
  <a href="../../utility/OptionalPointee.html#less">less_pointees()</a> instead.
<HR>

<H2><A NAME="synopsis">Synopsis</A></H2>

<PRE>namespace boost {

template&lt;class T>
class optional
{
  public :

    <i><u>(If T is of reference type, the parameters and results by reference are by value)</u></i>

    optional () ;

    optional ( none_t ) ;

    optional ( T const&amp; v ) ;

    optional ( bool condition, T const&amp; v ) ;  <u><i>[new in 1.34]</u></i>
    
    optional ( optional const&amp; rhs ) ;

    template&lt;class U&gt; explicit optional ( optional&lt;U&gt; const&amp; rhs ) ;

    template&lt;class InPlaceFactory&gt; explicit optional ( InPlaceFactory const&amp; f ) ;

    template&lt;class TypedInPlaceFactory&gt; explicit optional ( TypedInPlaceFactory const&amp; f ) ;

    optional&amp; operator = ( none_t ) ;

    optional&amp; operator = ( T const&amp; v ) ;

    optional&amp; operator = ( optional const&amp; rhs ) ;

    template&lt;class U&gt; optional&amp; operator = ( optional&lt;U&gt; const&amp rhs ) ;

    template&lt;class InPlaceFactory&gt; optional&amp; operator = ( InPlaceFactory const&amp f ) ;

    template&lt;class TypedInPlaceFactory&gt; optional&amp; operator = ( TypedInPlaceFactory const&amp f ) ;

    T const& get() const ;
    T&       get() ;

    T const&amp; get_value_or( T const&amp; default ) const ;  <u><i>[new in 1.34]</u></i>
    
    T const* operator -&gt;() const ;
    T*       operator -&gt;() ;

    T const&amp; operator *() const ;
    T&amp;       operator *() ;

    T const* get_ptr() const ;
    T*       get_ptr() ;

    operator <i>unspecified-bool-type</i>() const ;

    bool operator!() const ;

    <i><u>deprecated methods</u></i>

    void reset() ; (deprecated)
    void reset ( T const&amp; ) ; (deprecated)
    bool is_initialized() const ; (deprecated)

} ;

template&lt;class T&gt; inline bool operator == ( optional&lt;T&gt; const& x, optional&lt;T&gt; const& y ) ;

template&lt;class T&gt; inline bool operator != ( optional&lt;T&gt; const& x, optional&lt;T&gt; const& y ) ;

template&lt;class T&gt; inline bool operator <  ( optional&lt;T&gt; const& x, optional&lt;T&gt; const& y ) ;

template&lt;class T&gt; inline bool operator >  ( optional&lt;T&gt; const& x, optional&lt;T&gt; const& y ) ;

template&lt;class T&gt; inline bool operator <= ( optional&lt;T&gt; const& x, optional&lt;T&gt; const& y ) ;

template&lt;class T&gt; inline bool operator >= ( optional&lt;T&gt; const& x, optional&lt;T&gt; const& y ) ;

template&lt;class T&gt; inline bool operator == ( optional&lt;T&gt; const& x, T const& n ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator != ( optional&lt;T&gt; const& x, T const& n ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator <  ( optional&lt;T&gt; const& x, T const& n ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator >  ( optional&lt;T&gt; const& x, T const& n ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator <= ( optional&lt;T&gt; const& x, T const& n ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator >= ( optional&lt;T&gt; const& x, T const& n ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator == ( T const& n, optional&lt;T&gt; const& y ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator != ( T const& n, optional&lt;T&gt; const& y ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator <  ( T const& n, optional&lt;T&gt; const& y ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator >  ( T const& n, optional&lt;T&gt; const& y ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator <= ( T const& n, optional&lt;T&gt; const& y ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator >= ( T const& n, optional&lt;T&gt; const& y ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator == ( optional&lt;T&gt; const& x, none_t n ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator != ( optional&lt;T&gt; const& x, none_t n ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator <  ( optional&lt;T&gt; const& x, none_t n ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator >  ( optional&lt;T&gt; const& x, none_t n ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator <= ( optional&lt;T&gt; const& x, none_t n ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator >= ( optional&lt;T&gt; const& x, none_t n ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator == ( none_t n, optional&lt;T&gt; const& y ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator != ( none_t n, optional&lt;T&gt; const& y ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator <  ( none_t n, optional&lt;T&gt; const& y ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator >  ( none_t n, optional&lt;T&gt; const& y ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator <= ( none_t n, optional&lt;T&gt; const& y ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline bool operator >= ( none_t n, optional&lt;T&gt; const& y ) ; <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline optional&lt;T&gt; make_optional ( T const& v ) ;  <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline optional&lt;T&gt; make_optional ( bool condition, T const& v ) ;  <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline T const&amp; get_optional_value_or ( optional&lt;T&gt; const& opt, T const& default ) ;  <u><i>[new in 1.34]</u></i>

template&lt;class T&gt; inline T const& get ( optional&lt;T&gt; const& opt ) ;

template&lt;class T&gt; inline T& get ( optional&lt;T&gt; & opt ) ;

template&lt;class T&gt; inline T const* get ( optional&lt;T&gt; const* opt ) ;

template&lt;class T&gt; inline T* get ( optional&lt;T&gt;* opt ) ;

template&lt;class T&gt; inline T const* get_pointer ( optional&lt;T&gt; const& opt ) ;

template&lt;class T&gt; inline T* get_pointer ( optional&lt;T&gt; & opt ) ;

template&lt;class T&gt; inline void swap( optional&lt;T&gt;& x, optional&lt;T&gt;&amp; y ) ;

} // namespace boost
</PRE>

<HR>

<h2><A NAME="semantics">Detailed Semantics</a></h2>

<p><b><u>NOTES: </u></b></p>

<p><b>Because T might be of reference type, in the sequel, those entries whose
semantic depends on T being of reference type or not will be distinguished using
the following convention:<br>
If the entry reads: optional&lt;T (not a ref)&gt;, the description corresponds only to
the case where T is not of reference type.<br>
If the entry reads: optional&lt;T&amp;&gt;, the description corresponds only to the case
where T is of reference type. <br>
If the entry reads: optional&lt;T&gt;, the description is the same for both cases.</b></p>

<p><i>The following section contains various assert() which are used only to
show the postconditions as sample code. It is not implied that the type T must
support each particular expression but that if the expression is supported, the
implied condition holds.</i></p>

<hr>

<pre>optional&lt;T&gt;::optional();</pre>
<blockquote>
<p><b>Effect:</b> Default-Constructs an <b>optional</b>.</p>
<p><b>Postconditions:</b> <b>*this</b> is <u>uninitialized</u>.</p>
<p><b>Throws:</b> Nothing.</p>
<p><b>Notes:</b> T's default constructor <u><i>is not</i></u> called.</p>
<p><b>Example:</b></p>
  <blockquote>
    <pre>optional&lt;T&gt; def ;
assert ( !def ) ;</pre>
</blockquote>
</blockquote>

<HR>

<pre>optional&lt;T&gt;::optional( none_t );</pre>
<blockquote>
<p><b>Effect:</b> Constructs an <b>optional</b> uninitialized.</p>
<p><b>Postconditions:</b> <b>*this</b> is <u>uninitialized</u>.</p>
<p><b>Throws:</b> Nothing.</p>
<p><b>Notes:</b></p>
<blockquote>
<p>T's default constructor <u><i>is not</i></u> called.<br>
The
expression <code>boost::none</code> denotes an instance of <code>boost::none_t</code> that can be
used as the parameter.</p>
</blockquote>
<p><b>Example:</b></p>
  <blockquote>
<pre>
#include &lt;boost/none.hpp&gt;
optional&lt;int&gt; n(boost::none) ;
assert ( !n ) ;
</pre>
</blockquote>
</blockquote>

<HR>

<pre>optional&lt;T <i>(not a ref)</i>&gt;::optional( T const&amp; v )</pre>
<blockquote>
<p><b>Effect:</b> Directly-Constructs an <b>optional</b>.</p>
<p><b>Postconditions:</b> <b>*this</b> is <u>initialized</u> and its value is a <i>copy</i> of 'v'.</p>
<p><b>Throws:</b> Whatever T::T( T const&amp; ) throws.</p>
<p><b>Notes: </b> T::T( T const&amp; ) is called.</p>
<p><b>Exception Safety:</b> Exceptions can only be thrown during T::T( T const&amp; );
in that case, this constructor has no effect.
</p>
<p><b>Example:</b></p>
<blockquote>
<pre>
T v;
optional&lt;T&gt; opt(v);
assert ( *opt == v ) ;
</pre>
</blockquote>
</blockquote>

<HR>

<pre>optional&lt;T&amp;&gt;::optional( T&amp; ref )</pre>
<blockquote>
<p><b>Effect:</b> Directly-Constructs an <b>optional</b>.</p>
<p><b>Postconditions:</b> <b>*this</b> is <u>initialized</u> and its value is an
instance of an internal type wrapping the reference 'ref'.</p>
<p><b>Throws:</b> Nothing.</p>
<p><b>Example:</b></p>
<blockquote>
<pre>
T v;
T&amp; vref = v ;
optional&lt;T&amp;&gt; opt(vref);
assert ( *opt == v ) ;
++ v ; // mutate referee
assert (*opt == v); 
</pre>
</blockquote>
</blockquote>

<HR>

<pre>optional&lt;T <i>(not a ref)</i>&gt;::optional( bool condition, T const&amp; v ) ;
optional&lt;T&amp;&gt;           ::optional( bool condition, T&amp;       v ) ;
</pre>

<blockquote>
<p>If <i>condition</i> is <code>true</code>, same as:</p>
<pre>optional&lt;T <i>(not a ref)</i>&gt;::optional( T const&amp; v )
optional&lt;T&amp;&gt;           ::optional( T&amp;       v )
</pre>
<p>otherwise, same as:</p>
<pre>
optional&lt;T <i>(not a ref)</i>&gt;::optional()
optional&lt;T&amp;&gt;           ::optional()
</pre>
</blockquote>

<HR>

<pre>optional&lt;T <i>(not a ref)</i>&gt;::optional( optional const&amp; rhs );</pre>
<blockquote>
<p><b>Effect:</b> Copy-Constructs an <b>optional</b>.</p>
<p><b>Postconditions:</b> If <b>rhs</b> is initialized, <b>*this</b> is initialized
and its value is a <i>copy</i> of the value of <b>rhs</b>; else <b>*this</b>
is uninitialized.</p>
<p><b>Throws:</b> Whatever T::T( T const& ) throws.</p>
<p><b>Notes:</b> If <b>rhs</b> is initialized, T::T(T const&amp; ) is called.</p>
<p><b>Exception Safety:</b> Exceptions can only be thrown during T::T( T const& );
in that case, this constructor has no effect.
</p>
<p><b>Example:</b></p>
<blockquote>
<pre>
optional&lt;T&gt; uninit ;
assert (!uninit);

optional&lt;T&gt; uinit2 ( uninit ) ;
assert ( uninit2 == uninit );

optional&lt;T&gt; init( T(2) );
assert ( *init == T(2) ) ;

optional&lt;T&gt; init2 ( init ) ;
assert ( init2 == init ) ;
</pre>

</blockquote>
</blockquote>

<HR>

<pre>optional&lt;T&amp;&gt;::optional( optional const&amp; rhs );</pre>
<blockquote>
<p><b>Effect:</b> Copy-Constructs an <b>optional</b>.</p>
<p><b>Postconditions:</b> If <b>rhs</b> is initialized, <b>*this</b> is initialized
and its value is another reference to the same object referenced by <b>*rhs</b>; else <b>*this</b>
is uninitialized.</p>
<p><b>Throws:</b> Nothing.</p>
<p><b>Notes:</b> If <b>rhs</b> is initialized, both <b>*this</b> and <b>*rhs</b> will
reefer to the same object<b> </b>(they alias).</p>
<p><b>Example:</b></p>
<blockquote>
<pre>
optional&lt;T&amp;&gt; uninit ;
assert (!uninit);

optional&lt;T&amp;&gt; uinit2 ( uninit ) ;
assert ( uninit2 == uninit );

T v = 2 ; T&amp; ref = v ;
optional&lt;T&gt; init(ref);
assert ( *init == v ) ;

optional&lt;T&gt; init2 ( init ) ;
assert ( *init2 == v ) ;

v = 3 ;

assert ( *init  == 3 ) ;
assert ( *init2 == 3 ) ;


</pre>

</blockquote>
</blockquote>

<HR>

<pre>template&lt;U&gt; explicit optional&lt;T <i>(not a ref)</i>&gt;::optional( optional&lt;U&gt; const&amp; rhs );</pre>
<blockquote>
<p><b>Effect:</b> Copy-Constructs an <b>optional</b>.</p>
<p><b>Postconditions:</b> If <b>rhs</b> is initialized, <b>*this</b> is initialized
    and its value is a <i>copy</i> of the value of <b>rhs</b> <i>converted</i>
    to type T; else <b>*this</b> is uninitialized.
</p>
<p><b>Throws:</b> Whatever T::T( U const& ) throws.</p>
<p><b>Notes:</b> T::T( U const& ) is called if <b>rhs</b> is initialized, which requires
a valid conversion from U to T.
</p>
<p><b>Exception Safety:</b> Exceptions can only be thrown during T::T( U const& );
in that case, this constructor has no effect.
</p>
<p><b>Example:</b></p>
<blockquote>

<pre>
optional&lt;double&gt; x(123.4);
assert ( *x == 123.4 ) ;

optional&lt;int&gt; y(x) ;
assert( *y == 123 ) ;
</pre>
</blockquote>
</blockquote>

<HR>

<pre>template&lt;<i>InPlaceFactory</i>&gt; explicit optional&lt;T <i>(not a ref)</i>&gt;::optional( <i>InPlaceFactory</i> const&amp; f );</pre>

<pre>template&lt;<i>TypedInPlaceFactory</i>&gt; explicit optional&lt;T <i>(not a ref)</i>&gt;::optional( <i>TypedInPlaceFactory</i> const&amp; f );</pre>
<blockquote>
<p><b>Effect:</b> Constructs an <b>optional</b> with a value of T obtained from
the factory.</p>
<p><b>Postconditions:</b>&nbsp; <b>*this</b> is <u>initialized</u> and its value is
<i>directly given</i> from the factory 'f' (i.e., the value<u> is not copied</u>).</p>
<p><b>Throws:</b> Whatever the T constructor called by the factory throws.</p>
<p><b>Notes:</b> See <A HREF="#inplace">In-Place Factories</A></p>
<p><b>Exception Safety:</b> Exceptions can only be thrown during the call to the
T constructor used by the factory;
in that case, this constructor has no effect.
</p>
<p><b>Example:</b></p>
<blockquote>

<pre>
class C { C ( char, double, std::string ) ; } ;

C v('A',123.4,&quot;hello&quot;);

optional&lt;C&gt; x( in_place   ('A', 123.4, &quot;hello&quot;) ); // InPlaceFactory used
optional&lt;C&gt; y( in_place&lt;C&gt;('A', 123.4, &quot;hello&quot;) ); // TypedInPlaceFactory used

assert ( *x == v ) ;
assert ( *y == v ) ;

</pre>
</blockquote>
</blockquote>

<HR>

<pre>optional&amp; optional&lt;T</i>&gt;::operator= ( none_t n ) ;</pre>
<blockquote>
<p><b>Effect:</b> Same as opeator=(optional const&amp; rhs), when rhs is default-constructed (uninitialized).</p>
<p><b>Postconditions:</b> <b>*this</b> is uninitialized</p>
<p><b>Example:</b></p>
<blockquote>
<pre>
#include &lt;boost/none.hpp&gt;

optional&lt;int&gt; def ;
optional&lt;int&gt; opt(123) ;

opt = boost::none ;

assert ( opt == def ) ;
</pre>
</blockquote>
</blockquote>

<HR>

<pre>optional&amp; optional&lt;T <i>(not a ref)</i>&gt;::operator= ( T const&amp; rhs ) ;</pre>
<blockquote>
<p><b>Effect:</b> Assigns the value 'rhs' to an <b>optional</b>.</p>
<p><b>Postconditions:</b> <b>*this</b> is initialized
and its value is a <i>copy</i> of <b>rhs.</b></p>
<p><b>Throws:</b> Whatever T::operator=( T const& ) or T::T(T const&amp;) throws.</p>
<p><b>Notes:</b> If <b>*this</b> was initialized, T's assignment operator is 
used, otherwise, its copy-constructor is used.</p>
<p><b>Exception Safety:</b> In the event of an exception, the initialization 
state of <b>*this</b> is unchanged and its value unspecified as far as optional 
is concerned (it is up to T's operator=()) [If <b>*this</b> is initially 
uninitialized and T's <i>copy constructor</i> fails, <b>*this</b> is left 
properly uninitialized]</p>
<p><b>Example:</b></p>
<blockquote>
<pre>
T x;
optional&lt;T&gt; def ;
optional&lt;T&gt; opt(x) ;

T y;
def = y ;
assert ( *def == y ) ;
opt = y ;
assert ( *opt == y ) ;</pre>
</blockquote>
</blockquote>

<HR>

<pre>optional&lt;T&amp;&gt;&amp; optional&lt;T&amp;&gt;::operator= ( T&amp; const&amp; rhs ) ;</pre>
<blockquote>
<p><b>Effect:</b> (Re)binds thee wrapped reference.</p>
<p><b>Postconditions:</b> <b>*this</b> is initialized
and it references the same object referenced by <b>rhs.</b></p>
<p><b>Notes:</b> If <b>*this</b> was initialized, is is <i>rebound</i> to the 
new object. See <A HREF="#refassign">here</a> for details on this behavior.</p>
<p><b>Example:</b></p>
<blockquote>
<pre>
int a = 1 ;
int b = 2 ;
T&amp; ra = a ;
T&amp; rb = b ;
optional&lt;int&amp;&gt; def ;
optional&lt;int&amp;&gt; opt(ra) ;

def = rb ; // binds 'def' to 'b' through 'rb'
assert ( *def == b ) ;
*def = a ; // changes the value of 'b' to a copy of the value of 'a'
assert ( b == a ) ;
int c = 3;
int&amp; rc = c ;
opt = rc ; // REBINDS to 'c' through 'rc'
c = 4 ;
assert ( *opt == 4 ) ;
</pre>
</blockquote>
</blockquote>

<HR>

<pre>optional&amp; optional&lt;T <i>(not a ref)</i>&gt;::operator= ( optional const&amp; rhs ) ;</pre>
<blockquote>
<p><b>Effect:</b> Assigns another <b>optional</b> to an <b>optional</b>.</p>
<p><b>Postconditions:</b> If <b>rhs</b> is initialized, <b>*this</b> is initialized
and its value is a <i>copy</i> of the value of <b>rhs</b>; else <b>*this</b>
is uninitialized.
</p>
<p><b>Throws:</b> Whatever T::operator( T const&amp;) or&nbsp; T::T( T const& ) throws.</p>
<p><b>Notes:</b> If both<b> *this</b> and <b>rhs</b> are initially initialized, 
T's <i>assignment</i> <i>operator</i> is used. If <b>*this</b> is initially initialized but <b>
rhs</b> is uninitialized, T's <i>destructor</i> is called. If <b>*this</b> is initially 
uninitialized but rhs is initialized, T's <i>copy constructor</i> is called.
</p>
<p><b>Exception Safety:</b> In the event of an exception, the initialization 
state of <b>*this</b> is unchanged and its value unspecified as far as optional 
is concerned (it is up to T's operator=()) [If <b>*this</b> is initially 
uninitialized and T's <i>copy constructor</i> fails, <b>*this</b> is left 
properly uninitialized]</p>
<p><b>Example:</b></p>
<blockquote>
    <pre>T v;
optional&lt;T&gt; opt(v);
optional&lt;T&gt; def ;

opt = def ;
assert ( !def ) ;
// previous value (copy of 'v') destroyed from within 'opt'.

</pre>
</blockquote>
</blockquote>

<HR>

<pre>optional&lt;T&amp;&gt; &amp; optional&lt;T&amp;&gt;::operator= ( optional&lt;T&amp;&gt; const&amp; rhs ) ;</pre>
<blockquote>
<p><b>Effect:</b> (Re)binds thee wrapped reference.</p>
<p><b>Postconditions:</b> If <b>*rhs</b> is initialized, *<b>this</b> is initialized
and it references the same object referenced by <b>*rhs</b>; otherwise, <b>*this</b> 
is uninitialized (and references no object).</p>
<p><b>Notes:</b> If <b>*this</b> was initialized and so is <b>*rhs</b>, <b>this</b> 
is is <i>rebound</i> to the new object. See <A HREF="#refassign">here</a> for details on this 
behavior.</p>
<p><b>Example:</b></p>
<blockquote>
    <pre>int a = 1 ;
int b = 2 ;
T&amp; ra = a ;
T&amp; rb = b ;
optional&lt;int&amp;&gt; def ;
optional&lt;int&amp;&gt; ora(ra) ;
optional&lt;int&amp;&gt; orb(rb) ;

def = orb ; // binds 'def' to 'b' through 'rb' wrapped within 'orb'
assert ( *def == b ) ;
*def = ora ; // changes the value of 'b' to a copy of the value of 'a'
assert ( b == a ) ;
int c = 3;
int&amp; rc = c ;
optional&lt;int&amp;&gt; orc(rc) ;
ora = orc ; // REBINDS ora to 'c' through 'rc'
c = 4 ;
assert ( *ora == 4 ) ;
</pre>
</blockquote>
</blockquote>

<HR>

<pre>template&lt;U&gt; optional&amp; optional&lt;T <i>(not a ref)</i>&gt;::operator= ( optional&lt;U&gt; const&amp; rhs ) ;</pre>
<blockquote>
<p><b>Effect:</b> Assigns another <i>convertible</i> <b>optional</b> to an <b>optional</b>.</p>
<p><b>Postconditions:</b> If <b>rhs</b> is initialized, <b>*this</b> is initialized
and its value is a <i>copy</i> of the value of <b>rhs</b> <i>converted</i>
to type T; else <b>*this</b> is uninitialized.
</p>
<p><b>Throws:</b> Whatever T::operator=( U const&amp; ) or T::T( U const& ) throws.</p>
<p><b>Notes:</b> If both<b> *this</b> and <b>rhs</b> are initially initialized, 
T's <i>assignment</i> <i>operator</i> (from U) is used. If <b>*this</b> is initially initialized but <b>
rhs</b> is uninitialized, T's <i>destructor</i> is called. If <b>*this</b> is initially 
uninitialized but rhs is initialized, T's <i>converting constructor</i> (from U) is called.
</p>
<p><b>Exception Safety:</b> In the event of an exception, the initialization 
state of <b>*this</b> is unchanged and its value unspecified as far as optional 
is concerned (it is up to T's operator=()) [If <b>*this</b> is initially 
uninitialized and T's <i>converting constructor</i> fails, <b>*this</b> is left 
properly uninitialized]</p>
<p><b>Example:</b></p>
<blockquote>
    <pre>T v;
optional&lt;T&gt; opt0(v);
optional&lt;U&gt; opt1;

opt1 = opt0 ;
assert ( *opt1 == static_cast&lt;U&gt;(v) ) ;
</pre>
</blockquote>
</blockquote>

<HR>
<pre>void optional&lt;T <i>(not a ref)</i>&gt;::reset( T const&amp v ) ;</pre>
<blockquote>
<p><b>Deprecated:</b> same as operator= ( T const&amp; v) ;</p>
</blockquote>

<HR>
<pre>void optional&lt;T&gt;::reset() ;</pre>
<blockquote>
<p><b>Deprecated: </b>Same as operator=( none_t n);</p>
</blockquote>

<HR>

<pre>T const&amp; optional&lt;T <i>(not a ref)</i>&gt;::operator*() const ;
T&amp;       optional&lt;T<i> (not a ref)</i>&gt;::operator*();</pre>

<pre>T const&amp; optional&lt;T <i>(not a ref)</i>&gt;::get() const ;
T&amp;       optional&lt;T <i>(not a ref)</i>&gt;::get() ;

inline T const&amp; get ( optional&lt;T<i> (not a ref)</i>&gt; const&amp; ) ;
inline T&amp;       get ( optional&lt;T <i>(not a ref)</i>&gt; &amp;) ;
</pre>
<blockquote>
<p><b>Requirements: *this</b> is initialized</p>
<p><b>Returns:</b> A reference to the contained value</p>
<p><b>Throws:</b> Nothing.</p>
<p><b>Notes:</b> The requirement is asserted via BOOST_ASSERT().</p>
<p><b>Example:</b></p>
<blockquote>
    <pre>T v ;
optional&lt;T&gt; opt ( v );
T const&amp; u = *opt;
assert ( u == v ) ;
T w ;
*opt = w ;
assert ( *opt == w ) ;
</pre>
  </blockquote>
    <pre></pre>
</blockquote>

<HR>


<pre>T const&amp; optional&lt;T&amp;&gt;::operator*() const ;
T      &amp; optional&lt;T<i>&amp;</i>&gt;::operator*();</pre>

<pre>T const&amp; optional&lt;T&amp;&gt;::get() const ;
T&amp;       optional&lt;T&amp;&gt;::get() ;

inline T const&amp; get ( optional&lt;T<i>&amp;</i>&gt; const&amp; ) ;
inline T&amp;       get ( optional&lt;T&amp;&gt; &amp;) ;
</pre>
<blockquote>
<p><b>Requirements: *this</b> is initialized</p>
<p><b>Returns:</b> <u>The</u> reference contained.</p>
<p><b>Throws:</b> Nothing.</p>
<p><b>Notes:</b> The requirement is asserted via BOOST_ASSERT().</p>
<p><b>Example:</b></p>
<blockquote>
    <pre>T v ;
T&amp; vref = v ;
optional&lt;T&amp;&gt; opt ( vref );
T const&amp; vref2 = *opt;
assert ( vref2 == v ) ;
++ v ;
assert ( *opt == v ) ;</pre>
  </blockquote>
</blockquote>

<HR>

<pre>T const&amp; optional&lt;T&gt;::get_value_or( T const&amp; default) const ;
T&amp;       optional&lt;T&gt;::get_value_or( T&amp;       default ) ;

inline T const&amp; get_optional_value_or ( optional&lt;T&gt; const&amp; o, T const&amp; default ) ;
inline T&amp;       get_optional_value_or ( optional&lt;T&gt;&amp;       o, T&amp;       default ) ;
</pre>
<blockquote>
<p><b>Returns:</b> A reference to the contained value (which can be itself a reference), if any, or <code>default</code></p>
<p><b>Throws:</b> Nothing.</p>
<p><b>Example:</b></p>
<blockquote>
    <pre>T v, z ;
optional&lt;T&gt; def;
T const&amp; y = def.get_value_or(z);
assert ( y == z ) ;

optional&lt;T&gt; opt ( v );
T const&amp; u = get_optional_value_or(opt,z);
assert ( u == v ) ;
assert ( u != z ) ;
</pre>
  </blockquote>
    <pre></pre>
</blockquote>

<HR>

<pre>T const* optional&lt;T&gt;::get_ptr() const ;
T*       optional&lt;T&gt;::get_ptr() ;

inline T const* get_pointer ( optional&lt;T&gt; const&amp; ) ;
inline T*       get_pointer ( optional&lt;T&gt; &amp;) ;
</pre>
<blockquote>
<p><b>Returns:</b> If <b>*this</b> is initialized, a pointer to the contained
value; else 0 (<i>null</i>).
</p>
<p><b>Throws:</b> Nothing.</p>
<p><b>Notes:</b> If T is a reference type, the pointer is to the referenced object</p>
<p><b>Notes:</b> The contained value is permanently stored within *this, so
you should not hold nor delete this pointer.
</p>
<p><b>Example:</b></p>
<blockquote>
    <pre>int v=123;
optional&lt;int&gt; opt(v);
optional&lt;int&gt; const copt(v);
int* p = opt.get_ptr() ;
int const* cp = copt.get_ptr();
assert ( p == get_pointer(opt) );
assert ( cp == get_pointer(copt) ) ;

int& rv = v ;
optional&lt;int&amp;&gt; optr(rv);

*(optr.get_ptr()) = 456 ;

assert ( v == 456 );


</pre>
</blockquote>
</blockquote>


<HR>


<pre>T const* optional&lt;T&gt;::operator -&gt;() const ;
T*       optional&lt;T&gt;::operator -&gt;()       ;
</pre>
<blockquote>
<p><b>Requirements: *this</b> is initialized.</p>
<p><b>Returns:</b> A pointer to the contained value.</p>
<p><b>Throws:</b> Nothing.</p>
<p><b>Notes:</b> If T is a reference type, the pointer is to the referenced object</p>
<p><b>Notes:</b> The requirement is asserted via BOOST_ASSERT().</p>
<p><b>Example:</b></p>
<blockquote>
<pre>struct X { int mdata ; } ;
X x ;
optional&lt;X&gt; opt (x);
opt-&gt;mdata = 2 ;

X& rx = x ;

optional&lt;X&amp;&gt; optr (rx);
optr-&gt;mdata = 4 ;

assert ( x.mdata = 4 ) 

</pre>
</blockquote>
</blockquote>


<HR>


<pre>optional&lt;T&gt;::operator <i>unspecified-bool-type</i>() const ;</pre>
<blockquote>
<p><b>Returns:</b> An unspecified value which if used on a boolean context is equivalent to (get() != 0)</p>
<p><b>Throws:</b> Nothing.</p>
<blockquote>
    <pre>optional&lt;T&gt; def ;
assert ( def == 0 );
optional&lt;T&gt; opt ( v ) ;
assert ( opt );
assert ( opt != 0 );
</pre>
</blockquote>
</blockquote>

<HR>


<pre> bool optional&lt;T&gt;::operator!() ;</pre>
<blockquote>
<p><b>Returns:</b> If <b>*this</b> is uninitialized, <code>true</code>; else <code>false.</code></p>
<p><b>Throws:</b> Nothing.</p>
<p><b>Notes:</b> This operator is provided for those compilers which can't use
the <i>unspecified-bool-type</i> operator in certain boolean contexts.
</p>
<p><b>Example:</b></p>
<blockquote>
    <pre>optional&lt;T&gt; opt ;
assert ( !opt );
*opt = some_T ;

// Notice the &quot;double-bang&quot; idiom here.
assert ( !!opt ) ;
</pre>
</blockquote>
</blockquote>


<HR>


<pre>bool optional&lt;T&gt;::is_initialized() const ;</pre>
<blockquote>
<p><b>Returns:</b> <i>true</i> is the <b>optional</b> is initialized, <i>false</i>
otherwise.</p>
<p><b>Throws:</b> Nothing.</p>
<blockquote>
    <pre>optional&lt;T&gt; def ;
assert ( !def.is_initialized() );
optional&lt;T&gt; opt ( v ) ;
assert ( opt.is_initialized() );</pre>
</blockquote>
</blockquote>

<HR>

<pre>optional&lt;T <i>(not a ref)</i>&gt; make_optional( T const&amp; v )</pre>
<blockquote>
<p><b>Returns:</b> optional&lt;T&gt;(v) for the <i>deduced</i> type <code>T</code> of <code>v</code>.</p>
<p><b>Example:</b></p>
<blockquote>
<pre>template&lt;class T&gt; void foo ( optional&lt;T&gt; const& opt ) ;

foo ( make_optional(1+1) ) ; // Creates an optional&lt;int&gt;
</blockquote>
</blockquote>
<HR>

<pre>optional&lt;T <i>(not a ref)</i>&gt; make_optional( bool condition, T const&amp; v )</pre>
<blockquote>
<p><b>Returns:</b> optional&lt;T&gt;(condition,v) for the <i>deduced</i> type <code>T</code> of <code>v</code>.</p>
<p><b>Example:</b></p>
<blockquote>
<pre>optional&lt;double&gt; calculate_foo()
{
  double val = compute_foo();
  return make_optional(is_not_nan_and_finite(val),val);
}

optional&lt;double&gt; v = calculate_foo();
if ( !v )
  error("foo wasn't computed");
</blockquote>
</blockquote>

<HR>


<pre>bool operator == ( optional&lt;T&gt; const&amp x, optional&lt;T&gt const&amp y );</pre>
<blockquote>
<p><b>Returns:</b> If both <b>x</b> and <b>y</b> are initialied, <code>(*x == *y)</code>.
If only x or y is initialized, <code>false</code>. If both are uninitialized, <code>true</code>. </p>
<p><b>Throws:</b> Nothing.</p>
<p><b>Notes:</b> Pointers have shallow relational operators while <b>optional</b> has
deep relational operators. Do not use operator == directly in generic code
which expect to be given either an optional&lt;T&gt; or a pointer;
use <a href="../../utility/OptionalPointee.html#equal">equal_pointees()</a> instead </p>
<p><b>Example:</b></p>
<blockquote>
    <pre>T x(12);
T y(12);
T z(21);
optional&lt;T&gt; def0 ;
optional&lt;T&gt; def1 ;
optional&lt;T&gt; optX(x);
optional&lt;T&gt; optY(y);
optional&lt;T&gt; optZ(z);

// Identity always hold
assert ( def0 == def0 );
assert ( optX == optX );

// Both uninitialized compare equal
assert ( def0 == def1 );

// Only one initialized compare unequal.
assert ( def0 != optX );

// Both initialized compare as (*lhs == *rhs)
assert ( optX == optY ) ;
assert ( optX != optZ ) ;
</pre>
</blockquote>
</blockquote>

<HR>


<pre>bool operator &lt; ( optional&lt;T&gt; const&amp x, optional&lt;T&gt const&amp y );</pre>
<blockquote>
<p><b>Returns:</b> If <b>y</b> is not initialized, <code>false</code>.
If <b>y</b> is initialized and <b>x</b> is not initialized, <code>true</code>.
If both <b>x</b> and <b>y</b> are initialized, <code>(*x &lt; *y)</code>. </p>
<p><b>Throws:</b> Nothing.</p>
<p><b>Notes:</b> Pointers have shallow relational operators while <b>optional</b> has
deep relational operators. Do not use operator &lt; directly in generic code
which expect to be given either an optional&lt;T&gt; or a pointer;
use <a href="../../utility/OptionalPointee.html#less">less_pointees()</a> instead </p>
<p><b>Example:</b></p>
<blockquote>
    <pre>T x(12);
T y(34);
optional&lt;T&gt; def ;
optional&lt;T&gt; optX(x);
optional&lt;T&gt; optY(y);

// Identity always hold
assert ( !(def &lt; def) );
assert ( optX == optX );

// Both uninitialized compare equal
assert ( def0 == def1 );

// Only one initialized compare unequal.
assert ( def0 != optX );

// Both initialized compare as (*lhs == *rhs)
assert ( optX == optY ) ;
assert ( optX != optZ ) ;
</pre>
</blockquote>
</blockquote>

<HR>
<pre>bool operator != ( optional&lt;T&gt; const&amp x, optional&lt;T&gt const&amp y );
</pre>
<blockquote>
  <p><b>Returns:</b> !( x == y );</p>
  <p><b>Throws:</b> Nothing.</p>
</blockquote>

<HR>
<pre>bool operator &gt; ( optional&lt;T&gt; const&amp x, optional&lt;T&gt const&amp y );
</pre>
<blockquote>
  <p><b>Returns:</b> ( y &lt; x );</p>
  <p><b>Throws:</b> Nothing.</p>
</blockquote>

<HR>
<pre>bool operator &lt;= ( optional&lt;T&gt; const&amp x, optional&lt;T&gt const&amp y );
</pre>
<blockquote>
  <p><b>Returns:</b> !( y&lt;x );</p>
  <p><b>Throws:</b> Nothing.</p>
</blockquote>

<HR>
<pre>bool operator &gt;= ( optional&lt;T&gt; const&amp x, optional&lt;T&gt const&amp y );
</pre>
<blockquote>
  <p><b>Returns:</b> !( x&lt;y );</p>
  <p><b>Throws:</b> Nothing.</p>
</blockquote>

<HR>
<pre>
bool operator == ( optional&lt;T&gt; const&amp; x, T const&amp; n );
bool operator != ( optional&lt;T&gt; const&amp; x, T const&amp; n );
bool operator &lt;  ( optional&lt;T&gt; const&amp; x, T const&amp; n );
bool operator &gt;  ( optional&lt;T&gt; const&amp; x, T const&amp; n );
bool operator &lt;= ( optional&lt;T&gt; const&amp; x, T const&amp; n );
bool operator &gt;= ( optional&lt;T&gt; const&amp; x, T const&amp; n );
bool operator == ( T const&amp; n, optional&lt;T&gt; const&amp; y );
bool operator != ( T const&amp; n, optional&lt;T&gt; const&amp; y );
bool operator &lt;  ( T const&amp; n, optional&lt;T&gt; const&amp; y );
bool operator &gt;  ( T const&amp; n, optional&lt;T&gt; const&amp; y );
bool operator &lt;= ( T const&amp; n, optional&lt;T&gt; const&amp; y );
bool operator &gt;= ( T const&amp; n, optional&lt;T&gt; const&amp; y );
</pre>
<blockquote>
  <p><b>Returns:</b> The result obtained by replacing the argument 'n' by optional&lt;T&gt;(n).</p>
</blockquote>

<HR>
<pre>
bool operator == ( optional&lt;T&gt; const&amp; x, none_t n );
bool operator != ( optional&lt;T&gt; const&amp; x, none_t n );
bool operator &lt;  ( optional&lt;T&gt; const&amp; x, none_t n );
bool operator &gt;  ( optional&lt;T&gt; const&amp; x, none_t n );
bool operator &lt;= ( optional&lt;T&gt; const&amp; x, none_t n );
bool operator &gt;= ( optional&lt;T&gt; const&amp; x, none_t n );
bool operator == ( none_t n, optional&lt;T&gt; const&amp; y );
bool operator != ( none_t n, optional&lt;T&gt; const&amp; y );
bool operator &lt;  ( none_t n, optional&lt;T&gt; const&amp; y );
bool operator &gt;  ( none_t n, optional&lt;T&gt; const&amp; y );
bool operator &lt;= ( none_t n, optional&lt;T&gt; const&amp; y );
bool operator &gt;= ( none_t n, optional&lt;T&gt; const&amp; y );
</pre>
<blockquote>
  <p><b>Returns:</b> The result obtained by replacing the argument 'n' by optional&lt;T&gt;().</p>
</blockquote>
<HR>

<pre>void swap ( optional&lt;T&gt;&amp x, optional&lt;T&gt&amp y );</pre>

<blockquote>
<p><b>Effect:</b> If both <b>x</b> and <b>y</b> are initialized, calls <code>swap(*x,*y)</code> using std::swap.<br>
If only one is initialized, say x, calls: <code>y = *x; x = boost:none;</code><br>
If none is initialized, does nothing. </p>
<p><b>Postconditions:</b> The states of x and y interchanged.</p>
<p><b>Throws:</b> If both are initialized, whatever swap(T&amp;,T&amp;) throws.
If only one is initialized, whatever T::T ( T const&amp; ) throws. </p>
<p><b>Notes:</b> If both are initialized, swap(T&amp;,T&amp;) is used <i>unqualified</i> but with std::swap introduced in scope.<br>
If only one is initialized, T::~T() and T::T( T const& ) is called. </p>
<p><b>Exception Safety:</b> If both are initialized, this operation has the exception
safety guarantees of swap(T&,T&).<br>
If only one is initialized, it has the same <b>basic</b> guarantee as optional&lt;T&gt;::operator=( T const& ). </p>
<p><b>Example:</b></p>
<blockquote>
      <pre>T x(12);
T y(21);
optional&lt;T&gt; def0 ;
optional&lt;T&gt; def1 ;
optional&lt;T&gt; optX(x);
optional&lt;T&gt; optY(y);

boost::swap(def0,def1); // no-op

boost::swap(def0,optX);
assert ( *def0 == x );
assert ( !optX );

boost::swap(def0,optX); // Get back to original values

boost::swap(optX,optY);
assert ( *optX == y );
assert ( *optY == x );

</pre>
</blockquote>
</blockquote>
<HR>

<H2><A NAME="examples">Examples</A></H2>

<h3>Optional return values</h3>
<PRE>optional&lt;char&gt; get_async_input()
{
&nbsp; if ( !queue.empty() )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return optional&lt;char&gt;(queue.top());
&nbsp; else return optional&lt;char&gt;(); // uninitialized
}

void receive_async_message()
{
&nbsp; optional&lt;char&gt; rcv ;
&nbsp; // The safe boolean conversion from 'rcv' is used here.
&nbsp; while ( (rcv = get_async_input()) &amp;&amp; !timeout() )
&nbsp;&nbsp;&nbsp; output(*rcv);
}
</pre>

<h3>Optional local variables</h3>
<pre>optional&lt;string&gt; name ;
if ( database.open() )
{
&nbsp; name = database.lookup(employer_name) ;
}
else
{
&nbsp; if ( can_ask_user )
&nbsp;&nbsp;&nbsp; name = user.ask(employer_name) ;
}

if ( name )
&nbsp;&nbsp;&nbsp;&nbsp; print(*name);
else print(&quot;employer's name not found!&quot;);
</pre>

<h3>Optional data members</h3>
<pre>class figure
{
&nbsp; public:

&nbsp;&nbsp;&nbsp; figure()
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // data member 'm_clipping_rect' is uninitialized at this point.
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; void clip_in_rect ( rect const&amp; rect )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ....
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_clipping_rect = rect ; // initialized here.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; void draw ( canvas& cvs )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( m_clipping_rect )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do_clipping(*m_clipping_rect);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cvs.drawXXX(..);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; // this can return NULL.
&nbsp;&nbsp;&nbsp; rect const* get_clipping_rect() { return get_pointer(m_clipping_rect); }

&nbsp; private :

&nbsp;&nbsp;&nbsp; optional&lt;rect&gt; m_clipping_rect ;

};
</pre>
<h3>Bypassing expensive unnecessary default construction</h3>
<pre>class ExpensiveCtor { ... } ;
class Fred
{
&nbsp; Fred() : mLargeVector(10000) {}

&nbsp; std::vector< optional&lt;ExpensiveCtor&gt; > mLargeVector ;
} ;
</pre>

<HR>

<H2><A NAME="ref">Optional references</A></H2>
<p>This library allows the template parameter T to be of reference type: T&amp;, and
to some extent, T const&amp;.</p>

<p>However, since references are not real objects some restrictions apply and
some operations are not available in this case:</p>

<ul>
  <li>Converting constructors</li>
  <li>Converting assignment</li>
  <li>InPlace construction</li>
  <li>InPlace assignment</li>
</ul>
<p>Also, even though optional&lt;T&amp;&gt; treats it wrapped pseudo-object much as a real
value, a true real reference is stored, thus aliasing can ocurr: </p>

<ul>
  <li>Copies of optional&lt;T&amp;&gt; copies the reference, but all copied references
  will nonetheless reefer to the same object.</li>
  <li>Value-access provides access to the referenced object rather
  than the reference itself.</li>
  <li>Pointer-access provides a pointer to the referenced object rather
  than a pointer to the reference itself.</li>
</ul>

<HR>
<h2><A NAME="refassign">Rebinding semantics for assignment of optional 
references</a></h2>
<p>If you assign to an <i>uninitialized</i> optional&lt;T&amp;&gt; the effect is to bind (for the first time) to the object. 
Clearly, there is no other choice.</p>
<pre>int x = 1 ;
int&amp; rx = x ;
optional&lt;int&amp;&gt; ora ;
optional&lt;int&amp;&gt; orb(rx) ;
ora = orb ; // now 'ora'&nbsp;is bound to 'x' through 'rx'
*ora = 2 ; // Changes value of 'x' through 'ora'
assert(x==2); 
</pre>
<p>If you assign to a bare C++ reference, the assignment is forwarded to the 
referenced object; it's value changes but the reference is never rebound.</p>
<pre>int a = 1 ;
int&amp; ra = a ;
int b = 2 ;
int&amp; rb = b ;
ra = rb ; // Changes the VALUE of 'a' to that of 'b'
assert(a==b);
b = 3 ;
assert(ra!=b); // 'ra' is not rebound to 'b'
</pre>
<p>Now, if you assign to an <i>initialized</i> optional&lt;T&amp;&gt;, the effect is to <b>rebind</b> to the new object instead of assigning the referee. This is unlike 
bare C++ references.</p>
<pre>int a = 1 ;
int b = 2 ;
int&amp; ra = a ;
int&amp; rb = b ;
optional&lt;int&amp;&gt; ora(ra) ;
optional&lt;int&amp;&gt; orb(rb) ;
ora = orb ; // 'ora'&nbsp;is <b>rebound</b> to 'b'
*ora = 3 ; // Changes value of 'b' (not 'a')
assert(a==1); 
assert(b==3); 
</pre>
<h3>Rationale:</h3>
<p>Rebinding semantics for the assignment of <i>initialized</i> optional 
references has been chosen to provide<b><i> </i>consistency among initialization 
states<i> </i></b>even at the expense of lack of consistency with the semantics of bare 
C++ references.<br>
It is true that optional&lt;U&gt; strives to behave as much as possible as U does 
whenever it is initialized; but in the case when U is T&amp;, doing so would result 
in inconsistent behavior w.r.t to the lvalue initialization state.</p>
<p>Consider the following code :</p>
<pre>
int x = 1 ;
int& rx = x ;
void foo ( optional&lt;int&amp;&gt; & outer )
{
  optional&lt;int&amp;&gt; b(rx);
  outer = b ;
}
</pre>
<p>What should the assignment to 'outer' do?<br>
If 'outer' is <i>uninitialized</i>, the answer is clear: it should bind to 'x' (so we now have 
a second reference to 'x').<br>
But what if 'outer' is already <i>initialized?</i><br>
The assignment could change the value of the 
referenced object (whatever that is), but doing that would be inconsistent with the uninitialized case
and then you wouldn't be able to reason at compile time about all the references to x since
the appearance of a new reference to it would depend on wheter the lvalue ('outer')
is initialized or not.</p>
<p>Arguably, if rebinding the reference to another object is wrong for your code, then is 
likely that binding it for the fist time via assignment instead of intialization is also wrong.
In that case, you can always just assign the value to the referenced object directly via
the access operator <code>*opt=value</code>.</p>
<p>If rebinding is wrong but first-time binding 
isn't (via assignment), you can always work around the rebinding semantics using a discriminator:</p>
<pre>
if ( !opt )
      opt = value ; // first-time binding
else *opt = value ; // assign to referee without rebinding 
</pre>

<HR>

<H2><A NAME="none">none_t and none</A></H2>
<p>optional&lt;T&gt; supports uninitialized states with a convenient syntax via a constant of 
the <i>implementation-defined</i> type <code>boost::none_t</code>, identified as <code>boost::none</code>.</p>
<p>Starting with Boost version 1.34.0, both <code>boost::none_t</code> and <code>boost::none</code> are
included in <code>boost/none.hpp</code>, which is automatically included by <code>boost/optional/optional.hpp</code>
</p>
<p>This contant is similar in purpose to NULL, except that is not a <i>null pointer value</i>. You can use it to initialize  
an optional&lt;T&gt; instance, which has the same effect of a default constructor, and you can assign it which has the 
effect of reseting the optional&lt;T&gt; instance. You can also use it in relational operators to make the predicate expression
more clear.</p>
<p>Here are some typical examples:</p>
<pre>
#include "boost/optional/optional.hpp" // boost/none.hpp is included automatically

boost::optional&lt;int&gt; foo ( int a )
{
  return some_condition(a) ? boost::make_optional(a) : boost::none ;  
  
  // NOTE: in real code you can just use this: make_optional(some_condition(a), a ) 
}

boost::optional&lt;int&gt; opt = boost::none ;

if ( opt == boost::none )
  opt = foo(123);

opt = boost::none ;

</pre>

<HR>

<H2><A NAME="inplace">In-Place Factories</A></H2>
<p>
One of the typical problems with wrappers and containers is that their
interfaces usually provide an operation to initialize or assign the contained
object as a copy of some other object. This not only requires the underlying
type to be <a href="../../utility/CopyConstructible.html">Copy Constructible</a>, but also requires the existence of a fully
constructed object, often temporary, just to follow the copy from:</p>
<pre>struct X
{
  X ( int, std:::string ) ;
} ;</pre>
<pre>class W
{
  X wrapped_ ;

public:

  W ( X const& x ) : wrapped_(x) {}
} ;</pre>
<pre>void foo()
{
  // Temporary object created.
  W ( X(123,"hello") ) ;
}
</pre>
<p>A solution to this problem is to support direct construction of the contained
object right in the container's storage.<br>
In this scheme, the user only needs to supply the arguments to the constructor
to use in the wrapped object construction.</p>
<pre>class W
{
  X wrapped_ ;

public:

  W ( X const& x ) : wrapped_(x) {}
  W ( int a0, std::string a1) : wrapped_(a0,a1) {}
} ;</pre>
<pre>void foo()
{
  // Wrapped object constructed in-place
  // No temporary created.
  W (123,"hello") ;
}
</pre>
<p>A limitation of this method is that it doesn't scale well to wrapped objects with multiple
constructors nor to generic code were the constructor overloads are unknown.</p>
<p>The solution presented in this library is the family of <b>InPlaceFactories</b> and <b>TypedInPlaceFactories</b>.<br>
These factories are a family of classes which encapsulate an increasing number of arbitrary
constructor parameters and supply a method to construct an object of a given type using those
parameters at an address specified by the user via placement new.</p>
<p>&nbsp;For example, one member of this family looks like:</p>
<pre>template&lt;class T,class A0, class A1&gt;
class TypedInPlaceFactory2
{
  A0 m_a0 ; A1 m_a1 ;

public:

  TypedInPlaceFactory2( A0 const& a0, A1 const& a1 ) : m_a0(a0), m_a1(a1) {}

  void construct ( void* p ) { new (p) T(m_a0,m_a1) ; }
} ;
</pre>
<p>A wrapper class aware of this can use it as:</p>
<pre>class W
{
  X wrapped_ ;

public:

  W ( X const& x ) : wrapped_(x) {}
  W ( TypedInPlaceFactory2 const& fac ) { fac.construct(&wrapped_) ; }
} ;</pre>
<pre>void foo()
{
  // Wrapped object constructed in-place via a TypedInPlaceFactory.
  // No temporary created.
  W ( TypedInPlaceFactory2&lt;X,int,std::string&rt;(123,"hello")) ;
}
</pre>
<p>The factories are divided in two groups:<ul>
  <li><u>TypedInPlaceFactories</u>: those which take the target type as a primary template parameter.</li>
  <li><u>InPlaceFactories</u>: those with a template <code>construct(void*)</code> member function taking the target type.</li>
  </ul>
<p>Within each group, all the family members differ only in the number of parameters allowed.</p>
<p></p>
<p>This library provides an overloaded set of helper template functions to construct these factories
without requiring unnecessary template parameters:</p>
<pre>template&lt;class A0,...,class AN&gt;
InPlaceFactory<i>N </i>&lt;A0,...,AN&gt; <b>in_place</b> ( A0 const& a0, ..., AN const& aN) ;

template&lt;class T,class A0,...,class AN&gt;
TypedInPlaceFactory<i>N </i>&lt;T,A0,...,AN&gt; <b>in_place</b> ( T const& a0, A0 const& a0, ..., AN const& aN) ;</pre>

<p>In-place factories can be used generically by the wrapper and user as follows:</p>
<pre>class W
{
  X wrapped_ ;

public:

  W ( X const& x ) : wrapped_(x) {}

  template<class InPlaceFactory></class>
  W ( InPlaceFactory const& fac ) { fac.template &lt;X&gt;construct(&wrapped_) ; }

} ;</pre>
<pre>void foo()
{
  // Wrapped object constructed in-place via a InPlaceFactory.
  // No temporary created.
  W ( in_place(123,"hello") ) ;
}
</pre>
<p>The factories are implemented in the headers: <a href="../../../boost/utility/in_place_factory.hpp">in_place_factory.hpp</a> and <a href="../../../boost/utility/typed_in_place_factory.hpp">typed_in_place_factory.hpp</a> </p>

<HR>

<H2><A NAME="bool">A note about optional&lt;bool&gt;</A></H2>
<p><code>optional&lt;bool&gt;</code> should be used with special caution and consideration.</p>
<p>First, it is functionally similar to a tristate boolean (false,maybe,true) &mdash;such as <a href="http://www.boost.org/doc/html/tribool.html">boost::tribool</a>&mdash;except that in a tristate boolean,
the <i>maybe</i> state <u>represents a valid value</u>, unlike the corresponding state
of an uninitialized optional&lt;bool&gt;.<br>
It should be carefully considered if an optional&lt;bool&gt; instead of a tribool is really needed</p>
<p>Second, optional&lt;&gt; provides a simple way to test initialization state: an implicit conversion to a type that evaluates as a 'bool' in a boolean context.<br>
Using optional&lt;bool&gt; can lead to subtle errors due to this implicit conversion:</p>
<pre>void foo ( bool v ) ;
void bar()
{
&nbsp; optional&lt;bool&gt; v = try();

&nbsp; // The following intended to pass the <b>value</b> of 'v' to foo():
&nbsp; foo(v);
&nbsp; // But instead, the <i>initialization state</i> is passed
&nbsp; // due to a typo: it should have been foo(<b>*</b>v).
}
</pre>
<p>The only implicit conversion is to bool, and it is <i>safe</i> in the sense that typical
integral promotions don't apply (i.e. if foo() takes an 'int' instead, it won't compile). <HR>

<H2><A NAME="exsafety">Exception Safety Guarantees</A></H2>

<H3><u>Assignment:</u></H3>
<p><i>IMPORTANT NOTE: This changed in 1.33.1 with respect to previous versions</i></p>
<p>Because of the current implementation (see <A HREF="#impl">Implementation Notes</A>), all
of the assignment methods:</p>
<ul>
  <li> <code>optional&lt;T&gt;::operator= ( optional&lt;T&gt; const&amp; ) </code>
  </li>
  <li> <code>optional&lt;T&gt;::operator= ( T const&amp; ) </code></li>
  <li> <code>template&lt;class U&gt; optional&lt;T&gt;::operator= ( optional&lt;U&gt; const&amp; ) </code>
  </li>
  <li> <code>template&lt;class InPlaceFactory&gt; optional&lt;T&gt;::operator= (
  InPlaceFactory const&amp; ) </code></li>
  <li> <code>template&lt;class TypedInPlaceFactory&gt; optional&lt;T&gt;::operator= (
  TypedInPlaceFactory const&amp; ) </code></li>
</ul>
<p>cannot offer any <i>exception safety guarantee</i> beyond that provided by <code>T::operator=( T const&amp; )</code></p>
<p>On the other hand, the <i>uninitializing</i> methods:</p>
<ul>
  <li><code>optional&lt;T&gt;::operator= ( detail::none_t ) </code></li>
</ul>
<p>Provides the no-throw guarantee (assuming a no-throw T::~T()) becuse it only destroys the stored object.</p>

<H3><u>Swap:</u></H3>
<p><code>void swap( optional&lt;T&gt;&amp;, optional&lt;T&gt;&amp; )</code> has the same exception guarantee as <code>swap(T&amp;,T&amp;)</code> when both optionals are initialized.<br>
If only one of the optionals is initialized, it gives the same exception guarantee as <code>T::operator=( T const&amp; )</code> (since <code>optional&lt;T&gt;::operator=( none_t )</code> doesn't throw).<br>
If none of the optionals is initialized, it has no-throw guarantee since it is a no-op. </p>

<HR>

<H2><A NAME="requirements">Type requirements</A></H2>
<p>In general, T must be <a href="../../utility/CopyConstructible.html">Copy Constructible</a> and have a no-throw destructor. The copy-constructible requirement is not needed
if InPlaceFactories are used.<br>
T <u>is not</u> required to be <a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">Default Constructible</a> </p>

<HR>

<H2><A NAME="impl">Implementation Notes</A></H2>
<p>optional&lt;T&gt; is currently implemented
  using a custom aligned storage facility built from <code>alignment_of</code> and <code>type_with_alignment</code> (both from Type Traits). 
  It uses a separate boolean flag to indicate the initialization state.</p>
<p>Placement new with T's copy constructor and T's destructor
  is explicitly used to initialize and destroy optional values. This allows T's default constructor to be effectively by-passed.</p>
<p>If assignment is used and the lvalue optional is uninitialized, T's copy constructor is used. However, if it is already initialized, T's assignment operator is used. This prevents optional from offering any exception guarantee stronger than the one offered by the type T itself</p>

<HR>

<H2><A NAME="porta">Dependencies and Portability</A></H2>

<p>The implementation uses <code>type_traits/alignment_of.hpp</code> and <code>type_traits/type_with_alignment.hpp</code></p>

<HR>

<H2><A NAME="credits">Acknowledgments</A></H2>
<p>Pre-formal review:</p>
<blockquote>
<p>Peter Dimov suggested the name 'optional', and was the first to point out the
  need for aligned storage<br>
  Douglas Gregor developed 'type_with_alignment', and later Eric Friedman coded
  'aligned_storage', which are the core of the optional class implementation.<br>
  Andrei Alexandrescu and Brian Parker also worked with aligned storage techniques
  and their work influenced the current implementation.<br>
  Gennadiy Rozental made extensive and important comments which shaped the design.<br>
  Vesa Karvonen and Douglas Gregor made quite useful comparisons between optional,
  variant and any; and made other relevant comments. Douglas Gregor and Peter
  Dimov commented on comparisons and evaluation in boolean contexts.<br>
  Eric Friedman helped understand the issues involved with aligned storage, move/copy
  operations and exception safety.<br>
  Many others have participated with useful comments: Aleksey Gurotov, Kevlin
  Henney, David Abrahams, and others I can't recall. </p>
</blockquote>
<p>Post-formal review:</p>
<blockquote>
  <p>William Kempf carefully considered the originally proposed interface and
    suggested the new interface which is currently used. He also started and fueled
    the discussion about the analogy optional&lt;&gt;/smart pointer and about
    relational operators.<br>
    Peter Dimov, Joel de Guzman, David Abrahams, Tanton Gibbs and Ian Hanson focused
    on the relational semantics of optional (originally undefined); concluding
    with the fact that the pointer-like interface doesn't make it a pointer so
    it shall have deep relational operators.<br>
    Augustus Saunders also explored the different relational semantics between
    optional&lt;&gt; and a pointer and developed the OptionalPointee concept as
    an aid against potential conflicts on generic code.<br>
    Joel de Guzman noticed that optional&lt;&gt; can be seen as an API on top
    of variant&lt;T,nil_t&gt;.<br>
    Dave Gomboc explained the meaning and usage of the Haskell analog to optional&lt;&gt;:
    the Maybe type constructor (analogy originally pointed out by David Sankel).<br>
    Other comments were posted by Vincent Finn, Anthony Williams, Ed Brey, Rob
    Stewart, and others.<br>
    Joel de Guzman made the case for the support of references and helped with
    the proper semantics.<br>
    Mat Marcus shown the virtues of a value-oriented interface, influencing the
    current design, and contributed the idea of &quot;none&quot;.</p>
</blockquote>
<HR>

<P>Revised March 27, 2007</P>
<p> Copyright Fernando Luis Cacciola Carballal, 2003-2007</p>
<p> Use, modification, and distribution are subject to the Boost Software
License, Version 1.0. (See accompanying file <a href="../../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a>)</p>
<P>Developed by <A HREF="mailto:fernando_cacciola@hotmail.com">Fernando Cacciola</A>,
the latest version of this file can be found at <A
HREF="http://www.boost.org">www.boost.org</A>, and the boost <A HREF="http://www.boost.org/more/mailing_lists.htm#main">discussion lists</A></P>
</pre></BODY>
</HTML>