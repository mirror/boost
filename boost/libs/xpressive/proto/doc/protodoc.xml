<?xml version="1.0" standalone="yes"?>
<library-reference><header name="boost/xpressive/proto/args.hpp"><para>Contains definition of args&lt;&gt; class template. </para><namespace name="boost"><namespace name="proto"><struct name="args1"><template>
      <template-type-parameter name="Arg0"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="size" specifiers="static"><type>const long</type></data-member><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>mpl::void_</type></typedef><typedef name="arg2"><type>mpl::void_</type></typedef><typedef name="arg3"><type>mpl::void_</type></typedef><typedef name="arg4"><type>mpl::void_</type></typedef></struct><struct name="args2"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="size" specifiers="static"><type>const long</type></data-member><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>Arg1</type></typedef><typedef name="arg2"><type>mpl::void_</type></typedef><typedef name="arg3"><type>mpl::void_</type></typedef><typedef name="arg4"><type>mpl::void_</type></typedef></struct><struct name="args3"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="size" specifiers="static"><type>const long</type></data-member><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>Arg1</type></typedef><typedef name="arg2"><type>Arg2</type></typedef><typedef name="arg3"><type>mpl::void_</type></typedef><typedef name="arg4"><type>mpl::void_</type></typedef></struct><struct name="args4"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
      <template-type-parameter name="Arg3"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="size" specifiers="static"><type>const long</type></data-member><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>Arg1</type></typedef><typedef name="arg2"><type>Arg2</type></typedef><typedef name="arg3"><type>Arg3</type></typedef><typedef name="arg4"><type>mpl::void_</type></typedef></struct><struct name="args5"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
      <template-type-parameter name="Arg3"/>
      <template-type-parameter name="Arg4"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="size" specifiers="static"><type>const long</type></data-member><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>Arg1</type></typedef><typedef name="arg2"><type>Arg2</type></typedef><typedef name="arg3"><type>Arg3</type></typedef><typedef name="arg4"><type>Arg4</type></typedef></struct></namespace></namespace></header><header name="boost/xpressive/proto/context.hpp"><para>Definintion of context&lt;&gt;, a default evaluation context for expr&lt;&gt;eval() that uses Boost.Typeof to deduce return types of the built-in operators. </para><namespace name="boost"><namespace name="proto"><struct name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
      <template-type-parameter name="Tag"><default>typename Expr::tag_type</default></template-type-parameter>
      <template-nontype-parameter name="Arity"><type>long</type><default>Expr::arity::value</default></template-nontype-parameter>
    </template></struct><struct name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
      <template-nontype-parameter name="Arity"><type>long</type><default>Expr::arity::value</default></template-nontype-parameter>
    </template></struct><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::tag_type, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group><method-group name="private member functions"><method name="char" cv=""><type>typedef</type><parameter name="no_type"><paramtype>&amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::true_</paramtype></parameter></method><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::false_</paramtype></parameter></method></method-group><method-group name="private static functions"><method name="check" cv=""><type>static yes_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>T const &amp;</paramtype></parameter></method><method name="check" cv=""><type>static no_type</type><parameter name=""><paramtype>typename inner_context::private_type_ const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::tag_type, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 1 &gt;::const_reference)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group><method-group name="private member functions"><method name="char" cv=""><type>typedef</type><parameter name="no_type"><paramtype>&amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::true_</paramtype></parameter></method><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::false_</paramtype></parameter></method></method-group><method-group name="private static functions"><method name="check" cv=""><type>static yes_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>T const &amp;</paramtype></parameter></method><method name="check" cv=""><type>static no_type</type><parameter name=""><paramtype>typename inner_context::private_type_ const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>3</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::tag_type, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 1 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 2 &gt;::const_reference)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group><method-group name="private member functions"><method name="char" cv=""><type>typedef</type><parameter name="no_type"><paramtype>&amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::true_</paramtype></parameter></method><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::false_</paramtype></parameter></method></method-group><method-group name="private static functions"><method name="check" cv=""><type>static yes_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>T const &amp;</paramtype></parameter></method><method name="check" cv=""><type>static no_type</type><parameter name=""><paramtype>typename inner_context::private_type_ const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>4</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::tag_type, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 1 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 2 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 3 &gt;::const_reference)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group><method-group name="private member functions"><method name="char" cv=""><type>typedef</type><parameter name="no_type"><paramtype>&amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::true_</paramtype></parameter></method><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::false_</paramtype></parameter></method></method-group><method-group name="private static functions"><method name="check" cv=""><type>static yes_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>T const &amp;</paramtype></parameter></method><method name="check" cv=""><type>static no_type</type><parameter name=""><paramtype>typename inner_context::private_type_ const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>5</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::tag_type, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 1 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 2 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 3 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 4 &gt;::const_reference)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group><method-group name="private member functions"><method name="char" cv=""><type>typedef</type><parameter name="no_type"><paramtype>&amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::true_</paramtype></parameter></method><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter><parameter name=""><paramtype>mpl::false_</paramtype></parameter></method></method-group><method-group name="private static functions"><method name="check" cv=""><type>static yes_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>T const &amp;</paramtype></parameter></method><method name="check" cv=""><type>static no_type</type><parameter name=""><paramtype>typename inner_context::private_type_ const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct name="default_context"><description><para>default_context </para></description><struct name="eval"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::default_eval&lt; Expr, Context, Tag, Arity &gt;</inherit><description><para>default_context::eval </para></description></struct></struct><struct name="callable_context"><template>
      <template-type-parameter name="Context"/>
    </template><description><para>callable_context </para></description><struct name="eval"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::callable_eval&lt; Expr, Context &gt;</inherit><description><para>callable_context::eval </para></description></struct></struct><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::posit</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::negate</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::dereference</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::complement</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::address_of</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::logical_not</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::pre_inc</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::pre_dec</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::shift_left</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::shift_right</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::multiplies</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::divides</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::modulus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::plus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::minus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::less</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::greater</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::less_equal</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::greater_equal</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::equal_to</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::not_equal_to</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::logical_or</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::logical_and</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_and</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_or</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_xor</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::mem_ptr</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::shift_left_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::shift_right_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::multilpies_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::divides_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::modulus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::plus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::minus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_and_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_or_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_xor_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::terminal</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type>mpl::if_&lt; is_const&lt; Expr &gt;, typename <classname>proto::result_of::arg</classname>&lt; Expr &gt;::const_reference, typename <classname>proto::result_of::arg</classname>&lt; Expr &gt;::reference &gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name=""><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::post_inc</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::post_dec</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::subscript</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::comma</template-arg><template-arg>2</template-arg></specialization><typedef name="arg0_type"><type><classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 0 &gt;::type, Context &gt;::type</type></typedef><typedef name="arg1_type"><type><classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::type, Context &gt;::type</type></typedef><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>1</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type()&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>2</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::type, Context &gt;::type)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>3</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 2 &gt;::type, Context &gt;::type)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>4</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 2 &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 3 &gt;::type, Context &gt;::type)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>5</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 2 &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 3 &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 4 &gt;::type, Context &gt;::type)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization></namespace></namespace></header><header name="boost/xpressive/proto/debug.hpp"><para>Utilities for debugging proto expression trees </para><namespace name="boost"><namespace name="proto"><namespace name="functional"><struct name="display_expr"><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>expr&lt; <classname>tag::terminal</classname>, Args, 1 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>expr&lt; Tag, Args, 1 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>expr&lt; Tag, Args, 0 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></method></method-group><constructor><parameter name="depth"><paramtype>int</paramtype><default>0</default></parameter><parameter name="sout"><paramtype>std::ostream &amp;</paramtype><default>std::cout</default></parameter></constructor></struct></namespace><namespace name="tag"><function name="proto_tag_name"><type>char const *</type><template>
          <template-type-parameter name="Tag"/>
        </template><parameter name=""><paramtype>Tag</paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::posit</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::negate</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::dereference</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::complement</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::address_of</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::logical_not</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::pre_inc</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::pre_dec</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::post_inc</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::post_dec</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::shift_left</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::shift_right</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::multiplies</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::divides</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::modulus</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::plus</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::minus</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::less</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::greater</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::less_equal</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::greater_equal</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::equal_to</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::not_equal_to</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::logical_or</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::logical_and</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_and</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_or</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_xor</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::comma</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::mem_ptr</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::shift_left_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::shift_right_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::multilpies_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::divides_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::modulus_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::plus_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::minus_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_and_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_or_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_xor_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::subscript</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::function</classname></paramtype></parameter></function></namespace><function name="display_expr"><type>void</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></function><function name="display_expr"><type>void</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="sout"><paramtype>std::ostream &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/xpressive/proto/deep_copy.hpp"><para>Replace all nodes stored by reference by nodes stored by value. </para><namespace name="boost"><namespace name="proto"><namespace name="functional"><struct name="deep_copy"><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::deep_copy</classname>&lt; Expr &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct></namespace><namespace name="result_of"><struct name="deep_copy"><template>
      <template-type-parameter name="Expr"/>
    </template></struct></namespace><data-member name="deep_copy"><type><classname>functional::deep_copy</classname> const</type></data-member></namespace></namespace></header><header name="boost/xpressive/proto/domain.hpp"><para>Contains definition of domain&lt;&gt; class template, for defining domains with a grammar for controlling operator overloading. </para><namespace name="boost"><namespace name="proto"><struct name="domain"><template>
      <template-type-parameter name="Generator"/>
      <template-type-parameter name="Grammar"/>
    </template><inherit access="public">Generator</inherit><typedef name="grammar"><type>Grammar</type></typedef></struct><struct name="deduce_domain"><inherit access="public">boost::proto::domain&lt;  &gt;</inherit></struct><struct name="is_domain"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="EnableIf"/>
    </template></struct><struct name="domain_of"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="EnableIf"/>
    </template><typedef name="type"><type><classname>default_domain</classname></type></typedef></struct><struct-specialization name="is_domain"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>typename T::boost_proto_is_domain_</template-arg></specialization></struct-specialization><struct-specialization name="domain_of"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>typename T::is_boost_proto_expr_</template-arg></specialization><typedef name="type"><type>T::domain</type></typedef></struct-specialization></namespace></namespace></header><header name="boost/xpressive/proto/eval.hpp"><para>Contains the eval() expression evaluator. </para><namespace name="boost"><namespace name="proto"><namespace name="functional"><struct name="eval"><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>Context)</template-arg></specialization><inherit access="public">boost::proto::result_of::eval&lt; remove_reference&lt; Expr &gt;::type, remove_reference&lt; Context &gt;::type &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>proto::result_of::eval</classname>&lt; Expr, Context &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="Context"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>proto::result_of::eval</classname>&lt; Expr, Context &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="Context"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context const &amp;</paramtype></parameter></method></method-group></struct></namespace><namespace name="result_of"><struct name="eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><typedef name="type"><type>Context::template <classname>eval</classname>&lt; Expr &gt;::result_type</type></typedef></struct></namespace><data-member name="eval"><type><classname>functional::eval</classname> const</type></data-member></namespace></namespace></header><header name="boost/xpressive/proto/expr.hpp"><para>Contains definition of expr&lt;&gt; class template. </para><namespace name="boost"><namespace name="proto"><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>1</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr &gt;::type</type></typedef></struct><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arity"><type>mpl::long_&lt; 1 &gt;</type></typedef><typedef name="type"><type>expr</type></typedef><typedef name="args_type"><type>Args</type></typedef><typedef name="domain"><type><classname>default_domain</classname></type></typedef><typedef name="fusion_tag"><type>proto_expr_tag</type></typedef><typedef name="is_boost_proto_expr_"><type>void</type></typedef><typedef name="boost_proto_expr_type_"><type>expr</type></typedef><typedef name="arg0_type"><type>Args::arg0</type></typedef><typedef name="arg1_type"><type>void</type></typedef><typedef name="arg2_type"><type>void</type></typedef><typedef name="arg3_type"><type>void</type></typedef><typedef name="arg4_type"><type>void</type></typedef><typedef name="address_of_hack_type_"><description><para>If <computeroutput>Tag</computeroutput> is <computeroutput>boost::proto::tag::address_of</computeroutput> and <computeroutput>arg0_type</computeroutput> is <computeroutput>proto::ref_&lt;T&gt;</computeroutput>, then <computeroutput>address_of_hack_type_</computeroutput> is <computeroutput>T*</computeroutput>. Otherwise, it is some undefined type. </para></description><type><emphasis>unspecified</emphasis></type></typedef><data-member name="arg0"><type>arg0_type</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group><method-group name="public member functions"><method name="cast" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="cast" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="conversion-operator" cv="const"><type>address_of_hack_type_</type><description><para>

</para></description><returns><para>The address of <computeroutput>this-&gt;arg0</computeroutput> if <computeroutput>Tag</computeroutput> is <computeroutput>boost::proto::tag::address_of</computeroutput>. Otherwise, this function will fail to compile.</para></returns><notes><para>Proto overloads <computeroutput>operator&amp;</computeroutput>, which means that proto-ified objects cannot have their addresses taken, unless we use the following hack to make <computeroutput>&amp;x</computeroutput> implicitly convertible to <computeroutput>X*</computeroutput>. </para></notes></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>2</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr &gt;::type</type></typedef></struct><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arity"><type>mpl::long_&lt; 2 &gt;</type></typedef><typedef name="type"><type>expr</type></typedef><typedef name="args_type"><type>Args</type></typedef><typedef name="domain"><type><classname>default_domain</classname></type></typedef><typedef name="fusion_tag"><type>proto_expr_tag</type></typedef><typedef name="is_boost_proto_expr_"><type>void</type></typedef><typedef name="boost_proto_expr_type_"><type>expr</type></typedef><typedef name="arg0_type"><type>Args::arg0</type></typedef><typedef name="arg1_type"><type>Args::arg1</type></typedef><typedef name="arg2_type"><type>void</type></typedef><typedef name="arg3_type"><type>void</type></typedef><typedef name="arg4_type"><type>void</type></typedef><data-member name="arg0"><type>arg0_type</type></data-member><data-member name="arg1"><type>arg1_type</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group><method-group name="public member functions"><method name="cast" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="cast" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>3</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr &gt;::type</type></typedef></struct><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arity"><type>mpl::long_&lt; 3 &gt;</type></typedef><typedef name="type"><type>expr</type></typedef><typedef name="args_type"><type>Args</type></typedef><typedef name="domain"><type><classname>default_domain</classname></type></typedef><typedef name="fusion_tag"><type>proto_expr_tag</type></typedef><typedef name="is_boost_proto_expr_"><type>void</type></typedef><typedef name="boost_proto_expr_type_"><type>expr</type></typedef><typedef name="arg0_type"><type>Args::arg0</type></typedef><typedef name="arg1_type"><type>Args::arg1</type></typedef><typedef name="arg2_type"><type>Args::arg2</type></typedef><typedef name="arg3_type"><type>void</type></typedef><typedef name="arg4_type"><type>void</type></typedef><data-member name="arg0"><type>arg0_type</type></data-member><data-member name="arg1"><type>arg1_type</type></data-member><data-member name="arg2"><type>arg2_type</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group><method-group name="public member functions"><method name="cast" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="cast" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>4</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr &gt;::type</type></typedef></struct><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arity"><type>mpl::long_&lt; 4 &gt;</type></typedef><typedef name="type"><type>expr</type></typedef><typedef name="args_type"><type>Args</type></typedef><typedef name="domain"><type><classname>default_domain</classname></type></typedef><typedef name="fusion_tag"><type>proto_expr_tag</type></typedef><typedef name="is_boost_proto_expr_"><type>void</type></typedef><typedef name="boost_proto_expr_type_"><type>expr</type></typedef><typedef name="arg0_type"><type>Args::arg0</type></typedef><typedef name="arg1_type"><type>Args::arg1</type></typedef><typedef name="arg2_type"><type>Args::arg2</type></typedef><typedef name="arg3_type"><type>Args::arg3</type></typedef><typedef name="arg4_type"><type>void</type></typedef><data-member name="arg0"><type>arg0_type</type></data-member><data-member name="arg1"><type>arg1_type</type></data-member><data-member name="arg2"><type>arg2_type</type></data-member><data-member name="arg3"><type>arg3_type</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group><method-group name="public member functions"><method name="cast" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="cast" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>5</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr &gt;::type</type></typedef></struct><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arity"><type>mpl::long_&lt; 5 &gt;</type></typedef><typedef name="type"><type>expr</type></typedef><typedef name="args_type"><type>Args</type></typedef><typedef name="domain"><type><classname>default_domain</classname></type></typedef><typedef name="fusion_tag"><type>proto_expr_tag</type></typedef><typedef name="is_boost_proto_expr_"><type>void</type></typedef><typedef name="boost_proto_expr_type_"><type>expr</type></typedef><typedef name="arg0_type"><type>Args::arg0</type></typedef><typedef name="arg1_type"><type>Args::arg1</type></typedef><typedef name="arg2_type"><type>Args::arg2</type></typedef><typedef name="arg3_type"><type>Args::arg3</type></typedef><typedef name="arg4_type"><type>Args::arg4</type></typedef><data-member name="arg0"><type>arg0_type</type></data-member><data-member name="arg1"><type>arg1_type</type></data-member><data-member name="arg2"><type>arg2_type</type></data-member><data-member name="arg3"><type>arg3_type</type></data-member><data-member name="arg4"><type>arg4_type</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
          <template-type-parameter name="A4"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><parameter name="a4"><paramtype>A4 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group><method-group name="public member functions"><method name="cast" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="cast" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>proto::tag::terminal</template-arg><template-arg>Args</template-arg><template-arg>1</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr &gt;::type</type></typedef></struct><typedef name="tag_type"><type><classname>proto::tag::terminal</classname></type></typedef><typedef name="arity"><type>mpl::long_&lt; 1 &gt;</type></typedef><typedef name="type"><type>expr</type></typedef><typedef name="args_type"><type>Args</type></typedef><typedef name="domain"><type><classname>default_domain</classname></type></typedef><typedef name="fusion_tag"><type>proto_expr_tag</type></typedef><typedef name="is_boost_proto_expr_"><type>void</type></typedef><typedef name="boost_proto_expr_type_"><type>expr</type></typedef><typedef name="arg0_type"><type>Args::arg0</type></typedef><typedef name="arg1_type"><type>void</type></typedef><typedef name="arg2_type"><type>void</type></typedef><typedef name="arg3_type"><type>void</type></typedef><typedef name="arg4_type"><type>void</type></typedef><data-member name="arg0"><type>arg0_type</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><method-group name="public member functions"><method name="cast" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="cast" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv=""><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv=""><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A const &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv=""><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref_</classname>&lt; expr &gt; &gt; &gt; const</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv=""><type><classname>result_of::funop1</classname>&lt; expr, const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv=""><type><classname>result_of::funop2</classname>&lt; expr, const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv=""><type><classname>result_of::funop3</classname>&lt; expr, const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv=""><type><classname>result_of::funop4</classname>&lt; expr, const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment></struct-specialization><namespace name="result_of"><struct name="funop0"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref_</classname>&lt; Expr &gt;&gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr()</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop0&lt; This &gt;</inherit></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr const()</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop0&lt; This const  &gt;</inherit></struct-specialization><struct name="funop1"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
    </template><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; Expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A0 &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr(A0)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop1&lt; This, remove_reference&lt; A0 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr const(A0)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop1&lt; This const , remove_reference&lt; A0 &gt;::type &gt;</inherit></struct-specialization><struct name="funop2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args3</classname>&lt; <classname>ref_</classname>&lt; Expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A0 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A1 &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr(A0</template-arg><template-arg>A1)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop2&lt; This, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr const(A0</template-arg><template-arg>A1)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop2&lt; This const , remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type &gt;</inherit></struct-specialization><struct name="funop3"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args4</classname>&lt; <classname>ref_</classname>&lt; Expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A0 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A1 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A2 &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop3&lt; This, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr const(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop3&lt; This const , remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type &gt;</inherit></struct-specialization><struct name="funop4"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args5</classname>&lt; <classname>ref_</classname>&lt; Expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A0 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A1 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A2 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A3 &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop4&lt; This, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type, remove_reference&lt; A3 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr const(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop4&lt; This const , remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type, remove_reference&lt; A3 &gt;::type &gt;</inherit></struct-specialization></namespace></namespace></namespace></header><header name="boost/xpressive/proto/extends.hpp"><para>Macros and a base class for defining end-user expression types </para><namespace name="boost"><namespace name="proto"><struct name="is_proto_expr"><purpose>Empty type to be used as a dummy template parameter of POD expression wrappers. It allows argument-dependent lookup to find Proto's operator overloads. </purpose><description><para><computeroutput>proto::is_proto_expr</computeroutput> allows argument-dependent lookup to find Proto's operator overloads. For example:</para><para><programlisting> template&lt;typename T, typename Dummy = proto::is_proto_expr&gt;
 struct my_terminal
 {
     BOOST_PROTO_EXTENDS(
         typename proto::terminal&lt;T&gt;::type
       , my_terminal&lt;T&gt;
       , default_domain
     )
 };

 // ...
 my_terminal&lt;int&gt; _1, _2;
 _1 + _2; // OK, uses proto::operator+
</programlisting></para><para>Without the second <computeroutput>Dummy</computeroutput> template parameter, Proto's operator overloads would not be considered by name lookup. </para></description></struct><struct name="extends"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Derived"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="Tag"/>
    </template><purpose>extends&lt;&gt; class template for adding behaviors to a proto expression template </purpose><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><typedef name="type"><type>boost::mpl::apply_wrap1&lt; Domain, typename boost::proto::result_of::funop&lt; Sig, Derived &gt;::type &gt;::type</type></typedef></struct><data-member name="expr"><type>Expr</type></data-member><typedef name="type"><type>Expr</type></typedef><typedef name="domain"><type>Domain</type></typedef><typedef name="boost_proto_expr_type_"><type>Derived</type></typedef><typedef name="tag_type"><type>Expr::tag_type</type></typedef><typedef name="args_type"><type>Expr::args_type</type></typedef><typedef name="arity"><type>Expr::arity</type></typedef><typedef name="is_boost_proto_expr_"><type>void</type></typedef><typedef name="fusion_tag"><type>boost::proto::proto_expr_tag</type></typedef><typedef name="arg0_type"><type>Expr::arg0_type</type></typedef><typedef name="arg1_type"><type>Expr::arg1_type</type></typedef><typedef name="arg2_type"><type>Expr::arg2_type</type></typedef><typedef name="arg3_type"><type>Expr::arg3_type</type></typedef><typedef name="arg4_type"><type>Expr::arg4_type</type></typedef><method-group name="public member functions"><method name="cast" cv=""><type>Expr &amp;</type></method><method name="cast" cv="const"><type>Expr const &amp;</type></method><method name="operator[]" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; <classname>boost::proto::ref_</classname>&lt; Derived const  &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; <classname>boost::proto::ref_</classname>&lt; Derived const  &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop0</classname>&lt; Derived const  &gt;::type &gt;::type const</type></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop1</classname>&lt; Derived const , const A0 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop2</classname>&lt; Derived const , const A0, const A1 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop3</classname>&lt; Derived const , const A0, const A1, const A2 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop4</classname>&lt; Derived const , const A0, const A1, const A2, const A3 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter></method></method-group><constructor/><constructor><parameter name="that"><paramtype><classname>extends</classname> const &amp;</paramtype></parameter></constructor><constructor><parameter name="expr_"><paramtype>Expr const &amp;</paramtype></parameter></constructor><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static Derived const</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="extends"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Derived"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Derived</template-arg><template-arg>Domain</template-arg><template-arg>tag::terminal</template-arg></specialization><purpose>extends&lt;&gt; class template for adding behaviors to a proto expression template </purpose><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><typedef name="type"><type>boost::mpl::apply_wrap1&lt; Domain, typename boost::proto::result_of::funop&lt; Sig, Derived &gt;::type &gt;::type</type></typedef></struct><data-member name="expr"><type>Expr</type></data-member><typedef name="type"><type>Expr</type></typedef><typedef name="domain"><type>Domain</type></typedef><typedef name="boost_proto_expr_type_"><type>Derived</type></typedef><typedef name="tag_type"><type>Expr::tag_type</type></typedef><typedef name="args_type"><type>Expr::args_type</type></typedef><typedef name="arity"><type>Expr::arity</type></typedef><typedef name="is_boost_proto_expr_"><type>void</type></typedef><typedef name="fusion_tag"><type>boost::proto::proto_expr_tag</type></typedef><typedef name="arg0_type"><type>Expr::arg0_type</type></typedef><typedef name="arg1_type"><type>Expr::arg1_type</type></typedef><typedef name="arg2_type"><type>Expr::arg2_type</type></typedef><typedef name="arg3_type"><type>Expr::arg3_type</type></typedef><typedef name="arg4_type"><type>Expr::arg4_type</type></typedef><method-group name="public member functions"><method name="extends" cv=""><type/></method><method name="extends" cv=""><type/><parameter name="that"><paramtype><classname>extends</classname> const &amp;</paramtype></parameter></method><method name="extends" cv=""><type/><parameter name="expr_"><paramtype>Expr const &amp;</paramtype></parameter></method><method name="cast" cv=""><type>Expr &amp;</type></method><method name="cast" cv="const"><type>Expr const &amp;</type></method><method name="operator[]" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; <classname>boost::proto::ref_</classname>&lt; Derived const  &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; <classname>boost::proto::ref_</classname>&lt; Derived const  &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator[]" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; <classname>boost::proto::ref_</classname>&lt; Derived &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; <classname>boost::proto::ref_</classname>&lt; Derived &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop0</classname>&lt; Derived const  &gt;::type &gt;::type const</type></method><method name="operator()" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop0</classname>&lt; Derived &gt;::type &gt;::type const</type></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop1</classname>&lt; Derived const , const A0 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></method><method name="operator()" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop1</classname>&lt; Derived, const A0 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop2</classname>&lt; Derived const , const A0, const A1 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></method><method name="operator()" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop2</classname>&lt; Derived, const A0, const A1 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop3</classname>&lt; Derived const , const A0, const A1, const A2 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></method><method name="operator()" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop3</classname>&lt; Derived, const A0, const A1, const A2 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop4</classname>&lt; Derived const , const A0, const A1, const A2, const A3 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter></method><method name="operator()" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop4</classname>&lt; Derived, const A0, const A1, const A2, const A3 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static Derived const</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization></namespace></namespace></header><header name="boost/xpressive/proto/fusion.hpp"><para>Make any Proto parse tree a valid Fusion sequence </para><namespace name="boost"><namespace name="fusion"><namespace name="extension"><struct name="as_element"><template>
      <template-type-parameter name="Tag"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Expr"/>
    </template></struct><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result</classname>&lt; Expr &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="is_view_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Iterator"/>
    </template></struct></struct-specialization><struct-specialization name="is_view_impl"><template>
    </template><specialization><template-arg>proto::proto_expr_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Iterator"/>
    </template></struct></struct-specialization><struct-specialization name="value_of_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_iterator_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Iterator"/>
    </template><inherit access="public">boost::proto::result_of::arg&lt; Iterator::expr_type, Iterator::index &gt;</inherit></struct></struct-specialization><struct-specialization name="deref_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_iterator_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Iterator"/>
    </template><typedef name="type"><type><classname>proto::result_of::arg</classname>&lt; typename Iterator::expr_type, typename Iterator::index &gt;::type const &amp;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type</type><parameter name="iter"><paramtype>Iterator const &amp;</paramtype></parameter></method></method-group></struct></struct-specialization><struct-specialization name="advance_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_iterator_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Iterator"/>
      <template-type-parameter name="N"/>
    </template><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>type</classname></type><parameter name="iter"><paramtype>Iterator const &amp;</paramtype></parameter></method></method-group></struct></struct-specialization><struct-specialization name="distance_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_iterator_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="IteratorFrom"/>
      <template-type-parameter name="IteratorTo"/>
    </template></struct></struct-specialization><struct-specialization name="next_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_iterator_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Iterator"/>
    </template></struct></struct-specialization><struct-specialization name="prior_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_iterator_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Iterator"/>
    </template></struct></struct-specialization><struct-specialization name="category_of_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
    </template><typedef name="type"><type>random_access_traversal_tag</type></typedef></struct></struct-specialization><struct-specialization name="size_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
    </template></struct></struct-specialization><struct-specialization name="begin_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
    </template><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>type</classname></type><parameter name="seq"><paramtype>Sequence &amp;</paramtype></parameter></method></method-group></struct></struct-specialization><struct-specialization name="end_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
    </template><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>type</classname></type><parameter name="seq"><paramtype>Sequence &amp;</paramtype></parameter></method></method-group></struct></struct-specialization><struct-specialization name="value_at_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
      <template-type-parameter name="N"/>
    </template><typedef name="type"><type><classname>proto::result_of::arg</classname>&lt; Sequence, N &gt;::type</type></typedef></struct></struct-specialization><struct-specialization name="at_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
      <template-type-parameter name="N"/>
    </template><typedef name="type"><type><classname>proto::result_of::arg</classname>&lt; Sequence, N &gt;::type const &amp;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type</type><parameter name="seq"><paramtype>Sequence &amp;</paramtype></parameter></method></method-group></struct></struct-specialization><struct-specialization name="is_segmented_impl"><template>
    </template><specialization><template-arg>proto::proto_expr_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Iterator"/>
    </template></struct></struct-specialization><struct-specialization name="segments_impl"><template>
    </template><specialization><template-arg>proto::proto_expr_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
    </template><typedef name="tag_type"><type>Sequence::tag_type</type></typedef><typedef name="type"><type>fusion::transform_view&lt; <classname>proto::ref_</classname>&lt; Sequence &gt;, <classname>as_element</classname>&lt; tag_type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type</type><parameter name="sequence"><paramtype>Sequence &amp;</paramtype></parameter></method></method-group></struct></struct-specialization><struct-specialization name="category_of_impl"><template>
    </template><specialization><template-arg>proto::proto_expr_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
    </template><typedef name="type"><type>forward_traversal_tag</type></typedef></struct></struct-specialization><struct-specialization name="begin_impl"><template>
    </template><specialization><template-arg>proto::proto_expr_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
    </template></struct></struct-specialization><struct-specialization name="end_impl"><template>
    </template><specialization><template-arg>proto::proto_expr_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
    </template></struct></struct-specialization><struct-specialization name="size_impl"><template>
    </template><specialization><template-arg>proto::proto_expr_tag</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
    </template></struct></struct-specialization></namespace></namespace><namespace name="proto"><struct name="children"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::ref_&lt; Expr &gt;</inherit><method-group name="public member functions"/><constructor><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></constructor></struct><struct name="eval_fun"><template>
      <template-type-parameter name="Context"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>Context::template eval&lt; typename remove_reference&lt; Expr &gt;::type &gt;::result_type</type></typedef></struct><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result</classname>&lt; Expr &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method></method-group><constructor><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></constructor></struct><function name="children_of"><type><classname>children</classname>&lt; Expr &gt;</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/xpressive/proto/generate.hpp"><para>Contains definition of generate&lt;&gt; class template, which end users can specialize for generating domain-specific expression wrappers. </para><namespace name="boost"><namespace name="proto"><struct name="default_generator"><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>Expr</type></typedef></struct><method-group name="public static functions"><method name="make" cv=""><type>static Expr const &amp;</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="generator"><template>
      <template-nontype-parameter name="Extends"><type>template&lt; typename &gt; class</type></template-nontype-parameter>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>Extends&lt; Expr &gt;</type></typedef></struct><method-group name="public static functions"><method name="make" cv=""><type>static Extends&lt; Expr &gt;</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="pod_generator"><template>
      <template-nontype-parameter name="Extends"><type>template&lt; typename &gt; class</type></template-nontype-parameter>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>Extends&lt; Expr &gt;</type></typedef></struct><method-group name="public static functions"><method name="make" cv=""><type>static Extends&lt; Expr &gt;</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></header><header name="boost/xpressive/proto/literal.hpp"><para>The literal&lt;&gt; terminal wrapper, and the proto::lit() function for creating literal&lt;&gt; wrappers. </para><namespace name="boost"><namespace name="proto"><struct name="literal"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"/>
    </template><inherit access="public">boost::proto::extends&lt; terminal&lt; T &gt;::type, literal&lt; T, Domain &gt;, Domain &gt;</inherit><typedef name="terminal_type"><type><classname>terminal</classname>&lt; T &gt;::type</type></typedef><typedef name="base_type"><type><classname>extends</classname>&lt; terminal_type, <classname>literal</classname>&lt; T, Domain &gt;, Domain &gt;</type></typedef><method-group name="public member functions"/><constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype>U &amp;</paramtype></parameter></constructor><constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype>U const &amp;</paramtype></parameter></constructor><constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype><classname>literal</classname>&lt; U, Domain &gt; const &amp;</paramtype></parameter></constructor></struct><overloaded-function name="lit"><signature><type><classname>literal</classname>&lt; T &amp; &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></signature><signature><type><classname>literal</classname>&lt; T const &amp; &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></signature><description><para>lit </para></description></overloaded-function></namespace></namespace></header><header name="boost/xpressive/proto/make_expr.hpp"><para>Given a Fusion sequence of arguments and the type of a proto Expression, unpacks the sequence into the Expression. </para><namespace name="boost"><namespace name="fusion"/><namespace name="proto"><namespace name="functional"><struct name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>This(A0)</template-arg></specialization><inherit access="public">boost::proto::result_of::make_expr&lt; Tag, Domain, remove_reference&lt; A0 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1)</template-arg></specialization><inherit access="public">boost::proto::result_of::make_expr&lt; Tag, Domain, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg></specialization><inherit access="public">boost::proto::result_of::make_expr&lt; Tag, Domain, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg></specialization><inherit access="public">boost::proto::result_of::make_expr&lt; Tag, Domain, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type, remove_reference&lt; A3 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4)</template-arg></specialization><inherit access="public">boost::proto::result_of::make_expr&lt; Tag, Domain, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type, remove_reference&lt; A3 &gt;::type, remove_reference&lt; A4 &gt;::type &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, A &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>const A3 &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const A0, const A1, const A2, const A3, const A4 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
          <template-type-parameter name="A4"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>const A3 &amp;</paramtype></parameter><parameter name="a4"><paramtype>const A4 &amp;</paramtype></parameter></method></method-group></struct><struct name="unpack_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>This(Sequence)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::unpack_expr</classname>&lt; Tag, Domain, Sequence &gt;::type</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="sequence"><paramtype>Sequence const &amp;</paramtype></parameter></method></method-group></struct><struct name="unfused_expr_fun"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Sequence"/>
    </template><inherit access="public">boost::proto::result_of::unpack_expr&lt; Tag, Domain, Sequence &gt;</inherit></struct><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>proto::result_of::unpack_expr</classname>&lt; Tag, Domain, Sequence &gt;::type</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="sequence"><paramtype>Sequence const &amp;</paramtype></parameter></method></method-group></struct><struct name="unfused_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"/>
    </template></struct><struct-specialization name="make_expr"><template>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>tag::terminal</template-arg><template-arg>Domain</template-arg></specialization><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A"/>
    </template><specialization><template-arg>This(A)</template-arg></specialization><inherit access="public">boost::proto::result_of::make_expr&lt; tag::terminal, Domain, A &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; <classname>tag::terminal</classname>, Domain, A &gt;::type</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; <classname>tag::terminal</classname>, Domain, A const  &gt;::type</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method></method-group></struct-specialization></namespace><namespace name="result_of"><struct name="unpack_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Sequence"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template></struct><struct name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template></struct><struct-specialization name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>deduce_domain</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4</template-arg><template-arg>void</template-arg></specialization></struct-specialization><struct-specialization name="unpack_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Domain</template-arg><template-arg>Sequence</template-arg><template-arg>typename Domain::boost_proto_is_domain_</template-arg></specialization></struct-specialization><struct-specialization name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Domain</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4</template-arg><template-arg>typename Domain::boost_proto_is_domain_</template-arg></specialization></struct-specialization></namespace><overloaded-function name="unpack_expr"><signature><type>lazy_disable_if&lt; <classname>is_domain</classname>&lt; Sequence &gt;, <classname>result_of::unpack_expr</classname>&lt; Tag, Sequence &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="sequence"><paramtype>Sequence const &amp;</paramtype></parameter></signature><signature><type><classname>result_of::unpack_expr</classname>&lt; Tag, Domain, Sequence2 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="Sequence2"/>
        </template><parameter name="sequence2"><paramtype>Sequence2 const &amp;</paramtype></parameter></signature><description><para>unpack_expr </para></description></overloaded-function><overloaded-function name="make_expr"><signature><type>lazy_disable_if&lt; <classname>is_domain</classname>&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, A0 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, B0 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
        </template><parameter name="b0"><paramtype>B0 &amp;</paramtype></parameter></signature><signature><type>lazy_disable_if&lt; <classname>is_domain</classname>&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, const A0 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const B0 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
        </template><parameter name="b0"><paramtype>const B0 &amp;</paramtype></parameter></signature><signature><type>lazy_disable_if&lt; <classname>is_domain</classname>&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, const A0, const A1 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const B0, const B1 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
          <template-type-parameter name="B1"/>
        </template><parameter name="b0"><paramtype>const B0 &amp;</paramtype></parameter><parameter name="b1"><paramtype>const B1 &amp;</paramtype></parameter></signature><signature><type>lazy_disable_if&lt; <classname>is_domain</classname>&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, const A0, const A1, const A2 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const B0, const B1, const B2 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
          <template-type-parameter name="B1"/>
          <template-type-parameter name="B2"/>
        </template><parameter name="b0"><paramtype>const B0 &amp;</paramtype></parameter><parameter name="b1"><paramtype>const B1 &amp;</paramtype></parameter><parameter name="b2"><paramtype>const B2 &amp;</paramtype></parameter></signature><signature><type>lazy_disable_if&lt; <classname>is_domain</classname>&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, const A0, const A1, const A2, const A3 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>const A3 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const B0, const B1, const B2, const B3 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
          <template-type-parameter name="B1"/>
          <template-type-parameter name="B2"/>
          <template-type-parameter name="B3"/>
        </template><parameter name="b0"><paramtype>const B0 &amp;</paramtype></parameter><parameter name="b1"><paramtype>const B1 &amp;</paramtype></parameter><parameter name="b2"><paramtype>const B2 &amp;</paramtype></parameter><parameter name="b3"><paramtype>const B3 &amp;</paramtype></parameter></signature><signature><type>lazy_disable_if&lt; <classname>is_domain</classname>&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, const A0, const A1, const A2, const A3, const A4 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
          <template-type-parameter name="A4"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>const A3 &amp;</paramtype></parameter><parameter name="a4"><paramtype>const A4 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const B0, const B1, const B2, const B3, const B4 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
          <template-type-parameter name="B1"/>
          <template-type-parameter name="B2"/>
          <template-type-parameter name="B3"/>
          <template-type-parameter name="B4"/>
        </template><parameter name="b0"><paramtype>const B0 &amp;</paramtype></parameter><parameter name="b1"><paramtype>const B1 &amp;</paramtype></parameter><parameter name="b2"><paramtype>const B2 &amp;</paramtype></parameter><parameter name="b3"><paramtype>const B3 &amp;</paramtype></parameter><parameter name="b4"><paramtype>const B4 &amp;</paramtype></parameter></signature><description><para>make_expr </para></description></overloaded-function></namespace></namespace></header><header name="boost/xpressive/proto/matches.hpp"><para>Contains definition of matches&lt;&gt; metafunction for determining if a given expression matches a given pattern. </para><namespace name="boost"><namespace name="proto"><struct name="matches"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Grammar"/>
    </template></struct><struct name="or_"><template>
      <template-type-parameter name="G0"/>
      <template-type-parameter name="G1"/>
      <template-type-parameter name="G2"/>
      <template-type-parameter name="G3"/>
      <template-type-parameter name="G4"/>
      <template-type-parameter name="G5"/>
      <template-type-parameter name="G6"/>
      <template-type-parameter name="G7"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><typedef name="which"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="type"><type>which::template <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type></typedef></struct><typedef name="type"><type><classname>or_</classname></type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="and_"><template>
      <template-type-parameter name="G0"/>
      <template-type-parameter name="G1"/>
      <template-type-parameter name="G2"/>
      <template-type-parameter name="G3"/>
      <template-type-parameter name="G4"/>
      <template-type-parameter name="G5"/>
      <template-type-parameter name="G6"/>
      <template-type-parameter name="G7"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><typedef name="which"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="type"><type>which::template <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type></typedef></struct><typedef name="type"><type><classname>and_</classname></type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="switch_"><template>
      <template-type-parameter name="Cases"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><typedef name="type"><type><classname>switch_</classname></type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="_"><inherit access="public">boost::proto::has_identity_transform</inherit><typedef name="type"><type><classname>_</classname></type></typedef></struct><struct name="if_"><template>
      <template-type-parameter name="Pred"/>
    </template><inherit access="public">boost::proto::has_identity_transform</inherit><typedef name="type"><type><classname>if_</classname></type></typedef></struct><struct name="not_"><template>
      <template-type-parameter name="Pred"/>
    </template><inherit access="public">boost::proto::has_identity_transform</inherit><typedef name="type"><type><classname>not_</classname></type></typedef></struct><struct name="vararg"><template>
      <template-type-parameter name="Grammar"/>
    </template><typedef name="boost_proto_is_vararg_"><type>void</type></typedef></struct><struct name="if_matches"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Return"/>
    </template></struct><struct name="if_not_matches"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Return"/>
    </template></struct><struct name="exact"><template>
      <template-type-parameter name="T"/>
    </template></struct></namespace></namespace></header><header name="boost/xpressive/proto/operators.hpp"><para>Contains all the overloaded operators that make it possible to build expression templates using proto components </para><namespace name="boost"><namespace name="proto"><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator~"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator~"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator!"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator!"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function></namespace></namespace></header><header name="boost/xpressive/proto/proto.hpp"><para>The proto expression template compiler and supporting utilities. </para></header><header name="boost/xpressive/proto/proto_fwd.hpp"><para>Forward declarations of all of proto's public types and functions. </para><namespace name="boost"><namespace name="proto"><struct name="has_identity_transform"><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method></method-group></struct><namespace name="functional"/><namespace name="result_of"/><namespace name="tag"/><namespace name="transform"/><data-member name="N"><type>int const</type></data-member><typedef name="default_domain"><type><classname>domain</classname>&lt;  &gt;</type></typedef></namespace></namespace></header><header name="boost/xpressive/proto/ref.hpp"><para>Utility for storing a sub-expr by reference </para><namespace name="boost"><namespace name="proto"><struct name="ref_"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>Expr::type</type></typedef><typedef name="tag_type"><type>Expr::tag_type</type></typedef><typedef name="args_type"><type>Expr::args_type</type></typedef><typedef name="arity"><type>Expr::arity</type></typedef><typedef name="domain"><type>Expr::domain</type></typedef><typedef name="fusion_tag"><type>proto_ref_tag</type></typedef><typedef name="is_boost_proto_ref_"><type>void</type></typedef><typedef name="is_boost_proto_expr_"><type>void</type></typedef><typedef name="boost_proto_expr_type_"><type>Expr</type></typedef><typedef name="arg0_type"><type>Expr::arg0_type</type></typedef><typedef name="arg1_type"><type>Expr::arg1_type</type></typedef><typedef name="arg2_type"><type>Expr::arg2_type</type></typedef><typedef name="arg3_type"><type>Expr::arg3_type</type></typedef><typedef name="arg4_type"><type>Expr::arg4_type</type></typedef><data-member name="expr"><type>Expr &amp;</type></data-member><method-group name="public member functions"><method name="cast" cv="const"><type>mpl::if_&lt; is_const&lt; Expr &gt;, type const &amp;, type &amp; &gt;::type</type></method></method-group><method-group name="public static functions"><method name="make" cv=""><type>static <classname>ref_</classname>&lt; Expr &gt;</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="ref_"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>ref_&lt; Expr &gt;</template-arg></specialization></struct-specialization><namespace name="functional"><struct name="unref"><struct name="result"><template>
      <template-type-parameter name="T"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>T &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>T const &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>T &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype><classname>ref_</classname>&lt; T &gt; &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>T &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype><classname>ref_</classname>&lt; T &gt; const &amp;</paramtype></parameter></method></method-group></struct></namespace><namespace name="result_of"><struct name="unref"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="type"><type>T</type></typedef><typedef name="reference"><type>T &amp;</type></typedef><typedef name="const_reference"><type>T const &amp;</type></typedef></struct><struct-specialization name="unref"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>ref_&lt; T &gt;</template-arg></specialization><typedef name="type"><type>T::boost_proto_expr_type_</type></typedef><typedef name="reference"><type>T &amp;</type></typedef><typedef name="const_reference"><type>T &amp;</type></typedef></struct-specialization><struct-specialization name="unref"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T &amp;</template-arg></specialization><typedef name="type"><type>T</type></typedef><typedef name="reference"><type>T &amp;</type></typedef><typedef name="const_reference"><type>T &amp;</type></typedef></struct-specialization><struct-specialization name="unref"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T const &amp;</template-arg></specialization><typedef name="type"><type>T</type></typedef><typedef name="reference"><type>T const &amp;</type></typedef><typedef name="const_reference"><type>T const &amp;</type></typedef></struct-specialization></namespace><data-member name="unref"><type><classname>functional::unref</classname> const</type></data-member></namespace></namespace></header><header name="boost/xpressive/proto/tags.hpp"><para>Contains the tags for all the overloadable operators in C++ </para><namespace name="boost"><namespace name="proto"><namespace name="tag"><struct name="terminal"><purpose>Tag type for terminals; aka, leaves in the expression tree. </purpose></struct><struct name="posit"><purpose>Tag type for the unary + operator. </purpose></struct><struct name="negate"><purpose>Tag type for the unary - operator. </purpose></struct><struct name="dereference"><purpose>Tag type for the unary * operator. </purpose></struct><struct name="complement"><purpose>Tag type for the unary ~ operator. </purpose></struct><struct name="address_of"><purpose>Tag type for the unary &amp; operator. </purpose></struct><struct name="logical_not"><purpose>Tag type for the unary ! operator. </purpose></struct><struct name="pre_inc"><purpose>Tag type for the unary prefix ++ operator. </purpose></struct><struct name="pre_dec"><purpose>Tag type for the unary prefix -- operator. </purpose></struct><struct name="post_inc"><purpose>Tag type for the unary postfix ++ operator. </purpose></struct><struct name="post_dec"><purpose>Tag type for the unary postfix -- operator. </purpose></struct><struct name="shift_left"><purpose>Tag type for the binary &lt;&lt; operator. </purpose></struct><struct name="shift_right"><purpose>Tag type for the binary &gt;&gt; operator. </purpose></struct><struct name="multiplies"><purpose>Tag type for the binary * operator. </purpose></struct><struct name="divides"><purpose>Tag type for the binary / operator. </purpose></struct><struct name="modulus"><purpose>Tag type for the binary % operator. </purpose></struct><struct name="plus"><purpose>Tag type for the binary + operator. </purpose></struct><struct name="minus"><purpose>Tag type for the binary - operator. </purpose></struct><struct name="less"><purpose>Tag type for the binary &lt; operator. </purpose></struct><struct name="greater"><purpose>Tag type for the binary &gt; operator. </purpose></struct><struct name="less_equal"><purpose>Tag type for the binary &lt;= operator. </purpose></struct><struct name="greater_equal"><purpose>Tag type for the binary &gt;= operator. </purpose></struct><struct name="equal_to"><purpose>Tag type for the binary == operator. </purpose></struct><struct name="not_equal_to"><purpose>Tag type for the binary != operator. </purpose></struct><struct name="logical_or"><purpose>Tag type for the binary || operator. </purpose></struct><struct name="logical_and"><purpose>Tag type for the binary &amp;&amp; operator. </purpose></struct><struct name="bitwise_and"><purpose>Tag type for the binary &amp; operator. </purpose></struct><struct name="bitwise_or"><purpose>Tag type for the binary | operator. </purpose></struct><struct name="bitwise_xor"><purpose>Tag type for the binary ^ operator. </purpose></struct><struct name="comma"><purpose>Tag type for the binary , operator. </purpose></struct><struct name="mem_ptr"><purpose>Tag type for the binary -&gt;* operator. </purpose></struct><struct name="assign"><purpose>Tag type for the binary = operator. </purpose></struct><struct name="shift_left_assign"><purpose>Tag type for the binary &lt;&lt;= operator. </purpose></struct><struct name="shift_right_assign"><purpose>Tag type for the binary &gt;&gt;= operator. </purpose></struct><struct name="multilpies_assign"><purpose>Tag type for the binary *= operator. </purpose></struct><struct name="divides_assign"><purpose>Tag type for the binary /= operator. </purpose></struct><struct name="modulus_assign"><purpose>Tag type for the binary = operator. </purpose></struct><struct name="plus_assign"><purpose>Tag type for the binary += operator. </purpose></struct><struct name="minus_assign"><purpose>Tag type for the binary -= operator. </purpose></struct><struct name="bitwise_and_assign"><purpose>Tag type for the binary &amp;= operator. </purpose></struct><struct name="bitwise_or_assign"><purpose>Tag type for the binary |= operator. </purpose></struct><struct name="bitwise_xor_assign"><purpose>Tag type for the binary ^= operator. </purpose></struct><struct name="subscript"><purpose>Tag type for the binary subscript operator. </purpose></struct><struct name="function"><purpose>Tag type for the nary function call operator. </purpose></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/traits.hpp"><para>Contains definitions for arg&lt;&gt;, arg_c&lt;&gt;, left&lt;&gt;, right&lt;&gt;, tag&lt;&gt;, and the helper functions arg(), arg_c(), left() and right(). </para><namespace name="boost"><namespace name="proto"><struct name="is_ref"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="EnableIf"/>
    </template></struct><struct name="is_expr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="EnableIf"/>
    </template></struct><struct name="terminal"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_identity_transform</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::terminal</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::terminal</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="unary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; unary_expr&lt; Tag, T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="binary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; binary_expr&lt; Tag, T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="posit"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; posit&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::posit</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::posit</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="negate"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; negate&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::negate</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::negate</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="dereference"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; dereference&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::dereference</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::dereference</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="complement"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; complement&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::complement</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::complement</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="address_of"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; address_of&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::address_of</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::address_of</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="logical_not"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; logical_not&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::logical_not</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::logical_not</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="pre_inc"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; pre_inc&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::pre_inc</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::pre_inc</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="pre_dec"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; pre_dec&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::pre_dec</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::pre_dec</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="post_inc"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; post_inc&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::post_inc</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::post_inc</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="post_dec"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; post_dec&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::post_dec</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::post_dec</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="shift_left"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; shift_left&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::shift_left</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::shift_left</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="shift_right"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; shift_right&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::shift_right</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::shift_right</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="multiplies"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; multiplies&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::multiplies</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::multiplies</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="divides"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; divides&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::divides</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::divides</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="modulus"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; modulus&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::modulus</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::modulus</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="plus"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; plus&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::plus</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::plus</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="minus"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; minus&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::minus</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::minus</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="less"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; less&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::less</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::less</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="greater"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; greater&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::greater</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::greater</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="less_equal"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; less_equal&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::less_equal</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::less_equal</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="greater_equal"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; greater_equal&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::greater_equal</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::greater_equal</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="equal_to"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; equal_to&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::equal_to</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::equal_to</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="not_equal_to"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; not_equal_to&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::not_equal_to</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::not_equal_to</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="logical_or"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; logical_or&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::logical_or</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::logical_or</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="logical_and"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; logical_and&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::logical_and</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::logical_and</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="bitwise_and"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; bitwise_and&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::bitwise_and</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::bitwise_and</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="bitwise_or"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; bitwise_or&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::bitwise_or</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::bitwise_or</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="bitwise_xor"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; bitwise_xor&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::bitwise_xor</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::bitwise_xor</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="comma"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; comma&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::comma</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::comma</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="mem_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; mem_ptr&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::mem_ptr</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::mem_ptr</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="shift_left_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; shift_left_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::shift_left_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::shift_left_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="shift_right_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; shift_right_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::shift_right_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::shift_right_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="multilpies_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; multilpies_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::multilpies_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::multilpies_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="divides_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; divides_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::divides_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::divides_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="modulus_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; modulus_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::modulus_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::modulus_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="plus_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; plus_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::plus_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::plus_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="minus_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; minus_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::minus_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::minus_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="bitwise_and_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; bitwise_and_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::bitwise_and_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::bitwise_and_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="bitwise_or_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; bitwise_or_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::bitwise_or_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::bitwise_or_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="bitwise_xor_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; bitwise_xor_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::bitwise_xor_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::bitwise_xor_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="subscript"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; subscript&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::subscript</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::subscript</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="tag_of"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>Expr::tag_type</type></typedef></struct><struct name="id"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::result_of::deep_copy&lt; Expr &gt;</inherit></struct><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; function&lt; A0, void, void, void, void, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::function</classname>, <classname>args1</classname>&lt; A0 &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::function</classname></type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg2_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg3_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg4_type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; nary_expr&lt; Tag, A0, void, void, void, void, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args1</classname>&lt; A0 &gt; &gt;</type></typedef><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg2_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg3_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg4_type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; function&lt; A0, A1, void, void, void, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::function</classname>, <classname>args2</classname>&lt; A0, A1 &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::function</classname></type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type>A1</type></typedef><typedef name="arg2_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg3_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg4_type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; nary_expr&lt; Tag, A0, A1, void, void, void, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args2</classname>&lt; A0, A1 &gt; &gt;</type></typedef><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type>A1</type></typedef><typedef name="arg2_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg3_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg4_type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; function&lt; A0, A1, A2, void, void, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::function</classname>, <classname>args3</classname>&lt; A0, A1, A2 &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::function</classname></type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type>A1</type></typedef><typedef name="arg2_type"><type>A2</type></typedef><typedef name="arg3_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg4_type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; nary_expr&lt; Tag, A0, A1, A2, void, void, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args3</classname>&lt; A0, A1, A2 &gt; &gt;</type></typedef><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type>A1</type></typedef><typedef name="arg2_type"><type>A2</type></typedef><typedef name="arg3_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg4_type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; function&lt; A0, A1, A2, A3, void, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::function</classname>, <classname>args4</classname>&lt; A0, A1, A2, A3 &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::function</classname></type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type>A1</type></typedef><typedef name="arg2_type"><type>A2</type></typedef><typedef name="arg3_type"><type>A3</type></typedef><typedef name="arg4_type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; nary_expr&lt; Tag, A0, A1, A2, A3, void, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args4</classname>&lt; A0, A1, A2, A3 &gt; &gt;</type></typedef><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type>A1</type></typedef><typedef name="arg2_type"><type>A2</type></typedef><typedef name="arg3_type"><type>A3</type></typedef><typedef name="arg4_type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; function&lt; A0, A1, A2, A3, A4, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::function</classname>, <classname>args5</classname>&lt; A0, A1, A2, A3, A4 &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::function</classname></type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type>A1</type></typedef><typedef name="arg2_type"><type>A2</type></typedef><typedef name="arg3_type"><type>A3</type></typedef><typedef name="arg4_type"><type>A4</type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; nary_expr&lt; Tag, A0, A1, A2, A3, A4, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args5</classname>&lt; A0, A1, A2, A3, A4 &gt; &gt;</type></typedef><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type>A1</type></typedef><typedef name="arg2_type"><type>A2</type></typedef><typedef name="arg3_type"><type>A3</type></typedef><typedef name="arg4_type"><type>A4</type></typedef></struct-specialization><struct-specialization name="is_ref"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>typename T::is_boost_proto_ref_</template-arg></specialization></struct-specialization><struct-specialization name="is_expr"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>typename T::is_boost_proto_expr_</template-arg></specialization></struct-specialization><namespace name="functional"><struct name="as_expr"><template>
      <template-type-parameter name="Domain"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T)</template-arg></specialization><inherit access="public">boost::proto::result_of::as_expr&lt; remove_reference&lt; T &gt;::type, Domain &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::as_expr</classname>&lt; T, Domain &gt;::result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::as_expr</classname>&lt; T const, Domain &gt;::result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></method></method-group></struct><struct name="as_arg"><template>
      <template-type-parameter name="Domain"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T)</template-arg></specialization><inherit access="public">boost::proto::result_of::as_arg&lt; remove_reference&lt; T &gt;::type, Domain &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::as_arg</classname>&lt; T, Domain &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::as_arg</classname>&lt; T const, Domain &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></method></method-group></struct><struct name="arg_c"><template>
      <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
    </template><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result_of::arg_c&lt; Expr, N &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>result_of::arg_c&lt; Expr, N &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="arg"><template>
      <template-type-parameter name="N"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::arg</classname>&lt; Expr, N &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::arg</classname>&lt; Expr, N &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="left"><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::left</classname>&lt; Expr &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::left</classname>&lt; Expr &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="right"><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::right</classname>&lt; Expr &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::right</classname>&lt; Expr &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct></namespace><namespace name="result_of"><struct name="as_expr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="EnableIf"/>
    </template><typedef name="arg0_type"><type>mpl::eval_if&lt; mpl::or_&lt; boost::is_array&lt; T &gt;, is_function&lt; T &gt; &gt;, add_reference&lt; T &gt;, remove_cv&lt; T &gt;&gt;::type</type></typedef><typedef name="expr_type"><type>expr&lt; <classname>proto::tag::terminal</classname>, <classname>args1</classname>&lt; arg0_type &gt; &gt;</type></typedef><typedef name="type"><type>Domain::template apply&lt; expr_type &gt;::type</type></typedef><typedef name="result_type"><type>type</type></typedef><typedef name="T2"><type>T</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static result_type</type><parameter name="t"><paramtype>T2 &amp;</paramtype></parameter></method></method-group></struct><struct name="as_arg"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="EnableIf"/>
    </template><typedef name="expr_type"><type>expr&lt; <classname>proto::tag::terminal</classname>, <classname>args1</classname>&lt; T &amp; &gt; &gt;</type></typedef><typedef name="type"><type>Domain::template apply&lt; expr_type &gt;::type</type></typedef><typedef name="T2"><type>T</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type</type><parameter name="t"><paramtype>T2 &amp;</paramtype></parameter></method></method-group></struct><struct name="arg"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="N"/>
    </template><inherit access="public">arg_c&lt; Expr, N::value &gt;</inherit></struct><struct name="left"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::result_of::unref&lt; Expr::arg0_type &gt;</inherit></struct><struct name="right"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::result_of::unref&lt; Expr::arg1_type &gt;</inherit></struct><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>0</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; Expr::arg0_type &gt;</inherit><method-group name="public static functions"><method name="call" cv=""><type>static arg_c::reference</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="call" cv=""><type>static arg_c::const_reference</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>0</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 0 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>1</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; Expr::arg1_type &gt;</inherit><method-group name="public static functions"><method name="call" cv=""><type>static arg_c::reference</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="call" cv=""><type>static arg_c::const_reference</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>1</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 1 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>2</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; Expr::arg2_type &gt;</inherit><method-group name="public static functions"><method name="call" cv=""><type>static arg_c::reference</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="call" cv=""><type>static arg_c::const_reference</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>2</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 2 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>3</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; Expr::arg3_type &gt;</inherit><method-group name="public static functions"><method name="call" cv=""><type>static arg_c::reference</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="call" cv=""><type>static arg_c::const_reference</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>3</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 3 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>4</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; Expr::arg4_type &gt;</inherit><method-group name="public static functions"><method name="call" cv=""><type>static arg_c::reference</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="call" cv=""><type>static arg_c::const_reference</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>4</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 4 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>5</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; Expr::arg5_type &gt;</inherit><method-group name="public static functions"><method name="call" cv=""><type>static arg_c::reference</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="call" cv=""><type>static arg_c::const_reference</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>5</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 5 &gt;</inherit></struct-specialization><struct-specialization name="as_expr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>T</template-arg><template-arg>Domain</template-arg><template-arg>typename T::is_boost_proto_expr_</template-arg></specialization><typedef name="type"><type>T::boost_proto_expr_type_</type></typedef><typedef name="result_type"><type>T &amp;</type></typedef><typedef name="T2"><type>T</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static result_type</type><parameter name="t"><paramtype>T2 &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="as_arg"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>T</template-arg><template-arg>Domain</template-arg><template-arg>typename T::is_boost_proto_expr_</template-arg></specialization><typedef name="type"><type><classname>ref_</classname>&lt; T &gt;</type></typedef><typedef name="T2"><type>T</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>type</classname></type><parameter name="t"><paramtype>T2 &amp;</paramtype></parameter></method></method-group></struct-specialization></namespace><data-member name="left"><type><classname>functional::left</classname> const</type></data-member><data-member name="right"><type><classname>functional::right</classname> const</type></data-member><overloaded-function name="as_expr"><signature><type><classname>result_of::as_expr</classname>&lt; T &gt;::result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></signature><signature><type><classname>result_of::as_expr</classname>&lt; T const  &gt;::result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></signature><description><para>as_expr </para></description></overloaded-function><overloaded-function name="as_arg"><signature><type><classname>result_of::as_arg</classname>&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></signature><signature><type><classname>result_of::as_arg</classname>&lt; T const  &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></signature><description><para>as_arg </para></description></overloaded-function><overloaded-function name="arg"><signature><type><classname>result_of::unref</classname>&lt; typename Expr::type::arg0_type &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></signature><signature><type><classname>result_of::unref</classname>&lt; typename Expr::type::arg0_type &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></signature><description><para>arg </para></description></overloaded-function><overloaded-function name="arg_c"><signature><type>result_of::arg_c&lt; Expr, N &gt;::reference</type><template>
          <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></signature><signature><type>result_of::arg_c&lt; Expr, N &gt;::const_reference</type><template>
          <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></signature><description><para>arg_c </para></description></overloaded-function></namespace></namespace></header><header name="boost/xpressive/proto/transform/arg.hpp"><para>Proto transforms for extracting arguments from expressions. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="arg"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="N"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><inherit access="public">boost::proto::result_of::arg&lt; Grammar::template apply&lt; Expr, State, Visitor &gt;::type, N &gt;</inherit></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="arg_c"><template>
      <template-type-parameter name="Grammar"/>
      <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="left"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><inherit access="public">boost::proto::result_of::left&lt; Grammar::template apply&lt; Expr, State, Visitor &gt;::type &gt;</inherit></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="right"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><inherit access="public">boost::proto::result_of::right&lt; Grammar::template apply&lt; Expr, State, Visitor &gt;::type &gt;</inherit></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="state"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name=""/>
      <template-type-parameter name="State"/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>State</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static State const &amp;</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name=""><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state_"><paramtype>State const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="visitor"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
      <template-type-parameter name="Visitor"/>
    </template><typedef name="type"><type>Visitor</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static Visitor &amp;</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name=""><paramtype>Expr const &amp;</paramtype></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor_"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="always"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Always"/>
      <template-type-parameter name="Factory"/>
    </template><struct name="apply"><template>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Always</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static Always</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name=""><paramtype>Expr const &amp;</paramtype></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="identity"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method></method-group></struct><struct name="apply1"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Lambda"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="apply2"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Lambda"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name=""/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="apply3"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Lambda"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/branch.hpp"><para>A special-purpose proto transform for transforming one branch of the expression tree separately from the rest. Given an expression and a new state, it transforms the expression using the new state. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="branch"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="BranchState"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/compose.hpp"><para>A special-purpose proto transform for composing two transfomations. Given two Grammars, expressions that match the first grammar are transformed according to that grammar, and the result is forwarded to the second for further transformation. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="compose"><template>
      <template-type-parameter name="Grammar1"/>
      <template-type-parameter name="Grammar2"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><typedef name="type"><type>Grammar2::template <classname>apply</classname>&lt; typename Grammar1::template <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type, State, Visitor &gt;::type</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/conditional.hpp"><para>A special-purpose proto transform for selecting between two transforms based on a compile-time predicate. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="conditional"><template>
      <template-type-parameter name="Predicate"/>
      <template-type-parameter name="Grammar0"/>
      <template-type-parameter name="Grammar1"/>
    </template><inherit access="public">boost::proto::or_&lt; proto::and_&lt; proto::if_&lt; Predicate &gt;, Grammar0 &gt;, proto::and_&lt; proto::not_&lt; proto::if_&lt; Predicate &gt; &gt;, Grammar1 &gt; &gt;</inherit></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/fold.hpp"><para>A special-purpose proto transform for merging sequences of binary operations. It transforms the right operand and passes the result as state while transforming the left. Or, it might do the left first, if you choose. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="fold"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="reverse_fold"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/fold_to_list.hpp"><para>A higher-level transform that uses the fold, branch and list transforms to fold a binary tree into a fusion cons-list. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="fold_to_list"><template>
      <template-type-parameter name="Grammar"/>
    </template><data-member name="mpl_assertion_in_line_91" specifiers="static"><type>const std::size_t</type></data-member></struct><struct name="reverse_fold_to_list"><template>
      <template-type-parameter name="Grammar"/>
    </template><data-member name="mpl_assertion_in_line_106" specifiers="static"><type>const std::size_t</type></data-member></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/list.hpp"><para>A special-purpose proto transform for putting things into a fusion::cons&lt;&gt; list. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="list"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><typedef name="type"><type>fusion::cons&lt; typename Grammar::template <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type, State &gt;</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="tail"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><typedef name="type"><type>Grammar::template <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type::cdr_type</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/pass_through.hpp"><para>TODO </para><namespace name="boost"><namespace name="proto"><struct name="has_pass_through_transform"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><namespace name="transform"><struct name="pass_through"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header></library-reference>
