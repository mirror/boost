<html>
<head>
  <title>A Proposal to Add an Extensible Random Number Facility to the Standard Library</title>
</head>

<body bgcolor="#FFFFFF" text="#000000">

<font size=-1>
Jens Maurer &lt;Jens.Maurer@gmx.net&gt;
<br>
2002-08-27
<br>
Document Nxxxx
<br>
<code>$Id: proposal.html,v 1.14 2002/10/01 23:05:32 jmaurer Exp $</code>
</font>

<h1>A Proposal to Add an Extensible Random Number Facility to the
Standard Library</h1>

<blockquote>
Any one who considers arithmetical methods of producing random digits
is, of course, in a state of sin.
</blockquote>
<p align="right">
John von Neumann, 1951
</p>


<h2>I. Motivation</h2>

<blockquote><i>Why is this important? What kinds of problems does it
address, and what kinds of programmers, is it intended to support?  Is
it based on existing practice?</i></blockquote>

Computers are deterministic machines by design: equal input data
results in equal output, given the same internal state.  Sometimes,
applications require non-deterministic behaviour, usually provided by
generating random numbers.  Such applications include:
<ul>
<li>numerics (simulation, Monte-Carlo integration)
<li>games (shuffling card decks, non-deterministic enemy behavior)
<li>testing (generation of test input data for good coverage)
<li>security (generation of cryptographic keys)
</ul>
<p>

Programmers in all of the above areas have to find ways to generate
random numbers.  However, the difficulty to find generators that are
both efficient and have good quality is often underestimated, and so
ad-hoc implementations often fail to meet either or both of these
goals.
<p>

The C++ standard library includes <code>std::rand</code>, inherited
from the C standard library, as the only facility to generate
pseudo-random numbers.  It is underspecified, because the generation
function is not defined, and indeed early C standard library
implementations provided surprisingly bad generators.  Furthermore,
the interface relies on global state, making it difficult or
inefficient to provide for correct operation for simultaneous
invocations in multi-threaded applications.
<p>

There is a lot of existing practice in this area.  A multitude of
libraries, usually implemented in C or Fortran, is available from the
scientific community.  Some implement just one random number
engine, others seek to provide a full framework.  I know of no
comprehensive C++ framework for generating random numbers that adheres
to the design principles put forth section III.
<p>

Random number generators are appropriate for this TR because they fall
into one of the domains (numerics) identified in N1314 as a target for
the TR.

<h2>II. Impact On the Standard</h2>

<blockquote><i>What does it depend on, and what depends on it?  Is it
a pure extension, or does it require changes to standard components?
Does it require core language changes?</i></blockquote>

This proposal is a pure library extension.  It does not require
changes to any standard classes or functions.  It does not require
changes to any of the standard requirement tables.  It does not
require any changes in the core language, and it has been implemented
in standard C++ as per ISO 14882:1998.
<p>

The ISO C99 extension to specify an integral type giving a minimum or
exact bitwidth (e.g. int32_t) aids in implementing this proposal,
however these types (or the equivalent thereof under another name) can
be defined with template metaprogramming in standard C++, so these are
not strictly necessary.
<p>

In case the ISO C99 extensions become part of this TR, section IV should
be reviewed whether some requirements should be reformulated with the
ISO C99 extensions.


<h2>III. Design Decisions</h2>

<blockquote><i>Why did you choose the specific design that you did?
What alternatives did you consider, and what are the tradeoffs?  What
are the consequences of your choice, for users and implementors?  What
decisions are left up to implementors?  If there are any similar
libraries in use, how do their design decisions compare to yours?
</i></blockquote>


The design decisions are compared to those in the following libraries:
<ul>
<li>CLHEP (original at
http://wwwinfo.cern.ch/asd/lhc++/clhep/index.html, modifications from
FermiLab at (anonymous CVS)
:pserver:anonymous@zoomcvs.fnal.gov:/usr/people/cvsuser/repository)
</li>

<li>crng 1.1: Random-number generators (RNGs) implemented as Python
extension types coded in C (at http://www.sbc.su.se/~per/crng/)
</li>

<li>Swarm 2.1.1 (multi-agent simulation of complex systems), random
number package, using a Smalltalk-like programming language (at
http://www.santafe.edu/projects/swarm/swarmdocs/set/swarm.random.sgml.reference.html)
</li>

<li>GNU Scientific Library: general scientific computing library
implemented in C, comprehensive coverage of random number engines and
distributions (at http://sources.redhat.com/gsl)

</ul>


The choice of engines and distributions is also contrasted against the
following literature:

<ul>
<li>Knuth, "the Art of Computer Programming Vol. 2"
</li>

<li>"Numerical Recipes"
</li>

</ul>


<h3>A. Overview on Requirements</h3>

Here is a short overview on the requirements for the random number
framework.

<ul>
<li>allows users to choose in speed / size / quality tradeoffs
<li>has a tight enough specification to get reliable cross-platform
results
<li>allows storage of state on non-volatile media (e.g., in a disk
file)
<li>does not impede sequence "jump-ahead" for parallel computation
<li>provides a variety of base engines, to verify simulation results
<li>provides a variety of distributions, for various common tasks
<li>does not prevent implementations with utmost efficiency 
<li>provides a choice of pseudo-random numbers (for simulations etc.)
and "true" non-deterministic random numbers (for cryptography)
</ul>

All of the requirements are revisited in detail in the following
sections.


<h3>B. Pseudo-Random vs. Non-Deterministic Random Numbers</h3>

This section tries to avoid philosophical discussions about randomness
as much as possible, a certain amount of intuition is assumed.
<p>

In this proposal, a <em>pseudo-random number engine</em> is defined as
an initial internal state x(0) (also called seed), a function f that
moves from one internal state to the next x(i+1) := f(x(i)), and an
output function o that produces the output o(x(i)) of the generator.
This is an entirely deterministic process, it is determined by the
initial state x(0) and functions f and o only.  Apparent randomness is
achieved only because the client has a limited perception.
<p>

A <em>non-deterministic random-number engine</em> provides a
sequence of random numbers x(i) that cannot be foreseen.  Examples are
certain quantum-level physics experiments, measuring the time
difference between radioactive decay of individual atoms or noise of a
Zehner diode.  Relatively unforeseeable random sources are also (the
low bits of) timing between key touches, mouse movements, Ethernet
packet arrivals, etc.
<p>

Pseudo-random number engines are usually much faster than
non-deterministic random-number engines, because the latter require
I/O to query some randomness device outside of the computer.  However,
there is a common interface feature subset of both pseudo-random and
non-deterministic random-number engines.  For example, a
non-deterministic random-number engine could be employed to produce
random numbers with normal distribution; this is probably unlikely.
<p>

Library implementors may want to provide additional non-deterministic
random-number engines adhering to the interface specified in this
proposal.  Those engine might give additional information such as
entropy estimates or have optional blocking/non-blocking behavior.
<p>

Other libraries, including those mentioned above, only provide
either pseudo-random numbers, suitable for simulations and games, or
non-deterministic random numbers, suitable for cryptographic
applications.



<h3>C. Separation of Engines and Distributions</h3>

Random-number generation is usually conceptually separated into
<em>random-number engines</em> that produce uniformly distributed
random numbers between a given minimum and maximum and
<em>random-number distributions</em> that retrieve uniformly
distributed random numbers from some engine and produce numbers
according to a some distribution (e.g., Gaussian normal or Bernoulli
distribution).
Returning to the formalism in section A, the former can be identified
with the function f and the latter with the output function o.
<p>

This proposal honours this conceptual separation, but maintains a
common interface subset between engines and distributions.  This
ensures that library users needing uniformly distributed random
numbers can directly invoke an engine which matches the requirements
without the need to employ a distribution wrapper.
<em>[This might not be true: distributions have references to engines.]</em>
<p>

Furthermore, this proposal sets up requirements for distributions so
that each of them can be used with the full array of engines
available.  Similarly, a single engine can be used to provide
uniformly distributed random numbers for any of the distributions.
This freedom of combination allows for the utmost re-use.
<p>

Engines have usually been analyzed with all mathematical and empirical
tools currently available.  Nonetheless, those tools usually show the
absence of a particular weakness only, and are not exhaustive.  Albeit
unlikely, a new kind of test (for example, a use of random numbers in
a new kind of simulation or game) could show serious weaknesses in
some engines that were not known before.  
<p>

This proposal attempts to specify the engines precisely; two different
implementations, with the same seed, should return the same output
sequence.  This forces implementations to use the well-researched
engines specified hereinafter, and users can have confidence in their
quality.
<p>

On the other hand, the specifications for the distributions only
define the statistical result, not the precise algorithm to use.  This
is different from engines, because for distribution algorithms,
rigorous proofs of their correctness are available.  For example,
there are at least a handful of algorithms known to produce normally
distributed random numbers from uniformly distributed ones.  Which one
of these is most efficient depends on at least the relative execution
speeds for various trigonometric functions, cache and branch
prediction behaviour, and desired memory use.  This proposal therefore
leaves the choice of the algorithm to the implementation.  It follows
that output sequences for the distributions will not be identical
across implementations.  It is expected that implementations will
carefully choose the algorithms for distributions up front, since it
is certainly surprising to customers if some distribution produces
different numbers from one standard library version to the next.
<p>

Other libraries usually provide the same differentiation between
engines and distributions, but sometimes require a distribution
wrapper in all cases.  Since other libraries do not aim to provide a
specification framework, engines are sometimes only described
qualitatively.  Also, distributions are given as specific functions or
classes, so the quality-of-implementation question which
distribution algorithm to employ is not addressed.


<h3>D. Templates vs. Virtual Functions</h3>

The layering sketched in the previous subsection can be implemented by
either a template mechanism or by using virtual functions in a class
hierarchy.  This proposal uses templates.  Template parameters are
usually some base type and values denoting fixed parameters for the
functions f and o, e.g. a modulus.
<p>

For virtual functions in a class hierarchy, the core language requires
a (nearly) exact type match for a function in a derived classes
overriding a function in a base class.  This seems to be unnecessarily
restrictive, because engines can sometimes benefit from using
different integral base types and distributions can sometimes benefit
from using the same base type as the underlying engine.  Also, with
current compiler technology, virtual functions prevent inlining when a
pointer to the base class is used to call a virtual function that is
overridden in some derived class.  In particular with applications
such as simulations that sometimes use millions of pseudo-random
numbers per second, losing significant amounts of performance due to
missed inlining opportunities appears to not be acceptable.
<p>

The CLHEP library bases all its engines on the abstract base class
<code>HepRandomEngine</code>.  Specific engines derive from this class
and override its pure virtual functions.   Similarly, all
distributions are based on the base class <code>HepRandom</code>.
Specific distributions derive from this class, override operator(),
and provide a number of specific non-virtual functions.
<p>

The GNU Scientific Library, while coded in C, adheres to the
principles of object-structuring; all engines can be used with any of
the distributions.  The technical implementation is by mechanisms
similar to virtual functions.


<h3>E. Parameterization and Initialization for Engines</h3>

Engines usually have a "base" type which is used to store its internal
state.  Also, they usually have a choice of parameters.  For example,
a linear congruential engine is defined by x(i+1) = (a*x(i)+c) mod m,
so f(x) = (a*x+c) mod m; the base type is "int" and parameters are a,
c, and m.  Finding parameters for a given function f that make for
good randomness in the resulting engine's generated numbers x(i)
requires extensive and specialized mathematical training and
experience.  In order to make good random numbers available to a large
number of library users, this proposal not only defines generic
random-number engines, but also provides a number of predefined
well-known good parameterizations for those.  Usually, there are only
a few (less than five) well-known good parameterizations for each
engine, so it appears feasible to provide these.
<p>

Since random-number engines are mathematically designed with computer
implementation in mind, parameters are usually integers representable
in a machine word, which usually coincides nicely with a C++ built-in
type.  The parameters could either be given as (compile-time) template
arguments or as (run-time) constructor arguments.
<p>

Providing parameters as template arguments allows for providing
predefined parameterizations as simple "typedef"s.  Furthermore, the
parameters appear as integral constants, so the compiler can
value-check the given constants against the engine's base type.  Also,
the library implementor can choose different implementations depending
on the values of the parameters, without incurring any runtime
overhead.  For example, there is an efficient method to compute (a*x)
mod m, provided that a certain magnitude of m relative to the
underlying type is not exceeded.  Additionally, the compiler's
optimizer can benefit from the constants and potentially produce
better code, for example by unrolling loops with fixed loop count.
<p>

Providing parameters as constructor arguments allows for more
flexibility for the library user, for example when experimenting with
several parameterizations.  Predefined parameterizations can be
provided by defining wrapper types which default the constructor
parameters.
<p>

Other libraries have hard-coded the parameters of their engines and do
not allow the user any configuration of them at all.  If the user
wishes to change the parameters, he has to re-implement the engine's
algorithm.  In my opinion, this approach unnecessarily restricts
re-use.
<p>

Regarding initialization, this proposal chooses to provide
"deterministic seeding" with the default constructor and the
<code>seed</code> function without parameters: Two engines constructed
using the default constructor will output the same sequence.  In
contrast, the CLHEP library's default constructed engines will take a
fresh seed from a seed table for each instance.  While this approach
may be convenient for a certain group of users, it relies on global
state and can easily be emulated by appropriately wrapping engines
with deterministic seeding.
<p>

In addition to the default constructor, all engines provide a
constructor and <code>seed</code> function taking an iterator range
[it1,it2).  An engine initializes its state by successively consuming
values from the iterator range, return the advanced iterator it1.
This approach has the advantage that the user can completely exploit
the large state of some engines for initialization.  Also, it allows
to initialize compound engines in a uniform manner.  For example, a
compound engine consisting of two simpler engines would initialize the
first engine with its [it1,it2).  The first engine returns a smaller
iterator range that it has not consumed yet.  This can be used to
initialize the second engine.
<p>

I haven't seen the iterator-based approach to engine initialization in
other libraries; most initialization approaches rely on a either a
single value or on per-engine specific approaches to initialization.
<p>


<h3>F. Parameterization and Initialization for Distributions</h3>

Each distribution takes a reference to a uniform random-number
generator (for example, a pseudo-random number engine) as its first
constructor parameter.  This is called the "underlying source of
random numbers".  A distribution never stores an engine by value.
Several distribution objects (of possibly different type) can refer to
the same engine.  Whenever a distribution object is copied or
assigned, so is the reference to the underlying source of random
numbers.
<p>

Distributions have parameters for their distribution functions.  These
are constructor parameters, to be set at runtime by the library user
according to her requirements.  The parameters for a distribution
object cannot change after its construction.  When constructing the
distribution, this allows to pre-compute some data according to the
parameters given without risk of inadvertently invalidating them
later.
<p>

<em>Should we provide a special operator() for a random number with a
once-only parameterization?</em>




<h3>G. Properties as Traits vs. In-Class Constants</h3>

Users might wish to query compile-time properties of the engines and
distributions, e.g. their base types, constant parameters, etc.  This
is similar to querying the properties of the built-in types such as
<code>double</code> using std::numeric_limits&lt;&gt;.  However,
engines and distributions cannot be simple types, so it does not
appear to be necessary to separate the properties into separate traits
classes.  Instead, compile-time properties are given as members types
and static member constants.


<h3>H. Which Engines to Include</h3>

There is a multitude of pseudo-random number engines available in both
literature and code.  Some engines, such as Mersenne Twister, have an
independent algorithm ("base engine").  Others change the value or
order of output of other engines to improve randomness, for example
Knuth's "Algorithm B" ("compound engine").  The template mechanism
allows easy combination of base and compound engines.
<p>

Engines may be categorized according to the following dimensions.
Only one engine of each class should be provided.

<ul>
<li>integers or floating-point numbers produced (Some engines produce
uniformly distributed integers in the range [min,max], however, most
distribution functions expect uniformly distributed floating-point
numbers in the range [0,1[ as the input sequence.  The obvious
conversion requires a relatively costly floating-point division for
each random number used.  However, since the division is by the
constant (max-min+1), it can be replaced by a multiplication with the
precomputed value (max-min+1)<sup>-1</sup>.  To save even the
multiplication, some engines can directly produce floating-point
numbers in the range [0,1[ by maintaining the state x(i) in an
appropriately normalized form, given a sufficiently good
implementation of basic floating-point operations (e.g. IEEE
754).</li>

<li>quality of random numbers produced (What is the cycle length?
Does the engine pass all relevant statistical tests?  Up to what
dimension are numbers equidistributed?)</li>

<li>speed of generation (How many and what kind of operations have to
be performed to produce one random number, on average?)</li>

<li>size of state (How may machine words of storage are required to
hold the state x(i) of the random engine?)</li>

<li>option for independent subsequences (Is it possible to move from
x(i) to x(i+k) with at most O(log(k)) steps? This allows to
efficiently use subsequences x(0)...x(k-1), x(k)...x(2k-1), ...,
x(jk)...x((j+1)k-1), ..., for example for parallel computation, where
each of the m processors is assigned the (independent) subsequence
starting at x(jk) (0 &lt;= k &lt m).)</li>
</ul>

According to the criteria above, the engines given below were chosen.
The quality and size indications were completed according to best
known parameterizations.  Other parameterizations usually yield poorer
quality and/or less size.
<p>

<table border="1">
<tr>
<th>engine</th>
<th>quality</th>
<th>speed</th>
<th>size of state</th>
<th>subsequences</th>
<th>comments</th>
</tr>

<tr>
<td>linear_congruential</td>
<td>medium</td>
<td>medium</td>
<td>1 word</td>
<td>yes</td>
<td>cycle length is limited to the maximum value representable in one
machine word, passes most statisticial tests with chosen
parameters.</td>
</tr>

<tr>
<td>mersenne_twister</td>
<td>good</td>
<td>fast</td>
<td>624 words</td>
<td>no</td>
<td>long cycles, passes all statistical tests, good
equidistribution in high dimensions</td>
</tr>

<tr>
<td>lagged_fibonacci</td>
<td>medium</td>
<td>fast</td>
<td>up to 80,000 words</td>
<td>no</td>
<td>very long cycles possible, fails birthday spacings test, may store
the state in the [0,1[ range (see lagged_fibonacci01).</td>
</tr>

<tr>
<td>subtract_with_carry</td>
<td>medium</td>
<td>fast</td>
<td>25 words</td>
<td>no</td>
<td>very long cycles possible, fails some statistical tests, may store
the state in the [0,1[ range (see subtract_with_carry01).  Can be
improved with the discard_block compound engine.</td>
</tr>

<tr>
<td>linear_feedback_shift</td>
<td>medium</td>
<td>fast</td>
<td>1 word</td>
<td>no</td>
<td>cycle length is limited to the maximum value representable in one
machine word, fails some statistical tests, can be improved with the
xor_combine compound engine.</td>
</tr>

<tr>
<td>shuffle_output</td>
<td>good</td>
<td>fast</td>
<td>base engine + 100 words</td>
<td>no</td>
<td>compound engine that reorders the base engine's output, little
overhead for generation (one multiplication)</td>
</tr>

<tr>
<td>discard_block</td>
<td>good</td>
<td>slow</td>
<td>base engine + 1 word</td>
<td>no</td>
<td>compound engine that removes correlation provably by throwing away
significant chunks of the base engine's sequence, the resulting speed
is reduced to 10% to 3% of the base engine's.</td>
</tr>

<tr>
<td>xor_combine</td>
<td>good</td>
<td>fast</td>
<td>base engines</td>
<td>yes, if one of the base engines</td>
<td>compound engine that XOR-combines the sequences of
two base engines</td>
</tr>

</table>
<p>

Some engines were considered for inclusion, but left out for the
following reasons:

<ul>
<li>inversive congruential (Hellekalek 1995): state limited to one
machine word, therefore small cycle length, very slow generation speed
(requires computing x<sup>-1</sup> mod m), but good equidistribution
in several dimensions.</li>

<li>combining two linear congruential generators (L'Ecuyer 1988):
state limited to two machine words, therefore medium cycle length
only, medium generation speed.</li>

<li>General Feedback Shift Register with two taps: Easily exploitable
correlation (R250, Kirkpatrick and Stoll).</li>

</ul>

The GNU Scientific Library and Swarm have additional engine that are
not mentioned in the table below.
<p>

<table border="1">
<tr>
<th>Engine</th>
<th>this proposal</th>
<th>CLHEP</th>
<th>crng</th>
<th>GNU Scientific Library</th>
<th>Swarm</th>
<th>Numerical Recipes</th>
<th>Knuth</th>
</tr>

<tr>
<td>LCG(2<sup>31</sup>-1, 16807)</td>
<td>minstd_rand0</td>
<td>-</td>
<td>ParkMiller</td>
<td>ran0, minstd</td>
<td>-</td>
<td>ran0</td>
<td>p106, table 1, line 19</td>
</tr>

<tr>
<td>LCG(2<sup>32</sup>, a=1664525, c=1013904223)</td>
<td>linear_congruential&lt; ..., 1664525, 1013904223, (1 &lt&lt 32) &gt;</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>LCG1gen</td>
<td>-</td>
<td>p106, table 1, line 16</td>
</tr>

<tr>
<td>LCG1 + LCG2 + LCG3</td>
<td>-</td>
<td>-</td>
<td>WichmannHill</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>(LCG1 - LCG2 + LCG3 - LCG4) mod m0</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>C4LCGXgen</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>LCG(2<sup>31</sup>-1, 16807) with Bays/Durham shuffle</td>
<td>shuffle_output&lt;minstd_rand0, 32&gt;</td>
<td>-</td>
<td>-</td>
<td>ran1</td>
<td>PMMLCG1gen</td>
<td>ran1</td>
<td>Algorithm "B"</td>
</tr>

<tr>
<td>(LCG(2<sup>31</sup>-85, 40014) + LCG(2<sup>31</sup>-249, 40692))
mod 2<sup>31</sup>-85</td>
<td>ecuyer1988 (additive_combine not in this proposal)</td>
<td>Ranecu</td>
<td>LEcuyer</td>
<td>-</td>
<td>C2LCGXgen</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>(LCG(2<sup>31</sup>-85, 40014) with Bays/Durham shuffle +
LCG(2<sup>31</sup>-249, 40692)) mod 2<sup>31</sup>-85</td>
<td>additive_combine&lt;
    shuffle_output&lt;<br>
    linear_congruential&lt;int, 40014, 0, 2147483563, 0>, 32&gt;,<br>
    linear_congruential&lt;int, 40692, 0, 2147483399, 0>,
  val> (additive_combine not in proposal)</td>
<td>-</td>
<td>-</td>
<td>ran2</td>
<td>-</td>
<td>ran2</td>
<td>-</td>
</tr>

<tr>
<td>X(i) = (X(i-55) - X(i-33)) mod 10<sup>9</sup></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>ran3</td>
<td>~SCGgen</td>
<td>ran3</td>
<td>-</td>
</tr>

<tr>
<td>X(i) = (X(i-100) - X(i-37)) mod 2<sup>30</sup></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>ran_array</td>
</tr>

<tr>
<td>X(i) = (X(i-55) + X(i-24)) mod 2<sup>32</sup></td>
<td>lagged_fibonacci&lt; ..., 32, 55, 24, ...&gt;</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>ACGgen</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>DEShash(i,j)</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>ran4</td>
<td>-</td>
</tr>

<tr>
<td>MT</td>
<td>mt19937</td>
<td>MTwistEngine</td>
<td>MT19937</td>
<td>mt19937</td>
<td>MT19937gen</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>X(i) = (X(i-37) - X(i-24) - carry) mod 2<sup>32</sup></td>
<td>subtract_with_carry&lt; ..., (1&lt;&lt;32), 37, 24, ...&gt;</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>SWB1gen</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>X(i) = (X(i-43) - X(i-22) - carry) mod 2<sup>32</sup>-5</td>
<td>subtract_with_carry&lt; ..., (1&lt;&lt;32)-5, 43, 22, ...&gt;</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>PSWBgen</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>RCARRY with block discard by Lüscher</td>
<td>discard_block&lt; subtract_with_carry&lt...&gt;, ...&gt;</td>
<td>RanluxEngine, Ranlux64Engine</td>
<td>Ranlux</td>
<td>ranlx*</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>Hurd</td>
<td>-</td>
<td>Hurd160, Hurd288</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>physical model by Ranshi</td>
<td>-</td>
<td>Ranshi</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>return predefined data</td>
<td>-</td>
<td>NonRandom</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>RANMAR: z(i) = (z(i-97) - z(i-33)) mod 2<sup>24</sup>; y(i+1) =
(y(i)-c) mod 2<sup>24</sup>-3;  X(i) = (z(i) - y(i)) mod
2<sup>24</sup></td>
<td>additive_combine&lt; lagged_fibonacci&lt; (1&lt;&lt;24), 97, 33,
... &gt;, linear_congruential&lt; (1&lt;&lt;24)-3, 1, c, ...&gt;</td>
<td>JamesRandom</td>
<td>-</td>
<td>ranmar</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>Taus88</td>
<td>taus88 = xor_combine ...</td>
<td>-</td>
<td>Taus88</td>
<td>taus, taus2</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>Taus60</td>
<td>xor_combine&lt; linear_feedback_shift&lt; 31, 13, 12 &gt, 0,
linear_feedback_shift&lt; 29, 2, 4 &gt, 2, 0&gt;</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>C2TAUSgen</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>GFSR, 4-tap</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>gfsr4</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>MRG32k3a</td>
<td>-</td>
<td>-</td>
<td>MRG32k3a</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>

</table>


<h3>I. Which Distributions to Include</h3>

The following distributions were chosen due to their relatively
widespread use:

<ul>
<li>Integer uniform
<li>Floating-point uniform
<li>Exponential
<li>Normal
<li>Gamma
<li>Poisson
<li>Binomial
<li>Geometric
<li>Bernoulli
</ul>

<p>
The GNU Scientific Library has a multitude of additional distributions
that are not mentioned in the table below. 
<p>

<table border="1">
<tr>
<th>Distribution</th>
<th>this proposal</th>
<th>CLHEP</th>
<th>crng</th>
<th>GNU Scientific Library</th>
<th>Swarm</th>
<th>Numerical Recipes</th>
<th>Knuth</th>
</tr>

<tr>
<td>uniform (float)</td>
<td>uniform_01</td>
<td>RandFlat</td>
<td>UniformDeviate</td>
<td>flat</td>
<td>UniformDoubleDist</td>
<td>-</td>
<td>uniform</td>
</tr>

<tr>
<td>exponential</td>
<td>exponential_distribution</td>
<td>RandExponential</td>
<td>ExponentialDeviate</td>
<td>exponential</td>
<td>ExponentialDist</td>
<td>exponential</td>
<td>exponential</td>
</tr>

<tr>
<td>normal</td>
<td>normal_distribution</td>
<td>RandGauss*</td>
<td>NormalDeviate</td>
<td>gaussian</td>
<td>NormalDist</td>
<td>normal (gaussian)</td>
<td>normal</td>
</tr>

<tr>
<td>lognormal</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>lognormal</td>
<td>LogNormalDist</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>gamma</td>
<td>gamma_distribution</td>
<td>RandGamma</td>
<td>GammaDeviate</td>
<td>gamma</td>
<td>GammaDist</td>
<td>gamma</td>
<td>gamma</td>
</tr>

<tr>
<td>beta</td>
<td>-</td>
<td>-</td>
<td>BetaDeviate</td>
<td>beta</td>
<td>-</td>
<td>-</td>
<td>beta</td>
</tr>

<tr>
<td>poisson</td>
<td>poisson_distribution</td>
<td>Poisson</td>
<td>PoissonDeviate</td>
<td>poisson</td>
<td>PoissonDist</td>
<td>poisson</td>
<td>poisson</td>
</tr>

<tr>
<td>binomial</td>
<td>binomial_distribution</td>
<td>RandBinomial</td>
<td>BinomialDeviate</td>
<td>binomial</td>
<td>-</td>
<td>binomial</td>
<td>binomial</td>
</tr>

<tr>
<td>geometric</td>
<td>geometric_distribution</td>
<td>-</td>
<td>GeometricDeviate</td>
<td>geometric</td>
<td>-</td>
<td>-</td>
<td>geometric</td>
</tr>

<tr>
<td>bernoulli</td>
<td>bernoulli_distribution</td>
<td>-</td>
<td>BernoulliDeviate</td>
<td>bernoulli</td>
<td>BernoulliDist</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>random bit</td>
<td>-</td>
<td>RandBit</td>
<td>-</td>
<td>-</td>
<td>RandomBitDist</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>breit-wigner</td>
<td>-</td>
<td>RandBreitWigner</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>chi-square</td>
<td>-</td>
<td>RandChiSquare</td>
<td>-</td>
<td>chisq</td>
<td>-</td>
<td>-</td>
<td>chi-square</td>
</tr>

<tr>
<td>landau</td>
<td>-</td>
<td>Landau</td>
<td>-</td>
<td>landau</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>F</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>F</td>
<td>-</td>
<td>-</td>
<td>F (variance-ratio)</td>
</tr>

<tr>
<td>t</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>t</td>
<td>-</td>
<td>-</td>
<td>t</td>
</tr>

</table>


<h3>J. Taxonomy of Concepts</h3>

All of the engines and distributions support the number generator
requirements, i.e. they are zero-argument function objects which
return numbers.  All of the engines and some of the distributions
return uniformly distributed random numbers.  This is reflected in the
concept of the uniform random number generator, which refines number
generator.  Engines for pseudo-random numbers model the requirements
for pseudo-random number engine, which refines uniform random number
generator.

<pre>
NumberGenerator ---- UniformRandomNumberGenerator ---- Pseudo-RandomNumberGenerator
               \---- RandomDistribution
</pre>


<h3>K. Validation</h3>

All pseudo-random number engines provide a <code>validate</code>
static member function which can be used to check whether the engine
has been implemented correctly on the given platform.  The
<code>validate</code> function compares its argument against a
pre-computed and hardcoded value that is the 10001th number in the
random number sequence.  The user is expected to default-construct the
given engine, retrieve 10000 random numbers from it and then call
<code>validate()</code> with the 10001th number to validate the
implementation.
<p>

This is considered an important feature for library implementors and
serious users to check whether the provided library on the given
platform returns the correct numbers.  It could be argued that a
library implementor should provide a correct implementation of some
standard feature in any case, and thus the standard requiring a
user-checkable validation feature in the actual library code is
actually superfluous.  Should this be the view of the committee, the
validation values could easily become part of the semantic
specification and be removed from the coding requirements.
<p>

No other library I have encountered provides explicit validation
features, although some of them claim to be widely portable.
<p>
<em>The implementation of this is ugly: You usually provide a template
parameter with the validation value, which doesn't work for
floating-point values.  Probably it's better to have the validation as
a specification feature only, not an implementation feature.</em>


<h3>L. Non-Volatile Storage of Engine State</h3>

Pseudo-random number engines may store their state on a
<code>std::ostream</code> in textual form and recover it from an
appropriate <code>std::istream</code>.  Each engine specifies how its
internal state is represented.  It is expected that such external
storage happens rarely as opposed to producing random numbers, thus no
particular attention to performance is paid.
<p>

Engines use the usual idioms of <code>operator&lt;&lt;</code> and
<code>operator&gt;&gt;</code>.  If the user needs additional
processing before or after storage on non-volatile media, there is
always the option to use a temporary <code>std::stringstream</code>.
<p>

Distributions sometimes store values from the underlying source of
random numbers across calls to their operator().  For example, a
common method for generating normally distributed random numbers is to
retrieve two uniformly distribution random numbers and compute two
normally distributed random numbers out of them.  When saving the
state of the underlying engine at some point of program execution and
later restoring it, the further sequence of normally distributed
random numbers would surprisingly depend on whether the distribution
has, at this specific time, potentially outdated cached values or not.
In order to reset the distribution's random number cache to a defined
state, each distribution has a <code>reset</code> member function.  It
should be called on all distributions whenever the underlying engine
is checkpointed, i.e. stored for later re-setup and re-start at that
point.


<h3>M. Values vs. References</h3>

Compounded engines such as shuffle_output and discard_block contain a
base engine by value, because compounding is not intended to be used
on top of an existing (re-used) engine object.
<p>

In contrast, distributions contain references to engines, because a
given engine object is intended to be used with various distribution
objects, e.g. when the user requires generating interleaved values
with normal and binomial distributions.


<h3>N. Providing the Probability Density Function in Distributions</h3>

Some libraries provide the probability density function of a given
distribution as part of that distribution's interface.  While this may
be useful occasionally, this proposal does not provide for such a
feature.  One reason is separation of concerns: The distribution class
templates usually require a type that meet the requirements of a
uniform random number generator, while the computation itself does not
need one.  Also, the function representation is usually
straightforward, so the user can easily code it himself.


<h3>O. Implementation-defined behaviour</h3>

This proposal specifies implementation-defined behaviour in a number
of places.  I believe this is unavoidable; this section provides
detailed reasoning.
<p>

The precise state-holding base data types for the various engines are
left implementation-defined, because engines are usually optimized for
binary integers with 32 bits of word size.  The specification in this
proposal cannot foresee whether a 32 bit quantity on the machine is
available in C++ as short, int, long, or not at all.  It is up to the
implementation to decide which data type fits best.  The
implementation is required to document the choice of data type, so
that users can (non-portably) rely on the precise type, for example
for further computation.
<p>

The method how to produce non-deterministic random numbers is
considered implementation-defined, because it inherently depends on
the implementation and possibly even on the runtime environment:
Imagine a platform that has operating system support for randomness
collection, e.g. from user keystrokes and Ethernet inter-packet
arrival timing (Linux /dev/random does this).  If, in some
installation, access to the operating system functions providing these
services has been restricted, the C++ non-deterministic random number
engine has been deprived of its randomness.  The implementation is
required to document how these non-deterministic random numbers are
obtained, because only then can users' confidence in them grow.
<p>

The algorithms how to produce the various distributions are specified
as implementation-defined, because there is a vast variety of
algorithms known for each distribution.  Each has a different
trade-off in terms of speed, adaptation to recent computer
architectures, and memory use.  The implementation is required to
document its choice in order to allow users to verify that the
implementation's choice is acceptable.


<h3>Z. Open Issues</h3>

<ul>
<li>Some engines require non-negative template arguments.  Should
these be given as "int" or "unsigned int"?  Using "unsigned int"
sometimes adds significant clutter to the presentation.

</ul>



<h2>IV. Proposed Text</h2>

(Insert the following as a new section in clause 26 "Numerics".
Adjust the overview at the beginning of clause 26 accordingly.)
<p>

This subclause defines a facility for generating random numbers.


<h3>Random number requirements</h3>

A number generator is a function object (std:20.3
[lib.function.objects]) that takes zero arguments.
<p>

In the following table, <code>X</code> denotes a number generator
class returning objects of type <code>T</code>, and <code>u</code> is
a (possibly <code>const</code>) value of <code>X</code>.
<p>

<table border=1>
<tr>
<th colspan=4 align=center>Number generator requirements (in addition
to function object)</th>
</tr>

<tr><td>expression</td>
<td>return&nbsp;type</td>
<td>pre/post-condition</td>
<td>complexity</td>
</tr>

<tr>
<td><code>X::result_type</code></td>
<td>T</td>
<td><code>std::numeric_limits&lt;T&gt;::is_specialized</code> is
<code>true</code>, <code>T</code> is
<code>LessThanComparable</code> <em>[Why less-than-compare?]</td>
<td>compile-time</td>
</tr>

<tr>
<td><code>u()</code></td>
<td>T</td>
<td>-</td>
<td>amortized constant</td>
</tr>

</table>
<p>

The <em>tight lower bound</em> of some (finite) set S is the (unique)
member l in S, so that for all v in S, l <= v holds.  Likewise, the
<em>tight upper bound</em> of some (finite) set S is the (unique)
member u in S, so that for all v in S, v <= u holds.

<p>
In the following table, <code>X</code> denotes a uniform random number
generator class returning objects of type <code>T</code>, and
<code>v</code> is a (possibly <code>const</code>) value of
<code>X</code>.
<p>

<table border=1>
<tr>
<th colspan=4 align=center>Uniform random number generator
requirements (in addition to number generator)</th>
</tr>

<tr>
<td>expression</td>
<td>return&nbsp;type</td>
<td>pre/post-condition</td>
<td>complexity</td>
</tr>

<tr>
<td><code>X::has_fixed_range</code></td>
<td><code>bool</code></td>
<td>compile-time constant; if <code>true</code>, the range on which
the random numbers are uniformly distributed is known at compile-time
and members <code>min_value</code> and <code>max_value</code>
exist.</td>
<td>compile-time</td>
</tr>

<tr>
<td><code>X::min_value</code></td>
<td><code>T</code></td>
<td>compile-time constant; <code>min_value</code> is equal to
<code>v.min()</code></td>
<td>compile-time</td>
</tr>

<tr>
<td><code>X::max_value</code></td>
<td><code>T</code></td>
<td>compile-time constant; <code>max_value</code> is equal to
<code>v.max()</code></td>
<td>compile-time</td>
</tr>

<tr>
<td><code>v.min()</code></td>
<td><code>T</code></td>
<td>tight lower bound on the set of all values returned by
<code>operator()</code>. The return value of this function shall not
change during the lifetime of the object.</td>
<td>constant</td>
</tr>

<tr>
<td><code>v.max()</code></td>
<td><code>T</code></td>
<td>if <code>std::numeric_limits&lt;T&gt;::is_integer</code>, tight
upper bound on the set of all values returned by
<code>operator()</code>, otherwise, the smallest representable number
larger than the tight upper bound on the set of all values returned by
<code>operator()</code>.  In any case, the return value of this
function shall not change during the lifetime of the
object.</code></td>
<td>constant</td>
</tr>

</table>

<p>
In the following table, <code>X</code> denotes a pseudo-random number
engine class returning objects of type <code>T</code>, <code>t</code>
is a value of <code>T</code>, <code>u</code> is a value of
<code>X</code>, <code>v</code> is an lvalue of <code>X</code,
<code>it1</code> is an lvalue and <code>it2</code> is a (possibly
<code>const</code>) value of an input iterator type <code>It</code>
having value type convertible to <code>T</code>, <code>x</code>,
<code>y</code> are (possibly <code>const</code>) values of
<code>X</code>, <code>os</code> is convertible to an lvalue of type
<code>std::ostream</code>, and <code>is</code> is convertible to an
lvalue of type <code>std::istream</code>.
<p>
A pseudo-random number engine x has a state x(i) at any given time.
Each pseudo-random number engines defines the storage size of its
state, given as an integral constant expression involving
<code>sizeof</code>.
<p>

<table border=1>
<tr>
<th colspan=4 align=center>Pseudo-random number engine requirements
(in addition to uniform random number generator,
<code>CopyConstructible</code>, and <code>Assignable</code>)</th>
<tr><td>expression</td><td>return&nbsp;type</td>
<td>pre/post-condition</td>
<td>complexity</td>
</tr>

<tr>
<td><code>X()</code></td>
<td>-</td>
<td>creates an engine with the same initial state as all other
default-constructed engines of type <code>X</code> in the
program.</td>
<td>O(size of state)</td>
</tr>

<tr>
<td><code>X(it1, it2)</code></td>
<td>-</td>
<td>creates an engine with the initial state given by the range
<code>[it1,it2)</code>.  <code>it1</code> is advanced by the size of
state.  If the size of the range [it1,it2) is insufficient, leaves 
<code>it1 == it2</code> and throws <code>invalid_argument</code>.</td>
<td>O(size of state)</td>
</tr>

<tr>
<td><code>u.seed()</code></td>
<td>void</td>
<td>post: <code>u == X()</code></td>
<td>O(size of state)</td>
</tr>

<tr>
<td><code>u.seed(it1, it2)</code></td>
<td>void</td>
<td>post: If there are sufficient values in [it1, it2) to initialize
the state of <code>u</code>, then <code>u == X(it1,it2)</code>.
Otherwise, <code>it1 == it2</code>, throws
<code>invalid_argument</code>, and leaves <code>u</code> in an
undefined state.</td>
<td>O(size of state)</td>
</tr>

<tr>
<td><code>u()</code></td>
<td><code>T</code>
<td>given the state u(i) of the engine, computes u(i+1), sets the
state to u(i+1), and returns some output dependent on u(i+1)</td>
<td>amortized constant</td>
</tr>

<tr>
<td><code>X::validation(t)</code></td>
<td><code>bool</code></td>
<td>Given the random number sequence provided by repeated invocations
of <code>operator()</code> of a default-constructed X, returns true if
the 10001th element of said sequence is equal to <code>t</code>, false
otherwise.</td>
<td>constant</td>
</tr>

<tr>
<td><code>x == y</code></td>
<td><code>bool</code></td>
<td><code>==</code> is an equivalence relation. The current state x(i)
of x is equal to the current state y(j) of y.</td>
<td>O(size of state)</td>
</tr>

<tr>
<td><code>x != y</code></td>
<td><code>bool</code></td>
<td><code>!(x == y)</code></td>
<td>O(size of state)</td>
</tr>

<tr>
<td><code>os &lt;&lt; x</code></td>
<td><code>std::ostream&</code></td>
<td>writes a textual representation of the state x(i) of
<code>x</code> on <code>os</code>.  <em>What happens if os is in a
weird state?</em></td>
<td>O(size of state)</td>
</tr>

<tr>
<td><code>is &gt;&gt; v</code></td>
<td><code>std::istream&</code></td>
<td>sets the state v(i) of <code>v</code> as determined by reading its
textual representation from <code>is</code>.  <em>What happens if is
is in a weird state?  How to restore state from point of save?</em></td>
<td>O(size of state)</td>
</tr>

</table>
<p>

In the following table, <code>X</code> denotes a random distribution
class returning objects of type <code>T</code>, <code>u</code> is a
value of <code>X</code>, and <code>x</code> is a (possibly const)
value of <code>X</code>.
<p>

A random distribution references an underlying source of random
numbers of type <code>U</code>.
<p>

<table border=1>
<tr>
<th colspan=4 align=center>Random distribution requirements
(in addition to number generator,
<code>CopyConstructible</code>, and <code>Assignable</code>)</th>
<tr><td>expression</td><td>return&nbsp;type</td>
<td>pre/post-condition</td>
<td>complexity</td>
</tr>

<tr>
<td><code>X::base_type</code></td>
<td><code>U</code></td>
<td>-</td>
<td>compile-time</td>
</tr>

<tr>
<td><code>X(x)</code></td>
<td><code>X</code></td>
<td>copy construction; X(x) refers to the same underlying source of
random numbers as x; invokes <code>reset</code> on the copy.</td>
<td>constant</td>
</tr>

<tr>
<td><code>x.base()</code></td>
<td><code>U&</code></td>
<td>returns a reference to the underlying source of random numbers for
<code>x</code></td>
<td>constant</td>
</tr>

<tr>
<td><code>u.reset()</code></td>
<td><code>void</code></td>
<td>subsequent uses of <code>u</code> do not depend on values
produced by the underlying source of random numbers for <code>u</code>
prior to invoking <code>reset</code>.</td>
<td>constant</td>
</tr>

<tr>
<td><code>u()</code></td>
<td><code>T</code></td>
<td>the sequence of numbers returned by successive invocations is
randomly distributed with some probability density function p(x)</td>
<td>amortized constant number of invocations of the underlying source
of random numbers</td>
</tr>

</table>


<p>

<h3>Header <code>&lt;random&gt;</code> synopsis</h3>

<pre>
namespace std {
  template&lt;class IntType, IntType a, IntType c, IntType m, IntType val&gt;
  class linear_congruential;

  template&lt;class DataType, int w, int n, int m, int r, DataType a, int u,
  int s, DataType b, int t, DataType c, int l, IntType val&gt;
  class mersenne_twister;

  template&lt;class IntType, IntType m, int p, int q, IntType val&gt;
  class lagged_fibonacci;

  template&lt;class UniformRandomNumberGenerator, int k, 
    typename UniformRandomNumberGenerator::result_type val&gt;
  class shuffle_output;

  template&lt;class UniformRandomNumberGenerator, int p, int r, 
    typename UniformRandomNumberGenerator::result_type val&gt;
  class discard_block;

  template&lt;class UniformRandomNumberGenerator, class RealType = double>
  class exponential_distribution;

  template&lt;class UniformRandomNumberGenerator, class RealType = double&gt;
  class normal_distribution;

  // <em>This synopsis is incomplete.  It will be completed after discussion of the proposal in the committee.</em>
} // namespace std
</pre>


<h3>Random number engine class templates</h3>

Except where specified otherwise, the complexity of all functions specified in
the following sections is constant.  No function described in this
section except the constructor and seed functions taking an iterator
range [it1,it2) throws an exception.
<p>

The class templates specified in this section satisfy all the
requirements of a pseudo-random number engine (given in tables in
section x.x), except where specified otherwise.  Descriptions are
provided here only for operations on the engines that are not
described in one of these tables or for operations where there is
additional semantic information.
<p>

All members declared <code>static const</code> in any of the following
class templates shall be defined in such a way that they are usable as
integral constant expressions.


<h4>Class template <code>linear_congruential</code></h4>

A <code>linear_congruential</code> engine produces random numbers
using a linear function x(i+1) := (a * x(i) + c) % m.

<pre>
namespace std {
  template&lt;class IntType, IntType a, IntType c, IntType m, IntType val&gt;
  class linear_congruential
  {
  public:
    // <em>types</em>
    typedef IntType result_type;

    // <em>parameter values</em>
    static const IntType multiplier = a;
    static const IntType increment = c;
    static const IntType modulus = m;
    static const bool has_fixed_range = true;
    static const result_type min_value = <em>...</em>;
    static const result_type max_value = <em>...</em>;

    // <em> constructors and member function</em>
    explicit linear_congruential(IntType x0 = 1);
    template&lt;class In&gt; linear_congruential(In& first, In last);
    void seed(IntType x0);
    template&lt;class In&gt; void seed(In& first, In last);
    result_type min() const;
    result_type max() const;
    result_type operator()();
    static bool validation(result_type x) const;
  };

  template&lt;class IntType, IntType a, IntType c, IntType m, IntType val&gt;
  bool operator==(const linear_congruential&lt;IntType, a, c, m, val&gt;& x,
                  const linear_congruential&lt;IntType, a, c, m, val&gt;& y);
  template&lt;class IntType, IntType a, IntType c, IntType m, IntType val&gt;
  bool operator!=(const linear_congruential&lt;IntType, a, c, m, val&gt;& x,
                  const linear_congruential&lt;IntType, a, c, m, val&gt;& y);

  template&lt;class CharT, class traits,
           class IntType, IntType a, IntType c, IntType m, IntType val&gt;
  basic_ostream&lt;CharT, traits&gt;& operator&lt;&lt;(basic_ostream&lt;CharT, traits&gt;& os,
                                           const linear_congruential&lt;IntType, a, c, m, val&gt;& x);  
  template&lt;class CharT, class traits,
           class IntType, IntType a, IntType c, IntType m, IntType val&gt;
  basic_istream&lt;CharT, traits&gt;& operator&gt;&gt;(basic_istream&lt;CharT, traits&gt;& is, 
                                           linear_congruential&lt;IntType, a, c, m, val&gt;& x);

  typedef random::linear_congruential&lt;/* <em>implementation defined</em> */, 16807, 0, 2147483647,
       1043618065&gt; minstd_rand0;
  typedef random::linear_congruential&lt;/* <em>implementation defined</em> */, 48271, 0, 2147483647,
       399268537&gt; minstd_rand;
}
</pre>

<em>[min_value and max_value depend on the seed!!!!]</em>
<p>

The template parameter <code>IntType</code> shall denote an integral
type.  If the template parameter m is 0, the behaviour is
implementation defined.  Otherwise, the template parameters a and c
shall be less than m.  The template parameter <code>val</code> shall
have the value x(10001), using x(0) = 1.  The size of the state x(i)
is sizeof(IntType).


<pre>    explicit linear_congruential(IntType x0 = 1)</pre>

<strong>Requires:</strong> <code>c &gt 0 || x0 &gt; 0</code>
<br>
<strong>Effects:</strong> Constructs a
<code>linear_congruential</code> engine with state x(0) :=
<code>x0</code>.


<pre>    void seed(IntType x0)</pre>

<strong>Requires:</strong> <code>c &gt 0 || x0 &gt; 0</code>
<br>
<strong>Effects:</strong> Sets the state x(i) of the engine to
<code>x0</code>.


<pre>    static bool validation(result_type x) const</pre>

<strong>Returns:</strong> <code>x == val</code>


<pre>
  template&lt;class CharT, class traits,
           class IntType, IntType a, IntType c, IntType m, IntType val&gt;
  basic_ostream&lt;CharT, traits&gt;& operator&lt;&lt;(basic_ostream&lt;CharT, traits&gt;& os,
                                           const linear_congruential&lt;IntType, a, c, m, val&gt;& x);  
</pre>
<strong>Effects:</strong> As if <code>os &lt;&lt; x(i)</code>.

<pre>
  template&lt;class CharT, class traits,
           class IntType, IntType a, IntType c, IntType m, IntType val&gt;
  basic_istream&lt;CharT, traits&gt;& operator&gt;&gt;(basic_istream&lt;CharT, traits&gt;& is, 
                                           linear_congruential&lt;IntType, a, c, m, val&gt;& x);
</pre>
<strong>Effects:</strong> As if <code>is &gt;&gt; x(i)</code>.

<h4>Class template <code>mersenne_twister</code></h4>

A <code>mersenne_twister</code> engine produces random numbers
x(i) using the MT algorithm.

<pre>
namespace std {
  template&lt;class DataType, int w, int n, int m, int r, DataType a, int u,
  int s, DataType b, int t, DataType c, int l, IntType val&gt;
  class mersenne_twister
  {
  public:
    // <em>types</em>
    typedef DataType result_type;

    // <em>parameter values</em>
    static const int state_size = n;
    static const int shift_size = m;
    static const int mask_bits = r;
    static const DataType parameter_a = a;
    static const int output_u = u;
    static const int output_s = s;
    static const DataType output_b = b;
    static const int output_t = t;
    static const DataType output_c = c;
    static const int output_l = l;
    static const bool has_fixed_range = true;
    static const result_type min_value = <em>...</em>;
    static const result_type max_value = <em>...</em>;

    // <em> constructors and member function</em>
    mersenne_twister();
    explicit mersenne_twister(DataType value);
    template&lt;class Generator&gt; explicit mersenne_twister(Generator &amp; gen);
    template&lt;class In&gt; mersenne_twister(In& first, In last);
    void seed();
    void seed(DataType value);
    template&lt;class Generator&gt; void seed(Generator &amp; gen);
    template&lt;class In&gt; void seed(In& first, In last);
    result_type min() const;
    result_type max() const;
    result_type operator()();
    static bool validation(result_type) const;
  };

  template&lt;class DataType, int w, int n, int m, int r, DataType a, int u,
           int s, DataType b, int t, DataType c, int l, IntType val&gt;
  bool operator==(const mersenne_twister&lt;DataType, w, n, m, r, a, u, s, b, t, c, l, val>& y,
                  const mersenne_twister&lt;DataType, w, n, m, r, a, u, s, b, t, c, l, val>& x);
  template&lt;class DataType, int w, int n, int m, int r, DataType a, int u,
           int s, DataType b, int t, DataType c, int l, IntType val&gt;
  bool operator!=(const mersenne_twister&lt;DataType, w, n, m, r, a, u, s, b, t, c, l, val>& y,
                  const mersenne_twister&lt;DataType, w, n, m, r, a, u, s, b, t, c, l, val>& x);

  template&lt;class CharT, class traits,
           class DataType, int w, int n, int m, int r, DataType a, int u,
           int s, DataType b, int t, DataType c, int l, IntType val&gt;
  basic_ostream&lt;CharT, traits&gt;& operator&lt;&lt;(basic_ostream&lt;CharT, traits&gt;& os,
                                           const mersenne_twister&lt;DataType, w, n, m, r, a, u, s, b, t, c, l, val>& x);
  template&lt;class CharT, class traits,
           class DataType, int w, int n, int m, int r, DataType a, int u,
           int s, DataType b, int t, DataType c, int l, IntType val&gt;
  basic_istream&lt;CharT, traits&gt;& operator&gt;&gt;(basic_istream&lt;CharT, traits&gt;& is, 
                                           mersenne_twister&lt;DataType, w, n, m, r, a, u, s, b, t, c, l, val>& x);

  typedef mersenne_twister&lt;/* <em>implementation defined</em> */,32,351,175,19,0xccab8ee7,11,7,0x31b6ab00,15,0xffe50000,17, 2742893714U&gt; mt11213b;
  typedef mersenne_twister&lt;/* <em>implementation defined</em> */,32,624,397,31,0x9908b0df,11,7,0x9d2c5680,15,0xefc60000,18, 3346425566U&gt; mt19937;
}
</pre>

The template parameter <code>DataType</code> shall denote an unsigned
integral type.  It shall be large enough to store values up to
2<sup>w</sup>-1.  Also, the following relations shall hold:
1&lt=m&lt=n.  0&lt=r,u,s,t,l&lt=w.  0&lt=a,b,c&lt=2<sup>w</sup>-1.
The template parameter <code>val</code> shall have the value x(10001),
using the default x(0).  The size of the state x(i) is <code>n *
sizeof(DataType)</code>.


<pre>    mersenne_twister()</pre>
<strong>Effects:</strong> Constructs a <code>mersenne_twister</code>
engine and invokes <code>seed()</code>.
<br>
<strong>Complexity:</strong> O(n)

<pre>    explicit mersenne_twister(result_type value)</pre>
<strong>Effects:</strong> Constructs a <code>mersenne_twister</code>
engine and invokes <code>seed(value)</code>.
<br>
<strong>Complexity:</strong> O(n)

<pre>    template&lt;class Generator&gt; explicit mersenne_twister(Generator &amp; gen)</pre>
<strong>Effects:</strong> Constructs a <code>mersenne_twister</code>
engine and invokes <code>seed(gen)</code>.
<br>
<strong>Complexity:</strong> Exactly <code>n</code> invocations of
<code>gen</code>.

<pre>void seed()</pre>

<strong>Effects:</strong> Invokes
<code>seed(static_cast&lt;result_type&gt;(4357))</code>.
<br>
<strong>Complexity:</strong> O(n)

<pre>    void seed(result_type value)</pre>

<strong>Effects:</strong> As if
<pre>
    linear_congruential&lt;unsigned long, 69069ul, 0, 0, 0&gt; lcg(value);
    seed(lcg);
</pre>
<strong>Complexity:</strong> O(n)
<p>
<em>[This is broken: cannot use m=0 without explaining at
linear_congruential.]</em>


<pre>    template&lt;class Generator&gt; void seed(Generator &amp; gen)</pre>

<strong>Effects:</strong> Sets the state of this
<code>mersenne_twister</code> to the values returned by <code>n</code>
invocations of <code>gen</code>.
<br>
<strong>Complexity:</strong> Exactly <code>n</code> invocations of
<code>gen</code>.


<pre>    static bool validation(result_type x) const</pre>

<strong>Returns:</strong> <code>x == val</code>


<h4>Class template <code>lagged_fibonacci</code></h4>

A <code>lagged_fibonacci</code> engine produces random numbers
using x(i) = (x(i-q) + x(i-p)) mod m.
<p>

<pre>
namespace std {
  template&lt;class IntType, IntType m, int p, int q, IntType val&gt;
  class lagged_fibonacci
  {
  public:
    // <em>types</em>
    typedef IntType result_type;

    // <em>parameter values</em>
    static const IntType modulus = m;
    static const int long_lag = p;
    static const int short_lag = q;
    static const bool has_fixed_range = true;
    static const result_type min_value = <em>...</em>;
    static const result_type max_value = <em>...</em>;

    // <em> constructors and member function</em>
    lagged_fibonacci();
    explicit lagged_fibonacci(IntType value);
    template&lt;class Generator&gt; explicit lagged_fibonacci(Generator & gen);
    template&lt;class In&gt; lagged_fibonacci(In& first, In last);
    void seed(IntType value = 331u);
    template&lt;class Generator&gt; void seed(Generator & gen);
    template&lt;class In&gt; void seed(In& first, In last);
    result_type min() const;
    result_type max() const;
    result_type operator()();
    static bool validation(result_type x) const;
  };
  template&lt;class IntType, IntType m, int p, int q, IntType val&gt;
  bool operator==(const lagged_fibonacci&lt;IntType, m, p, q, val&gt x,
                  const lagged_fibonacci&lt;IntType, m, p, q, val&gt y);

  template&lt;class IntType, IntType m, int p, int q, IntType val&gt;
  bool operator!=(const lagged_fibonacci&lt;IntType, m, p, q, val&gt x,
                  const lagged_fibonacci&lt;IntType, m, p, q, val&gt y);
}
</pre>

The template parameter <code>IntType</code> shall denote an unsigned
integral type.  The following relation shall hold: 0&lt;=q&lt;p.  The
template parameter <code>val</code> shall have the value x(10001),
using the default x(0).  The size of the state is <code>p *
sizeof(IntType)</code>.

<pre>    lagged_fibonacci()</pre>
<strong>Effects:</strong> Constructs a <code>lagged_fibonacci</code>
engine and invokes <code>seed()</code>.

<pre>    explicit lagged_fibonacci(result_type value)</pre>
<strong>Effects:</strong> Constructs a <code>lagged_fibonacci</code>
engine and invokes <code>seed(value)</code>.

<pre>    template&lt;class Generator&gt; explicit lagged_fibonacci(Generator &amp; gen)</pre>
<strong>Effects:</strong> Constructs a <code>lagged_fibonacci</code>
engine and invokes <code>seed(gen)</code>.

<pre>    void seed()</pre>
<strong>Effects:</strong> Invokes
<code>seed(static_cast&lt;result_type&gt;(331))</code>.
<br>
<strong>Complexity:</strong> O(p)

<pre>    void seed(result_type value)</pre>
<strong>Effects:</strong> As if
<pre>
    minstd_rand0 lcg(value);
    seed(lcg);
</pre>
<strong>Complexity:</strong> O(p)

<pre>    template&lt;class Generator&gt; void seed(Generator &amp; gen)</pre>#
<strong>Effects:</strong> Sets the state of this
<code>lagged_fibonacci</code> to the values returned by <code>p</code>
invocations of <code>gen</code>.
<br>
<strong>Complexity:</strong> Exactly <code>p</code> invocations of
<code>gen</code>.


<pre>    static bool validation(result_type x) const</pre>

<strong>Returns:</strong> <code>x == val</code>



<h4>Class template <code>shuffle_output</code></h4>

A <code>shuffle_output</code> engine produces random numbers from some
base engine according to "Algorithm B" described by Knuth.  [<em>Say
what the state is.]</em>
<p>

<pre>
namespace std {
  template&lt;class UniformRandomNumberGenerator, int k, 
    typename UniformRandomNumberGenerator::result_type val&gt;
  class shuffle_output
  {
  public:
    // <em>types</em>
    typedef UniformRandomNumberGenerator base_type;
    typedef typename base_type::result_type result_type;
  
    // <em>parameter values</em>
    static const bool has_fixed_range = base_type::has_fixed_range;
    static const int buffer_size = k;
  
    // <em> constructors and member function</em>
    shuffle_output();
    template&lt;class T&gt; explicit shuffle_output(T seed);
    explicit shuffle_output(const base_type & rng);
    template&lt;class In&gt; shuffle_output(In& first, In last);
    void seed();
    template&lt;class T&gt; void seed(T s);
    template&lt;class In&gt; void seed(In& first, In last);
    const base_type& base() const;
    result_type min() const;
    result_type max() const;
    result_type operator()();  
    static bool validation(result_type x);
  private:
    // void init();                 <em>exposition only</em>
    // base_type b;                 <em>exposition only</em>
    // result_type v[k];            <em>exposition only</em>
    // result_type y;               <em>exposition only</em>
  };
  template&lt;class UniformRandomNumberGenerator, int k, 
    typename UniformRandomNumberGenerator::result_type val&gt;
  bool operator==(const shuffle_output&lt;UniformRandomNumberGenerator,k,val&gt; & x,
                 (const shuffle_output&lt;UniformRandomNumberGenerator,k,val&gt; & y);
  template&lt;class UniformRandomNumberGenerator, int k, 
    typename UniformRandomNumberGenerator::result_type val&gt;
  bool operator!=(const shuffle_output&lt;UniformRandomNumberGenerator,k,val&gt; & x,
                 (const shuffle_output&lt;UniformRandomNumberGenerator,k,val&gt; & y);
}
</pre>

The template parameter <code>UniformRandomNumberGenerator</code> shall
denote a class that satisfies all the requirements of a uniform random
number generator. The template parameter <code>val</code> shall have
the value x(10001), using the default x(0).  The size of the state is
the size of <code><em>b</em></code plus <code>sizeof(v[k]) +
sizeof(y)</code>.

<pre>    shuffle_output()</pre>
<strong>Effects:</strong> Constructs a <code>shuffle_output</code>
engine.  For <em>b</em>, invokes <code>base_type</code>'s
default constructor.  Invokes <code><em>init()</em></code>.

<pre>    template&lt;class T&gt; explicit shuffle_output(T x)</pre>
<strong>Effects:</strong> Constructs a <code>shuffle_output</code>
engine.  For <em>b</em>, invokes <code>base_type</code>'s
(possibly explicit) constructor taking a single argument of
<code>T</code>.  Invokes <code><em>init()</em></code>.
<br>
<strong>Notes:</strong> Only those specializations of the function
template are available where <code>base_type(x)</code> is well-formed.

<pre>    explicit shuffle_output(const base_type & rng);</pre>
<strong>Effects:</strong> Constructs a <code>shuffle_output</code>
engine.  Initializes <em>b</em> with a copy of <code>rng</code>.
Invokes <code><em>init()</em></code>.

<pre>    void seed()</pre>
<strong>Effects:</strong> Invokes <code><em>b</em>.seed()</code>,
then <code><em>init()</em></code>.

<pre>    template&lt;class T&gt; void seed(T s)</pre>
<strong>Effects:</strong> Invokes <code><em>b</em>.seed(s)</code>,
then <code><em>init()</em></code>.
<br>
<strong>Notes:</strong> Only those specializations of the function
template are available where <code><em>b</em>.seed(x)</code> is
well-formed.


<pre>    const base_type& base() const</pre>
<strong>Returns:</strong> <em>b</em>

<pre>    static bool validation(result_type x) const</pre>
<strong>Returns:</strong> <code>x == val</code>

<pre>    void init()</pre>
<strong>Effects:</strong> Sets <code><em>v[j]</em></code> (for j = 0
.. k-1) and y to the values returned by successive invocations of
<code><em>b</em></code>.
<br>
<strong>Complexity:</strong> Exactly <code>k+1</code> invocations of
<code>base</code>.


<h4>Class template <code>discard_block</code></h4>

A <code>discard_block</code> engine produces random numbers from some
base engine by discarding blocks of data.
<p>

<pre>
namespace std {
  template&lt;class UniformRandomNumberGenerator, int p, int r, 
    typename UniformRandomNumberGenerator::result_type val&gt;
  class discard_block
  {
  public:
    // <em>types</em>
    typedef UniformRandomNumberGenerator base_type;
    typedef typename base_type::result_type result_type;
  
    // <em>parameter values</em>
    static const bool has_fixed_range = base_type::has_fixed_range;
    static const int block_size = p;
    static const int used_block = r;
  
    // <em> constructors and member function</em>
    discard_block();
    template&lt;class T&gt; explicit discard_block(T seed);
    explicit discard_block(const base_type & rng);
    template&lt;class In&gt; discard_block(In& first, In last);
    void seed();
    template&lt;class T&gt; void seed(T s);
    template&lt;class In&gt; void seed(In& first, In last);
    const base_type& base() const;
    result_type min() const;
    result_type max() const;
    result_type operator()();  
    static bool validation(result_type x);
  private:
    // base_type base;              <em>exposition only</em>
    // int n;                       <em>exposition only</em>
  };
  template&lt;class UniformRandomNumberGenerator, int p, int r, 
    typename UniformRandomNumberGenerator::result_type val&gt;
  bool operator==(const discard_block&lt;UniformRandomNumberGenerator,p,r,val&gt; & x,
                 (const discard_block&lt;UniformRandomNumberGenerator,p,r,val&gt; & y);
  template&lt;class UniformRandomNumberGenerator, int p, int r,
    typename UniformRandomNumberGenerator::result_type val&gt;
  bool operator!=(const discard_block&lt;UniformRandomNumberGenerator,p,r,val&gt; & x,
                 (const discard_block&lt;UniformRandomNumberGenerator,p,r,val&gt; & y);

  template&lt;class CharT, class traits,
           class UniformRandomNumberGenerator, int p, int r,
           typename UniformRandomNumberGenerator::result_type val&gt;
  basic_ostream&lt;CharT, traits&gt;& operator&lt;&lt;(basic_ostream&lt;CharT, traits&gt;& os,
                                           const discard_block&lt;UniformRandomNumberGenerator,p,r,val&gt; & x);
  template&lt;class CharT, class traits,
           class UniformRandomNumberGenerator, int p, int r,
           typename UniformRandomNumberGenerator::result_type val&gt;
  basic_istream&lt;CharT, traits&gt;& operator&gt;&gt;(basic_istream&lt;CharT, traits&gt;& is, 
                                           discard_block&lt;UniformRandomNumberGenerator,p,r,val&gt; & x);

}
</pre>

The template parameter <code>UniformRandomNumberGenerator</code> shall
denote a class that satisfies all the requirements of a uniform random
number generator. r &lt;= p. The template parameter <code>val</code> shall have
the value x(10001), using the default x(0).  The size of the state is
the size of <code><em>b</em></code> plus sizeof(n).

<pre>    discard_block()</pre>
<strong>Effects:</strong> Constructs a <code>discard_block</code>
engine.  For <em>b</em>, invokes <code>base_type</code>'s
default constructor.  Sets <code>n = 0</code>.

<pre>    template&lt;class T&gt; explicit discard_block(T x)</pre>
<strong>Effects:</strong> Constructs a <code>discard_block</code>
engine.  For <em>b</em>, invokes <code>base_type</code>'s
(possibly explicit) constructor taking a single argument of
<code>T</code>.  Sets <code>n = 0</code>.
<br>
<strong>Notes:</strong> Only those specializations of the function
template are available where <code>base_type(x)</code> is well-formed.

<pre>    explicit discard_block(const base_type & rng);</pre>
<strong>Effects:</strong> Constructs a <code>discard_block</code>
engine.  Initializes <em>b</em> with a copy of <code>rng</code>.
Sets <code>n = 0</code>.

<pre>    void seed()</pre>
<strong>Effects:</strong> Invokes <code><em>b</em>.seed()</code>
and sets <code>n = 0</code>.

<pre>    template&lt;class T&gt; void seed(T s)</pre>
<strong>Effects:</strong> Invokes <code><em>b</em>.seed(s)</code>
and sets <code>n = 0</code>.
<br>
<strong>Notes:</strong> Only those specializations of the function
template are available where <code><em>b</em>.seed(x)</code> is
well-formed.

<pre>    const base_type& base() const</pre>
<strong>Returns:</strong> <em>b</em>

<pre>    result_type operator()()</pre>
<strong>Effects:</strong> If n &gt;= r, invokes
<code><em>b</em></code> (p-r) times, discards the values returned,
and sets <code>n = 0</code>.  In any case, increments <code>n</code>
and returns <code><em>b()</em></code>.

<pre>    static bool validation(result_type x) const</pre>
<strong>Returns:</strong> <code>x == val</code>

<pre>
  template&lt;class CharT, class traits,
           class UniformRandomNumberGenerator, int p, int r,
           typename UniformRandomNumberGenerator::result_type val&gt;
  basic_ostream&lt;CharT, traits&gt;& operator&lt;&lt;(basic_ostream&lt;CharT, traits&gt;& os,
                                           const discard_block&lt;UniformRandomNumberGenerator,p,r,val&gt; & x);
</pre>
<strong>Effects:</strong> As if <code>os &lt;&lt; <em>b</em>
&lt;&lt; <em>n</em></code>.

<pre>
  template&lt;class CharT, class traits,
           class UniformRandomNumberGenerator, int p, int r,
           typename UniformRandomNumberGenerator::result_type val&gt;
  basic_istream&lt;CharT, traits&gt;& operator&gt;&gt;(basic_istream&lt;CharT, traits&gt;& is, 
                                           discard_block&lt;UniformRandomNumberGenerator,p,r,val&gt; & x);
</pre>
<strong>Effects:</strong> As if <code>is &gt;&gt; <em>b</em>
&gt;&gt; <em>n</em></code>.


<h3>Class <code>random_device</code></h3>

A <code>random_device</code> produces non-deterministic random
numbers.  It satisfies all the requirements of a uniform random number
generator (given in tables in section x.x).  Descriptions are provided
here only for operations on the engines that are not described in one
of these tables or for operations where there is additional semantic
information.
<p>

If implementation limitations prevent generating non-deterministic
random numbers, the implementation can employ a pseudo-random number
engine.

<pre>
namespace std {
  class random_device
  {
  public:
    // <em>types</em>
    typedef unsigned int result_type;

    // <em>constants</em>
    static const bool has_fixed_range = true;
    static const result_type min_value = 0;
    static const result_type max_value = <em> /* ... */</em>;
  
    // <em>constructors, destructors and member functions</em>
    explicit random_device(const std::string& token = /* <em>implementation-defined</em> */);
    result_type min() const { return min_value; }
    result_type max() const { return max_value; }
    double entropy() const;
    result_type operator()();
  
  private:
    random_device(const random_device& );
    void operator=(const random_device& );
  };
}
</pre>

All members declared <code>static const</code> shall be defined in
such a way that they are usable as integral constant expressions.
The member <code>max_value</code> contains the maximum value
representable in a value of type <code>unsigned int</code>.

<pre>    explicit random_device(const std::string& token = /* <em>implementation-defined</em> */)</pre>
<strong>Effects:</strong> Constructs a <code>random_device</code>
non-deterministic random number engine.  The semantics and default
value of the <code>token</code> parameter are implementation-defined.
[Footnote: The parameter is intended to allow an implementation to
differentiate between different sources of randomness.]
<br>
<strong>Throws:</strong> A value of some type derived from
<code>exception</code> if the <code>random_device</code> could not be
initialized.

<pre>    double entropy() const</pre>
<strong>Returns:</strong> An entropy estimate for the random numbers
returned by operator(), in the range 0 to
log<sub>2</sub>(<code>max_value</code>+1).  A deterministic random
number generator (e.g. a pseudo-random number engine) has entropy 0.
<br>
<strong>Throws:</strong> Nothing.


<pre>    result_type operator()()</pre>
<strong>Returns:</strong> A non-deterministic random value, uniformly
distributed between 0 and <code>max_value</code>, inclusive.  It is
implementation-defined how these values are generated.
<br>
<strong>Throws:</strong> A value of some type derived from
<code>exception</code> if a random number could not be obtained.


<h3>Random distribution class templates</h3>

The class templates specified in this section satisfy all the
requirements of a random distribution (given in tables in section
x.x).  Descriptions are provided here only for operations on the
distributions that are not described in one of these tables or for
operations where there is additional semantic information.  No
function described in this section throws an exception.
<p>
In this section, the template parameter
<code>UniformRandomNumberGenerator</code> shall denote a class that
satisfies all the requirements of a uniform random number generator.
Furthermore, a template parameter named <code>RealType</code> shall
denote a type that holds an approximation to a real number.  This type
shall meet the requirements for a numeric type (26.1
[lib.numeric.requirements]), the binary operators +, -, *, / shall be
applicable to it, and function signatures analogous to those
for type <code>double</code> in section 26.5 [lib.c.math] shall be
available by argument-dependent lookup (3.4.2 [basic.lookup.koenig]).
<em>[Footnote: The built-in floating-point types <code>float</code>
and <code>double</code> meet these requirements.]</em>
<p>
The algorithms for producing each of the specified distributions are
implementation-defined.


<h4>Class template <code>bernoulli_distribution</code></h4>

A <code>bernoulli_distribution</code> random distribution produces
<code>bool</code> values distributed with probabilities p(true) = p
and p(false) = 1-p.  p is the parameter of the distribution.

<pre>
namespace std {
  template&lt;class UniformRandomNumberGenerator, class RealType = double>
  class bernoulli_distribution
  {
  public:
    // <em>types</em>
    typedef UniformRandomNumberGenerator base_type;
    typedef bool result_type;

    // <em> constructors and member function</em>
    bernoulli_distribution(base_type & rng, const RealType& p);
    RealType p() const;
    base_type& base() const;
    void reset();
    result_type operator()();
  };
}
</pre>

<pre>    bernoulli_distribution(base_type & rng, const RealType& p)</pre>

<strong>Requires:</strong> 0 &lt;= p &lt;= 1
<br>
<strong>Effects:</strong> Constructs a
<code>bernoulli_distribution</code> object with <code>rng</code> as
the reference to the underlying source of random
numbers.  <code>p</code> is the parameter of the distribution.

<pre>    RealType p() const;</pre>
<strong>Returns:</strong> The "p" parameter of the distribution.


<h4>Class template <code>geometric_distribution</code></h4>

A <code>geometric_distribution</code> random distribution produces
integer values <em>i</em> &gt;= 1 with p(i) = (1-p) *
p<sup>i-1</sup>.  p is the parameter of the distribution.

<pre>
namespace std {
  template&lt;class UniformRandomNumberGenerator, class IntType = int, class RealType = double>
  class geometric_distribution
  {
  public:
    // <em>types</em>
    typedef UniformRandomNumberGenerator base_type;
    typedef IntType result_type;

    // <em> constructors and member function</em>
    geometric_distribution(base_type & rng, const RealType& p);
    RealType p() const;
    base_type& base() const;
    void reset();
    result_type operator()();
  };
}
</pre>

<pre>    geometric_distribution(base_type & rng, const RealType& p)</pre>

<strong>Requires:</strong> 0 &lt; p &lt; 1
<br>
<strong>Effects:</strong> Constructs a
<code>geometric_distribution</code> object with <code>rng</code> as
the reference to the underlying source of random
numbers.  <code>p</code> is the parameter of the distribution.

<pre>   RealType p() const;</pre>
<strong>Returns:</strong> The "p" parameter of the distribution.


<h4>Class template <code>poisson_distribution</code></h4>

A <code>poisson_distribution</code> random distribution produces
integer values <em>i</em> &gt;= 0 with p(i) = exp(-mean) *
mean<sup>i</sup> / i!.  mean is the parameter of the distribution.

<pre>
namespace std {
  template&lt;class UniformRandomNumberGenerator, class IntType = int, class RealType = double>
  class poisson_distribution
  {
  public:
    // <em>types</em>
    typedef UniformRandomNumberGenerator base_type;
    typedef IntType result_type;

    // <em> constructors and member function</em>
    poisson_distribution(base_type & rng, const RealType& mean);
    RealType mean() const;
    base_type& base() const;
    void reset();
    result_type operator()();
  };
}
</pre>

<pre>    poisson_distribution(base_type & rng, const RealType& mean)</pre>

<strong>Requires:</strong> mean &gt; 0
<br>
<strong>Effects:</strong> Constructs a
<code>poisson_distribution</code> object with <code>rng</code> as
the reference to the underlying source of random
numbers.  <code>mean</code> is the parameter of the distribution.

<pre>   RealType mean() const;</pre>
<strong>Returns:</strong> The "mean" parameter of the distribution.


<h4>Class template <code>binomial_distribution</code></h4>

A <code>binomial_distribution</code> random distribution produces
integer values <em>i</em> &gt;= 0 with p(i) = (n over i) *
p<sup>i</sup> * (1-p)<sup>t-i</sup>.  t and p are the parameters of the
distribution.

<pre>
namespace std {
  template&lt;class UniformRandomNumberGenerator, class IntType = int, class RealType = double>
  class binomial_distribution
  {
  public:
    // <em>types</em>
    typedef UniformRandomNumberGenerator base_type;
    typedef IntType result_type;

    // <em> constructors and member function</em>
    binomial_distribution(base_type & rng, IntType t, const RealType& p);
    IntType t() const;
    RealType p() const;
    base_type& base() const;
    void reset();
    result_type operator()();
  };
}
</pre>

<pre>    binomial_distribution(base_type & rng, IntType t, const RealType& p)</pre>

<strong>Requires:</strong> 0 &lt;= p &lt;= 1 and t &gt;= 0
<br>
<strong>Effects:</strong> Constructs a
<code>binomial_distribution</code> object with <code>rng</code> as
the reference to the underlying source of random
numbers.  <code>t</code> and <code>p</code> are the parameters of the
distribution.

<pre>   IntType t() const;</pre>
<strong>Returns:</strong> The "t" parameter of the distribution.

<pre>   RealType p() const;</pre>
<strong>Returns:</strong> The "p" parameter of the distribution.



<h4>Class template <code>uniform_01</code></h4>

A <code>uniform_01</code> random distribution produces random numbers 0
&lt;= x &lt; 1 with equal probability.

<pre>
namespace std {
  template&lt;class UniformRandomNumberGenerator, class RealType = double&gt;
  class uniform_01
  {
  public:
    typedef UniformRandomNumberGenerator base_type;
    typedef RealType result_type;
    static const bool has_fixed_range = false;
    explicit uniform_01(base_type & rng);
    result_type min() const;
    result_type max() const;
    base_type& base() const;
    void reset();
    result_type operator()();
  };
}
</pre>

In addition to the requirements put forth in the introduction, the
template parameter <code>RealType</code> shall be large enough to hold
numbers of value <code>rng.max()-rng.min()+1</code>.
<p>
The <code>uniform_01</code> class template also satisfies the
requirements of a uniform random-number generator.

<pre>    explicit uniform_01(base_type& rng)</pre>
<strong>Effects:</strong> Constructs a
<code>uniform_01</code> object with <code>rng</code> as
the reference to the underlying source of random
numbers.

<pre>    result_type operator()()</pre>
<strong>Returns:</strong> If the argument for the template parameter
<code>UniformRandomNumberGenerator</code> is a
<code>linear_congruential</code> generator, uses the least significant
bits of the numbers produced by the latter for least significant
digits of the result only.


<h4>Class template <code>exponential_distribution</code></h4>

An <code>exponential_distribution</code> random distribution produces
random numbers x &gt; 0 distributed with probability density function
p(x) = lambda * exp(-lambda * x), where lambda is the parameter of the
distribution.

<pre>
namespace std {
  template&lt;class UniformRandomNumberGenerator, class RealType = double>
  class exponential_distribution
  {
  public:
    // <em>types</em>
    typedef UniformRandomNumberGenerator base_type;
    typedef RealType result_type;

    // <em> constructors and member function</em>
    explicit exponential_distribution(base_type& rng, const result_type& lambda = 1);
    RealType lambda() const;
    base_type& base() const;
    void reset();
    result_type operator()();
  };
}
</pre>

<pre>    exponential_distribution(base_type& rng, const result_type& lambda)</pre>

<strong>Requires:</strong> lambda &gt; 0
<br>
<strong>Effects:</strong> Constructs an
<code>exponential_distribution</code> object with <code>rng</code> as
the reference to the underlying source of random
numbers. <code>lambda</code> is the parameter for the distribution.


<h4>Class template <code>normal_distribution</code></h4>

A <code>normal_distribution</code> random distribution produces
random numbers x distributed with probability density function
p(x) = 1/sqrt(2*pi*sigma) * exp(- (x-mean)<sup>2</sup> /
(2*sigma<sup>2</sup>) ), where mean and sigma are the parameters of
the distribution.

<pre>
namespace std {
  template&lt;class UniformRandomNumberGenerator, class RealType = double&gt;
  class normal_distribution
  {
  public:
    // <em>types</em>
    typedef UniformRandomNumberGenerator base_type;
    typedef RealType result_type;

    // <em> constructors and member function</em>
    explicit normal_distribution(base_type & rng, const result_type& mean = 0,
                                 const result_type& sigma = 1);
    RealType mean() const;
    RealType sigma() const;
    base_type& base() const;
    void reset();
    result_type operator()();
  };
}
</pre>


<pre>
    explicit normal_distribution(base_type & rng, const result_type& mean = 0,
                                 const result_type& sigma = 1);
</pre>

<strong>Requires:</strong> sigma &gt; 0
<br>
<strong>Effects:</strong> Constructs a
<code>normal_distribution</code> object with <code>rng</code> as
the reference to the underlying source of random
numbers. <code>mean</code> and <code>sigma</code> are the parameters
for the distribution.

<pre>    RealType mean() const</pre>
<strong>Returns:</strong> The "mean" parameter of the distribution.

<pre>    RealType sigma() const</pre>
<strong>Returns:</strong> The "sigma" parameter of the distribution.


<h4>Class template <code>gamma_distribution</code></h4>

A <code>gamma_distribution</code> random distribution produces
random numbers x distributed with probability density function
p(x) = 1/Gamma(alpha) * x<sup>alpha-1</sup> * exp(-x), where alpha is the
parameter of the distribution.

<pre>
namespace std {
  template&lt;class UniformRandomNumberGenerator, class RealType = double&gt;
  class gamma_distribution
  {
  public:
    // <em>types</em>
    typedef UniformRandomNumberGenerator base_type;
    typedef RealType result_type;

    // <em> constructors and member function</em>
    explicit gamma_distribution(base_type & rng, const result_type& alpha);
    RealType alpha() const;
    base_type& base() const;
    void reset();
    result_type operator()();
  };
}
</pre>


<pre>
    explicit gamma_distribution(base_type & rng, const result_type& alpha);
</pre>

<strong>Requires:</strong> alpha &gt; 0
<br>
<strong>Effects:</strong> Constructs a
<code>gamma_distribution</code> object with <code>rng</code> as
the reference to the underlying source of random
numbers. <code>alpha</code> is the parameter for the distribution.

<pre>    RealType alpha() const</pre>
<strong>Returns:</strong> The "alpha" parameter of the distribution.



<h2>V. Acknowledgements</h2>

<ul>
<li>Thanks to Walter Brown, Marc Fischler and Marc Paterno from Fermilab
for input about the requirements of high-energy physics.
</li>

<li>Thanks to the Boost community for a platform for experimentation.
</li>

</ul>



<h2>VI. References</h2>

<ul>
<li>William H. Press, Saul A. Teukolsky, William A. Vetterling, Brian
P.  Flannery, "Numerical Recipes in C: The art of scientific
computing", 2nd ed., 1992, pp. 274-328
</li>

<li>Bruce Schneier, "Applied Cryptography", 2nd ed., 1996, ch. 16-17.
[I haven't read this myself. Yet.]
</li>

<li>D. H. Lehmer, "Mathematical methods in large-scale computing
units", Proc. 2nd Symposium on Large-Scale Digital Calculating
Machines, Harvard University Press, 1951, pp. 141-146
</li>

<li>P.A. Lewis, A.S. Goodman, J.M. Miller, "A pseudo-random number
generator for the System/360", IBM Systems Journal, Vol. 8, No. 2,
1969, pp. 136-146
</li>

<li>Stephen K. Park and Keith W. Miller, "Random Number Generators:
Good ones are hard to find", Communications of the ACM, Vol. 31,
No. 10, October 1988, pp. 1192-1201
</li>

<li>Makoto Matsumoto and Takuji Nishimura, "Mersenne Twister: A
623-dimensionally equidistributed uniform pseudo-random number
generator", ACM Transactions on Modeling and Computer Simulation:
Special Issue on Uniform Random Number Generation, Vol. 8, No. 1,
January 1998, pp. 3-30.
<a href="http://www.math.keio.ac.jp/matumoto/emt.html">http://www.math.keio.ac.jp/matumoto/emt.html</a>
</li>

<li>Donald E. Knuth, "The Art of Computer Programming, Vol. 2",
3rd ed., 1997, pp. 1-193.
</li>

<li>Carter Bays and S.D. Durham, "Improving a poor random number
generator", ACM Transactions on Mathematical Software, Vol. 2, 1979,
pp. 59-64.
</li>

<li>Martin Lüscher, "A portable high-quality random number generator
for lattice field theory simulations.", Computer Physics
Communications, Vol. 79, 1994, pp. 100-110.
</li>

<li>William J. Hurd, "Efficient Generation of Statistically Good
Pseudonoise by Linearly Interconnected Shift Registers", Technical
Report 32-1526, Volume XI, The Deep Space Network Progress Report for
July and August 1972, NASA Jet Propulsion Laboratory, 1972 and IEEE
Transactions on Computers Vol. 23, 1974.
</li>

<li>Pierre L'Ecuyer, "Efficient and Portable Combined Random Number
Generators", Communications of the ACM, Vol. 31, pp. 742-749+774,
1988.
</li>

<li>Pierre L'Ecuyer, "Maximally equidistributed combined Tausworthe
generators", Mathematics of Computation Vol. 65, pp. 203-213, 1996.
</li>

<li>Pierre L'Ecuyer, "Good parameters and implementations for combined
multple recursive random number generators", Operations Research
Vol. 47, pp. 159-164, 1999.
</li>

<li>S. Kirkpatrick and E. Stoll, "A very fast shift-register sequence
random number generator", Journal of Computational Physics, Vol. 40,
pp. 517-526, 1981.</li>

<li>R. C. Tausworthe, "Random numbers generated by iinear recurrence
modulo two", Mathematics of Computation, Vol. 19, pp. 201-209,
1965.</li>

<li>George Marsaglia and Arif Zaman, "A New Class of Random Number
Generators", Annals of Applied Probability, Vol. 1, No. 3, 1991.</li>

</ul>
