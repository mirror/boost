<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Template"
content="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Header <boost/compressed_pair.hpp></title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF"
vlink="#800080">

<h2><img src="../../c++boost.gif" width="276" height="86">Header
&lt;<a href="../../boost/detail/call_traits.hpp">boost/compressed_pair.hpp</a>&gt;</h2>

<p>All of the contents of &lt;boost/compressed_pair.hpp&gt; are
defined inside namespace boost.</p>

<p>The class compressed pair is very similar to std::pair, but if
either of the template arguments are empty classes, then the
&quot;empty member optimisation&quot; is applied to compress the
size of the pair.</p>

<pre>template &lt;class T1, class T2&gt;
class compressed_pair
{
public:
	typedef T1                                                 first_type;
	typedef T2                                                 second_type;
	typedef typename call_traits&lt;first_type&gt;::param_type       first_param_type;
	typedef typename call_traits&lt;second_type&gt;::param_type      second_param_type;
	typedef typename call_traits&lt;first_type&gt;::reference        first_reference;
	typedef typename call_traits&lt;second_type&gt;::reference       second_reference;
	typedef typename call_traits&lt;first_type&gt;::const_reference  first_const_reference;
	typedef typename call_traits&lt;second_type&gt;::const_reference second_const_reference;

	         compressed_pair() : base() {}
	         compressed_pair(first_param_type x, second_param_type y);
	explicit compressed_pair(first_param_type x);
	explicit compressed_pair(second_param_type y);

	first_reference       first();
	first_const_reference first() const;

	second_reference       second();
	second_const_reference second() const;

	void swap(compressed_pair&amp; y);
};</pre>

<p>The two members of the pair can be accessed using the member
functions first() and second(). Note that not all member
functions can be instantiated for all template parameter types.
In particular compressed_pair can be instantiated for reference
and array types, however in these cases the range of constructors
that can be used are limited. If types T1 and T2 are the same
type, then there is only one version of the single-argument
constructor, and this constructor initialises both values in the
pair to the passed value.</p>

<p>Note that compressed_pair can not be instantiated if either of
the template arguments is an enumerator type, unless there is
compiler support for boost::is_enum, or if boost::is_enum is
specialised for the enumerator type.</p>

<p>Finally, compressed_pair requires compiler support for partial
specialisation of class templates - without that support
compressed_pair behaves just like std::pair.</p>

<hr>

<p>Revised 08 March 2000</p>

<p>© Copyright boost.org 2000. Permission to copy, use, modify,
sell and distribute this document is granted provided this
copyright notice appears in all copies. This document is provided
&quot;as is&quot; without express or implied warranty, and with
no claim as to its suitability for any purpose.</p>

<p>Based on contributions by Steve Cleary, Beman Dawes, Howard
Hinnant and John Maddock.</p>

<p>Maintained by <a href="mailto:John_Maddock@compuserve.com">John
Maddock</a>, the latest version of this file can be found at <a
href="http://www.boost.org">www.boost.org</a>, and the boost
discussion list at <a href="http://www.egroups.com/list/boost">www.egroups.com/list/boost</a>.</p>

<p>&nbsp;</p>
</body>
</html>
