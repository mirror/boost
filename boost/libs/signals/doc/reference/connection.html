<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Boost.Signals: Header &lt;boost/signals/connection.hpp&gt;</title>
  </head>

  <body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080">

  <h1><IMG SRC="../../../../c++boost.gif" WIDTH="276" HEIGHT="86" ALT="Boost">Boost.Signals: Header <code>&lt;<a href="../../../../boost/signals/connection.hpp">boost/signals/connection.hpp</a>&gt;</code></h1>

<h2>Header <code>&lt;<a href="../../../../boost/signals/connection.hpp">boost/signals/connection.hpp</a>&gt;</code> synopsis</h2>

<pre>
<b>namespace</b> boost {
  <b>namespace</b> signals {
    class <a href="#connection_class">connection</a>;
    class <a href="#scoped_connection_class">scoped_connection</a>;

    <a href="#swap_free"><b>void</b> swap(connection&amp, connection&amp;)</a>;
    <a href="#scoped_swap_free"><b>void</b> swap(scoped_connection&amp, scoped_connection&amp;)</a>;
  }
}
</pre>

<a name="connection_class"><h2>Class <code>connection</code> synopsis</h2></a>
<p>The <code>connection</code> class represents a connection between a <a href="Signal.html">Signal</a> and a <a href="Slot.html">Slot</a>. It is a lightweight object that has the ability to query whether the signal and slot are currently connected, and to disconnect the signal and slot. It is always safe to query or disconnect a <code>connection</code>.

<pre>
<b>namespace</b> boost {
  <b>namespace</b> signals {
    <b>class</b> connection : <em>// Class connection is <a href="http://www.sgi.com/tech/stl/LessThanComparable.html">LessThanComparable</a> and <a href="http://www.sgi.com/tech/stl/EqualityComparable.html">EqualityComparable</a></em>
      <b>private</b> less_than_comparable1&lt;connection&gt;, <em>// Exposition only.</em>
      <b>private</b> equality_comparable1&lt;connection&gt;<em>// Exposition only.</em>
    {
    <b>public</b>:
      <a href="#default_constructor">connection()</a>;
      <a href="#copy_constructor">connection(<b>const</b> connection&amp;)</a>;
      <a href="#destructor">~connection()</a>;
  
      <a href="#disconnect"><b>void</b> disconnect() <b>const</b></a>;
      <a href="#connected"><b>bool</b> connected() <b>const</b></a>;

      <a href="#copy_assignment">connection& <b>operator=</b>(<b>const</b> connection&amp;)</a>;
      <a href="#swap_member"><b>void</b> swap(connection&amp;)</a>;

      <a href="#equality"><b>bool</b> <b>operator==</b>(<b>const</b> connection& other) <b>const</b></a>;
      <a href="#less_than"><b>bool</b> <b>operator&lt;</b>(<b>const</b> connection& other) <b>const</b></a>;
    };
  }
}
</pre>

<h2>Class <code>connection</code> members</h2>

<hr><h3>Constructors</h3>
<p><a name="default_constructor"><code>connection();</code></a>
<ul>
  <li><b>Effects</b>: Sets the currently represented connection to the NULL connection.</li>
  <li><b>Postconditions</b>: <code>!<b>this</b>-&gt;connected()</code>
  <li><b>Throws</b>: will not throw.</li>
</ul>

<p><a name="copy_constructor"><code>connection(<b>const</b> connection&amp; other);</code></a>
<ul>
  <li><b>Effects</b>: <code>this</code> references the connection referenced by <code>other</code>.</li>
  <li><b>Throws</b>: will not throw.</li>
</ul>

<hr><h3>Destructor</h3>

<p><a name="destructor">~<code>connection();</code></a>
<ul>
  <li><b>Effects</b>: none.</li>
</ul>

<hr><h3>Connection Management</h3>
<p><a name="disconnect"><code><b>void</b> disconnect() <b>const</b>;</code></a>
<ul>
  <li><b>Effects</b>: if <code><b>this-&gt;</b>is_connected()</code>, disconnects the signal and slot referenced by <code>this</code>; otherwise, this operation is a no-op.</li>
  <li><b>Postconditions</b>: <code><b>!this</b>-&gt;is_connected()</code></li>
</ul>

<p><a name="connected"><code><b>bool</b> connected() <b>const</b>;</code></a>
<ul>
  <li><b>Returns</b>: <code><b>true</b></code> if <code>this</code> references a non-NULL connection that is still active (connected), and <code><b>false</b></code> otherwise.</li>
  <li><b>Throws</b>: will not throw.</li>
</ul>

<hr><h3>Assignment and Swap</h3>
<p><a name="copy_assignment"><code>connection&amp; <b>operator=</b>(<b>const</b> connection&amp; other);</code></a>
<ul>
  <li><b>Effects</b>: <code>connection(other).swap(*<b>this</b>);</code>
  <li><b>Returns</b>: <code>*<b>this</b></code></li>
</ul>

<p><a name="swap_member"><code><b>void</b> swap(connection&amp; other);</code></a>
<ul>
  <li><b>Effects</b>: swaps the connections referenced in <code><b>this</b></code> and <code>other</code>.</li>
  <li><b>Throws</b>: will not throw.</li>
</ul>

<hr><h3>Comparison</h3>
<p><a name="equality"><code><b>bool</b> <b>operator==</b>(<b>const</b> connection& other) <b>const</b>;</code></a>
<ul>
  <li><b>Returns</b>: true if <code><b>this</b></code> and <code>other</code> reference the same connection or both reference the NULL connection, and <code><b>false</b></code> otherwise.</li>
  <li><b>Throws</b>: will not throw.</li>
</ul>

<p><a name="less_than"><code><b>bool</b> <b>operator&lt;</b>(<b>const</b> connection& other) <b>const</b>;</code></a>
<ul>
  <li><b>Returns</b>: <code><b>true</b></code> if the connection referenced by <code><b>this</b></code> precedes the connection referenced by <code>other</code> based on some implementation-defined ordering, and <code><b>false</b></code> otherwise. </li>
  <li><b>Throws</b>: will not throw.</li>
</ul>

<a name="scoped_connection_class"><h2>Class <code>scoped_connection</code> synopsis</h2></a>

<p>The <code>scoped_connection</code> class is a connection that will
be automatically disconnected when the <code>scoped_connection</code>
instance is destructed.

<pre>
<b>namespace</b> boost {
  <b>namespace</b> signals {
    <b>class</b> scoped_connection : <b>public</b> connection
    {
    <b>public</b>:
      <a href="#scoped_default_constructor">scoped_connection()</a>;
      <a href="#scoped_copy_constructor">scoped_connection(<b>const</b> scoped_connection&amp;)</a>;
      <a href="#scoped_copy_connection_constructor">scoped_connection(<b>const</b> connection&amp;)</a>;
      <a href="#scoped_destructor">~scoped_connection()</a>;

      <a href="#scoped_copy_assignment">connection& <b>operator=</b>(<b>const</b> scoped_connection&amp;)</a>;
      <a href="#scoped_copy_connection_assignment">connection& <b>operator=</b>(<b>const</b> connection&amp;)</a>;
      <a href="#scoped_swap_member"><b>void</b> swap(connection&amp;)</a>;
    };
  }
}
</pre>

<h2>Class <code>scoped_connection</code> members</h2>

<hr><h3>Constructors</h3>
<p><a name="scoped_default_constructor"><code>scoped_connection();</code></a>
<ul>
  <li><b>Effects</b>: Sets the currently represented connection to the NULL connection.</li>
  <li><b>Postconditions</b>: <code>!<b>this</b>-&gt;connected()</code>
  <li><b>Throws</b>: will not throw.</li>
</ul>

<p><a name="scoped_copy_constructor"><code>scoped_connection(<b>const</b> scoped_connection&amp; other);</code></a>
<ul>
  <li><b>Effects</b>: <code>this</code> references the connection referenced by <code>other</code>.</li>
  <li><b>Throws</b>: will not throw.</li>
</ul>

<p><a name="scoped_copy_connection_constructor"><code>scoped_connection(<b>const</b> connection&amp; other);</code></a>
<ul>
  <li><b>Effects</b>: <code>this</code> references the connection referenced by <code>other</code>.</li>
  <li><b>Throws</b>: will not throw.</li>
</ul>

<hr><h3>Destructor</h3>

<p><a name="destructor">~<code>connection();</code></a>
<ul>
  <li><b>Effects</b>: <code><b>this</b>-&gt;disconnect()</li>
</ul>

<hr><h3>Assignment and Swap</h3>
<p><a name="scoped_copy_assignment"><code>scoped_connection&amp; <b>operator=</b>(<b>const</b> scoped_connection&amp; other);</code></a>
<ul>
  <li><b>Effects</b>: <code>scoped_connection(other).swap(*<b>this</b>);</code>
  <li><b>Returns</b>: <code>*<b>this</b></code></li>
</ul>

<p><a name="scoped_copy_connection_assignment"><code>scoped_connection&amp; <b>operator=</b>(<b>const</b> connection&amp; other);</code></a>
<ul>
  <li><b>Effects</b>: <code>scoped_connection(other).swap(*<b>this</b>);</code>
  <li><b>Returns</b>: <code>*<b>this</b></code></li>
</ul>

<p><a name="scoped_swap_member"><code><b>void</b> swap(scoped_connection&amp; other);</code></a>
<ul>
  <li><b>Effects</b>: swaps the connections referenced in <code><b>this</b></code> and <code>other</code>.</li>
  <li><b>Throws</b>: will not throw.</li>
</ul>

<hr><h2>Free Functions</h2>
<p><a name="swap_free"><code><b>void</b> swap(connection&amp c1, connection&amp; c2);</code></a>
<ul>
  <li><b>Effects</b>: <code>c1.swap(c2)</code>.</li>
  <li><b>Throws</b>: will not throw.</li>
</ul>

<p><a name="scoped_swap_free"><code><b>void</b> swap(scoped_connection&amp c1, scoped_connection&amp; c2);</code></a>
<ul>
  <li><b>Effects</b>: <code>c1.swap(c2)</code>.</li>
  <li><b>Throws</b>: will not throw.</li>
</ul>

    <hr>
    <address><a href="mailto:gregod@cs.rpi.edu">Douglas Gregor</a></address>
<!-- Created: Fri Jul 13 10:57:20 EDT 2001 -->
<!-- hhmts start -->
Last modified: Wed Mar  6 19:04:00 EST 2002
<!-- hhmts end -->
  </body>
</html>