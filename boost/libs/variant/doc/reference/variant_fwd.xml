<?xml version="1.0" encoding="utf-8" ?> 
<header name="boost/variant/variant_fwd.hpp">
  <section id="variant.header.variant_fwd">
    <para>Provides a forward declaration of the
      <code><classname>boost::variant</classname></code> class template. Also
      defines the following preprocessor symbols:</para>
      
    <section id="variant.macro.BOOST_VARIANT_LIMIT_TYPES">
      <title>BOOST_VARIANT_LIMIT_TYPES</title>

      <para>Preprocessor macro. Expands to the length of the template
      parameter list for
      <code><classname alt="boost::variant">variant</classname></code>.</para>
      
      <para><emphasis role="bold">Note</emphasis>: Conforming implementations
      of <code>variant</code> must allow at least ten bounded types. That is,
      <code>BOOST_VARIANT_LIMIT_TYPES &gt;= 10</code> must be
      <code>true</code>.</para>
    </section>

    <section id="variant.macro.BOOST_VARIANT_ENUM_PARAMS">
      <title>BOOST_VARIANT_ENUM_PARAMS(<emphasis>param</emphasis>)</title>

      <para>Preprocessor macro. Expands to a comma-separated sequence of length
      <code><link linkend="variant.macro.BOOST_VARIANT_LIMIT_TYPES">BOOST_VARIANT_LIMIT_TYPES</link></code>,
      where each element in the sequence consists of the concatenation of
      <emphasis>param</emphasis> with its zero-based index into the
      sequence. That is, <code>param ## 0, param ## 1, ..., param ## BOOST_VARIANT_LIMIT_TYPES - 1</code>.</para>

      <para><emphasis role="bold">Rationale</emphasis>: This macro greatly
      simplifies for the user the process of declaring
      <code><classname alt="boost::variant">variant</classname></code> types
      in function templates or explicit partial specializations of class
      templates, as shown in the following examples:</para>

<programlisting>template &lt;typename T&gt; class some_class;

// example: <emphasis>explicit partial specialization</emphasis>
template &lt;BOOST_VARIANT_ENUM_PARAMS(typename T)&gt;
class some_class&lt; boost::variant&lt;BOOST_VARIANT_ENUM_PARAMS(T)&gt; &gt;;

// example: <emphasis>function template</emphasis>
template &lt;BOOST_VARIANT_ENUM_PARAMS(typename T)&gt;
void f(const boost::variant&lt;BOOST_VARIANT_ENUM_PARAMS(T)&gt; &amp;);</programlisting>

    </section>

    <section id="variant.macro.BOOST_VARIANT_ENUM_SHIFTED_PARAMS">
      <title>BOOST_VARIANT_ENUM_SHIFTED_PARAMS(<emphasis>param</emphasis>)</title>

      <para>Preprocessor macro. Expands to a comma-separated sequence of length
      <code><link linkend="variant.macro.BOOST_VARIANT_LIMIT_TYPES">BOOST_VARIANT_LIMIT_TYPES</link> - 1</code>,
      where each element in the sequence consists of the concatenation of
      <emphasis>param</emphasis> with its one-based index into the
      sequence. That is, <code>param ## 1, ..., param ## BOOST_VARIANT_LIMIT_TYPES - 1</code>.</para>

      <para><emphasis role="bold">Note</emphasis>: This macro results in the
      same expansion as <code>BOOST_VARIANT_ENUM_PARAMS</code> -- but without
      the first term.</para>
    </section>


    <section id="variant.macro.BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT">
      <title>BOOST_VARIANT_NO_TYPE_SEQUENCE_SUPPORT</title>

      <para>Configuration preprocessor symbol. Defined only if the
      <code><classname>boost::variant</classname>&lt;
      <emphasis>type-sequence</emphasis> &gt;</code> syntax is not supported
      for some reason on the current platform or compiler.</para>
    </section>
  </section>
</header>