<?xml version="1.0" standalone="yes"?>
<!-- Copyright (c) 2001-2005 CrystalClear Software, Inc.
     Subject to the Boost Software License, Version 1.0. 
     (See accompanying file LICENSE-1.0 or  http://www.boost.org/LICENSE-1.0)
-->
<!-- date source directory processed: 2005-Feb-1 -->
<section id="date_time_reference">
<title>Date Time Reference</title>
  <header name="boost/date_time/adjust_functors.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="day_functor">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>Functor to iterate a fixed number of days. </purpose>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="get_neg_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="f">
              <paramtype>int</paramtype>
            </parameter>
          </constructor>
        </class>
        <class name="month_functor">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>Provides calculation to find next nth month given a date. </purpose>
          <description>
            <para>This adjustment function provides the logic for 'month-based' advancement on a ymd based calendar. The policy it uses to handle the non existant end of month days is to back up to the last day of the month. Also, if the starting date is the last day of a month, this functor will attempt to adjust to the end of the month. </para>
          </description>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <typedef name="cal_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="ymd_type">
            <type>cal_type::ymd_type</type>
          </typedef>
          <typedef name="day_type">
            <type>cal_type::day_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="get_neg_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <purpose>Returns a negative duration_type. </purpose>
            </method>
          </method-group>
          <constructor>
            <parameter name="f">
              <paramtype>int</paramtype>
            </parameter>
          </constructor>
        </class>
        <class name="week_functor">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>Functor to iterate a over weeks. </purpose>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="get_neg_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="f">
              <paramtype>int</paramtype>
            </parameter>
          </constructor>
        </class>
        <class name="year_functor">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>Functor to iterate by a year adjusting for leap years. </purpose>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="get_neg_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="f">
              <paramtype>int</paramtype>
            </parameter>
          </constructor>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/c_local_time_adjustor.hpp">
    <para>Time adjustment calculations based on machine</para>
    <namespace name="boost">
      <namespace name="date_time">
        <class name="c_local_adjustor">
          <template>
      <template-type-parameter name="time_type"/>
    </template>
          <purpose>Adjust to / from utc using the C API. </purpose>
          <description>
            <para>Warning!!! This class assumes that timezone settings of the machine are correct. This can be a very dangerous assumption. </para>
          </description>
          <typedef name="time_duration_type">
            <type>time_type::time_duration_type</type>
          </typedef>
          <typedef name="date_type">
            <type>time_type::date_type</type>
          </typedef>
          <typedef name="date_duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <method-group name="public static functions">
            <method name="utc_to_local" cv="">
              <type>time_type</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
              <purpose>Convert a utc time to local time. </purpose>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/c_time.hpp">
    <para>Provide workarounds related to the ctime header</para>
    <namespace name="std"/>
  </header>
  <header name="boost/date_time/compiler_config.hpp">
    <namespace name="std"/>
  </header>
  <header name="boost/date_time/constrained_value.hpp">
    <namespace name="boost">
      <namespace name="CV">
        <class name="constrained_value">
          <template>
      <template-type-parameter name="value_policies"/>
    </template>
          <purpose>A template to specify a constrained basic value type. </purpose>
          <description>
            <para>This template provides a quick way to generate an integer type with a constrained range. The type provides for the ability to specify the min, max, and and error handling policy.</para>
            <para><emphasis role="bold">value policies</emphasis>  A class that provides the range limits via the min and max functions as well as a function on_error that determines how errors are handled. A common strategy would be to assert or throw and exception. The on_error is passed both the current value and the new value that is in error. </para>
          </description>
          <typedef name="value_type">
            <type>value_policies::value_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="conversion-operator" cv="const">
              <type>value_type</type>
              <purpose>Coerce into the representation type. </purpose>
            </method>
          </method-group>
          <constructor>
            <parameter name="value">
              <paramtype>value_type</paramtype>
            </parameter>
          </constructor>
          <copy-assignment>
            <parameter name="v">
              <paramtype>value_type</paramtype>
            </parameter>
          </copy-assignment>
          <method-group name="public static functions">
            <method name="BOOST_PREVENT_MACRO_SUBSTITUTION" cv="">
              <type>value_type max</type>
              <purpose>Return the max allowed value (traits method). </purpose>
            </method>
            <method name="BOOST_PREVENT_MACRO_SUBSTITUTION" cv="">
              <type>value_type min</type>
              <purpose>Return the min allowed value (traits method). </purpose>
            </method>
          </method-group>
          <method-group name="private member functions">
            <method name="assign" cv="">
              <type>void</type>
              <parameter name="value">
                <paramtype>value_type</paramtype>
              </parameter>
            </method>
          </method-group>
        </class>
        <class name="simple_exception_policy">
          <template>
      <template-type-parameter name="rep_type"/>
      <template-nontype-parameter name="min_value"><type>rep_type</type></template-nontype-parameter>
      <template-nontype-parameter name="max_value"><type>rep_type</type></template-nontype-parameter>
      <template-type-parameter name="exception_type"/>
    </template>
          <purpose>Template to shortcut the constrained_value policy creation process. </purpose>
          <typedef name="value_type">
            <type>rep_type</type>
          </typedef>
          <method-group name="public static functions">
            <method name="BOOST_PREVENT_MACRO_SUBSTITUTION" cv="">
              <type>rep_type min</type>
            </method>
            <method name="BOOST_PREVENT_MACRO_SUBSTITUTION" cv="">
              <type>rep_type max</type>
            </method>
            <method name="on_error" cv="">
              <type>void</type>
              <parameter name="">
                <paramtype>rep_type</paramtype>
              </parameter>
              <parameter name="">
                <paramtype>rep_type</paramtype>
              </parameter>
              <parameter name="">
                <paramtype>violation_enum</paramtype>
              </parameter>
            </method>
          </method-group>
        </class>
        <enum name="violation_enum">
          <enumvalue name="min_violation"/>
          <enumvalue name="max_violation"/>
          <purpose>Represent a min or max violation type. </purpose>
        </enum>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="date">
          <template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="calendar"/>
      <template-type-parameter name="duration_type_"/>
    </template>
          <purpose>Representation of timepoint at the one day level resolution. </purpose>
          <description>
            <para>The date template represents an interface shell for a date class that is based on a year-month-day system such as the gregorian or iso systems. It provides basic operations to enable calculation and comparisons.</para>
            <para><emphasis role="bold">Theory</emphasis> </para>
            <para>This date representation fundamentally departs from the C tm struct approach. The goal for this type is to provide efficient date operations (add, subtract) and storage (minimize space to represent) in a concrete class. Thus, the date uses a count internally to represent a particular date. The calendar parameter defines the policies for converting the the year-month-day and internal counted form here. Applications that need to perform heavy formatting of the same date repeatedly will perform better by using the year-month-day representation.</para>
            <para>Internally the date uses a day number to represent the date. This is a monotonic time representation. This representation allows for fast comparison as well as simplifying the creation of writing numeric operations. Essentially, the internal day number is like adjusted julian day. The adjustment is determined by the Epoch date which is represented as day 1 of the calendar. Day 0 is reserved for negative infinity so that any actual date is automatically greater than negative infinity. When a date is constructed from a date or formatted for output, the appropriate conversions are applied to create the year, month, day representations. </para>
          </description>
          <typedef name="date_type">
            <type>T</type>
          </typedef>
          <typedef name="calendar_type">
            <type>calendar</type>
          </typedef>
          <typedef name="traits_type">
            <type>calendar::date_traits_type</type>
          </typedef>
          <typedef name="duration_type">
            <type>duration_type_</type>
          </typedef>
          <typedef name="year_type">
            <type>calendar::year_type</type>
          </typedef>
          <typedef name="month_type">
            <type>calendar::month_type</type>
          </typedef>
          <typedef name="day_type">
            <type>calendar::day_type</type>
          </typedef>
          <typedef name="ymd_type">
            <type>calendar::ymd_type</type>
          </typedef>
          <typedef name="date_rep_type">
            <type>calendar::date_rep_type</type>
          </typedef>
          <typedef name="date_int_type">
            <type>calendar::date_int_type</type>
          </typedef>
          <typedef name="day_of_week_type">
            <type>calendar::day_of_week_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="year" cv="const">
              <type>year_type</type>
            </method>
            <method name="month" cv="const">
              <type>month_type</type>
            </method>
            <method name="day" cv="const">
              <type>day_type</type>
            </method>
            <method name="day_of_week" cv="const">
              <type>day_of_week_type</type>
            </method>
            <method name="year_month_day" cv="const">
              <type>ymd_type</type>
            </method>
            <method name="operator&lt;" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="is_special" cv="const">
              <type>bool</type>
              <purpose>check to see if date is a special value </purpose>
            </method>
            <method name="is_not_a_date" cv="const">
              <type>bool</type>
              <purpose>check to see if date is not a value </purpose>
            </method>
            <method name="is_infinity" cv="const">
              <type>bool</type>
              <purpose>check to see if date is one of the infinity values </purpose>
            </method>
            <method name="is_pos_infinity" cv="const">
              <type>bool</type>
              <purpose>check to see if date is greater than all possible dates </purpose>
            </method>
            <method name="is_neg_infinity" cv="const">
              <type>bool</type>
              <purpose>check to see if date is greater than all possible dates </purpose>
            </method>
            <method name="as_special" cv="const">
              <type>special_values</type>
              <purpose>return as a special value or a not_special if a normal date </purpose>
            </method>
            <method name="operator-" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-" cv="const">
              <type>date_type</type>
              <parameter name="dd">
                <paramtype>const duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-=" cv="">
              <type>date_type</type>
              <parameter name="dd">
                <paramtype>const duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="day_count" cv="const">
              <type>date_rep_type</type>
            </method>
            <method name="operator+" cv="const">
              <type>date_type</type>
              <parameter name="dd">
                <paramtype>const duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator+=" cv="">
              <type>date_type</type>
              <parameter name="dd">
                <paramtype>const duration_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="y">
              <paramtype>year_type</paramtype>
            </parameter>
            <parameter name="m">
              <paramtype>month_type</paramtype>
            </parameter>
            <parameter name="d">
              <paramtype>day_type</paramtype>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="ymd">
              <paramtype>const ymd_type &amp;</paramtype>
            </parameter>
          </constructor>
          <method-group name="protected member functions"/>
          <constructor>
            <parameter name="days">
              <paramtype>date_int_type</paramtype>
            </parameter>
            <description>
              <para>This is a private constructor which allows for the creation of new dates. It is not exposed to users since that would require class users to understand the inner workings of the date class. </para>
            </description>
          </constructor>
          <constructor>
            <parameter name="days">
              <paramtype>date_rep_type</paramtype>
            </parameter>
          </constructor>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_clock_device.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="day_clock">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>A clock providing day level services based on C time_t capabilities. </purpose>
          <description>
            <para>This clock uses Posix interfaces as its implementation and hence uses the timezone settings of the operating system. Incorrect user settings will result in incorrect results for the calls to local_day. </para>
          </description>
          <typedef name="ymd_type">
            <type>date_type::ymd_type</type>
          </typedef>
          <method-group name="public static functions">
            <method name="local_day" cv="">
              <type>date_type</type>
              <purpose>Get the local day as a date type. </purpose>
            </method>
            <method name="local_day_ymd" cv="">
              <type>date_type::ymd_type</type>
              <purpose>Get the local day as a ymd_type. </purpose>
            </method>
            <method name="universal_day_ymd" cv="">
              <type>date_type::ymd_type</type>
              <purpose>Get the current day in universal date as a ymd_type. </purpose>
            </method>
            <method name="universal_day" cv="">
              <type>date_type</type>
              <purpose>Get the UTC day as a date type. </purpose>
            </method>
          </method-group>
          <method-group name="private static functions">
            <method name="get_local_time" cv="">
              <type>::std::tm *</type>
            </method>
            <method name="get_universal_time" cv="">
              <type>::std::tm *</type>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_defs.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <enum name="weekdays">
          <enumvalue name="Sunday"/>
          <enumvalue name="Monday"/>
          <enumvalue name="Tuesday"/>
          <enumvalue name="Wednesday"/>
          <enumvalue name="Thursday"/>
          <enumvalue name="Friday"/>
          <enumvalue name="Saturday"/>
          <purpose>An enumeration of weekday names. </purpose>
        </enum>
        <enum name="months_of_year">
          <enumvalue name="Jan">
            <default>1</default>
          </enumvalue>
          <enumvalue name="Feb"/>
          <enumvalue name="Mar"/>
          <enumvalue name="Apr"/>
          <enumvalue name="May"/>
          <enumvalue name="Jun"/>
          <enumvalue name="Jul"/>
          <enumvalue name="Aug"/>
          <enumvalue name="Sep"/>
          <enumvalue name="Oct"/>
          <enumvalue name="Nov"/>
          <enumvalue name="Dec"/>
          <enumvalue name="NotAMonth"/>
          <enumvalue name="NumMonths"/>
          <purpose>Simple enum to allow for nice programming with Jan, Feb, etc. </purpose>
        </enum>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_duration.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="date_duration">
          <template>
      <template-type-parameter name="duration_rep_traits"/>
    </template>
          <purpose>Duration type with date level resolution. </purpose>
          <typedef name="duration_rep_type">
            <type>duration_rep_traits::int_type</type>
          </typedef>
          <typedef name="duration_rep">
            <type>duration_rep_traits::impl_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_rep" cv="const">
              <type>duration_rep</type>
              <purpose>returns days_ as it's instantiated type - used for streaming </purpose>
            </method>
            <method name="is_special" cv="const">
              <type>bool</type>
            </method>
            <method name="days" cv="const">
              <type>duration_rep_type</type>
              <purpose>returns days as value, not object. </purpose>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>date_duration</classname> &amp;</paramtype>
              </parameter>
              <purpose>Equality. </purpose>
            </method>
            <method name="operator&lt;" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>date_duration</classname> &amp;</paramtype>
              </parameter>
              <purpose>Less. </purpose>
            </method>
            <method name="operator-=" cv="">
              <type>
                <classname>date_duration</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>date_duration</classname> &amp;</paramtype>
              </parameter>
              <purpose>Subtract another duration -- result is signed. </purpose>
            </method>
            <method name="operator+=" cv="">
              <type>
                <classname>date_duration</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>date_duration</classname> &amp;</paramtype>
              </parameter>
              <purpose>Add a duration -- result is signed. </purpose>
            </method>
            <method name="operator-" cv="const">
              <type>
                <classname>date_duration</classname>
              </type>
              <purpose>unary- Allows for dd = -date_duration(2); -&gt; dd == -2 </purpose>
            </method>
            <method name="operator/=" cv="">
              <type><classname>date_duration</classname>&lt; duration_rep_traits &gt;</type>
              <parameter name="divisor">
                <paramtype>int</paramtype>
              </parameter>
              <purpose>Division operations on a duration with an integer. </purpose>
            </method>
            <method name="operator/" cv="">
              <type><classname>date_duration</classname>&lt; duration_rep_traits &gt;</type>
              <parameter name="divisor">
                <paramtype>int</paramtype>
              </parameter>
            </method>
            <method name="is_negative" cv="const">
              <type>bool</type>
              <purpose>return sign information </purpose>
            </method>
          </method-group>
          <constructor>
            <parameter name="day_count">
              <paramtype>duration_rep</paramtype>
            </parameter>
            <purpose>Construct from a day count. </purpose>
          </constructor>
          <constructor>
            <parameter name="sv">
              <paramtype>special_values</paramtype>
            </parameter>
            <description>
              <para>construct from special_values - only works when instantiated with duration_traits_adapted </para>
            </description>
          </constructor>
          <constructor>
            <parameter name="other">
              <paramtype>const <classname>date_duration</classname>&lt; duration_rep_traits &gt; &amp;</paramtype>
            </parameter>
            <purpose>Construct from another date_duration (Copy Constructor). </purpose>
          </constructor>
          <method-group name="public static functions">
            <method name="unit" cv="">
              <type>
                <classname>date_duration</classname>
              </type>
              <purpose>Returns the smallest duration -- used by to calculate 'end'. </purpose>
            </method>
          </method-group>
        </class>
        <struct name="duration_traits_long">
          <description>
            <para>Struct for instantiating date_duration with <emphasis role="bold">NO</emphasis>  special values functionality. Allows for transparent implementation of either date_duration&lt;long&gt; or date_duration&lt;int_adapter&lt;long&gt; &gt; </para>
          </description>
          <typedef name="int_type">
            <type>long</type>
          </typedef>
          <typedef name="impl_type">
            <type>long</type>
          </typedef>
          <method-group name="public static functions">
            <method name="as_number" cv="">
              <type>int_type</type>
              <parameter name="i">
                <paramtype>impl_type</paramtype>
              </parameter>
            </method>
          </method-group>
        </struct>
        <struct name="duration_traits_adapted">
          <description>
            <para>Struct for instantiating date_duration <emphasis role="bold">WITH</emphasis>  special values functionality. Allows for transparent implementation of either date_duration&lt;long&gt; or date_duration&lt;int_adapter&lt;long&gt; &gt; </para>
          </description>
          <typedef name="int_type">
            <type>long</type>
          </typedef>
          <typedef name="impl_type">
            <type><classname>boost::date_time::int_adapter</classname>&lt; long &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="as_number" cv="">
              <type>int_type</type>
              <parameter name="i">
                <paramtype>
                  <classname>impl_type</classname>
                </paramtype>
              </parameter>
            </method>
          </method-group>
        </struct>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_duration_types.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="weeks_duration">
          <template>
      <template-type-parameter name="duration_config"/>
    </template>
          <inherit access="public">boost::date_time::date_duration&lt; duration_config &gt;</inherit>
          <purpose>Additional duration type that represents a number of n*7 days. </purpose>
          <method-group name="public member functions"/>
          <constructor>
            <parameter name="w">
              <paramtype>typename duration_config::impl_type</paramtype>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="sv">
              <paramtype>special_values</paramtype>
            </parameter>
          </constructor>
        </class>
        <class name="months_duration">
          <template>
      <template-type-parameter name="base_config"/>
    </template>
          <purpose>additional duration type that represents a logical month </purpose>
          <description>
            <para>A logical month enables things like: "date(2002,Mar,2) + months(2) -&gt; 2002-May2". If the date is a last day-of-the-month, the result will also be a last-day-of-the-month. </para>
          </description>
          <method-group name="public member functions">
            <method name="number_of_months" cv="const">
              <type>int_rep</type>
            </method>
            <method name="get_neg_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <purpose>returns a negative duration </purpose>
            </method>
            <method name="get_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>months_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator!=" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>months_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator+" cv="const">
              <type>
                <classname>months_type</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>months_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator+=" cv="">
              <type><classname>months_type</classname> &amp;</type>
              <parameter name="rhs">
                <paramtype>const <classname>months_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-" cv="const">
              <type>
                <classname>months_type</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>months_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-=" cv="">
              <type><classname>months_type</classname> &amp;</type>
              <parameter name="rhs">
                <paramtype>const <classname>months_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator *" cv="const">
              <type>
                <classname>months_type</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator *=" cv="">
              <type><classname>months_type</classname> &amp;</type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator/" cv="const">
              <type>
                <classname>months_type</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator/=" cv="">
              <type><classname>months_type</classname> &amp;</type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator+" cv="const">
              <type>
                <classname>months_type</classname>
              </type>
              <parameter name="y">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator+=" cv="">
              <type><classname>months_type</classname> &amp;</type>
              <parameter name="y">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-" cv="const">
              <type>
                <classname>months_type</classname>
              </type>
              <parameter name="y">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-=" cv="">
              <type><classname>months_type</classname> &amp;</type>
              <parameter name="y">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="num">
              <paramtype>int_rep</paramtype>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="sv">
              <paramtype>special_values</paramtype>
            </parameter>
          </constructor>
        </class>
        <class name="years_duration">
          <template>
      <template-type-parameter name="base_config"/>
    </template>
          <purpose>additional duration type that represents a logical year </purpose>
          <description>
            <para>A logical year enables things like: "date(2002,Mar,2) + years(2) -&gt; 2004-Mar-2". If the date is a last day-of-the-month, the result will also be a last-day-of-the-month (ie date(2001-Feb-28) + years(3) -&gt; 2004-Feb-29). </para>
          </description>
          <method-group name="public member functions">
            <method name="number_of_years" cv="const">
              <type>int_rep</type>
            </method>
            <method name="get_neg_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <purpose>returns a negative duration </purpose>
            </method>
            <method name="get_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator!=" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator+" cv="const">
              <type>
                <classname>years_type</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator+=" cv="">
              <type><classname>years_type</classname> &amp;</type>
              <parameter name="rhs">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-" cv="const">
              <type>
                <classname>years_type</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-=" cv="">
              <type><classname>years_type</classname> &amp;</type>
              <parameter name="rhs">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator *" cv="const">
              <type>
                <classname>years_type</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator *=" cv="">
              <type><classname>years_type</classname> &amp;</type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator/" cv="const">
              <type>
                <classname>years_type</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator/=" cv="">
              <type><classname>years_type</classname> &amp;</type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator+" cv="const">
              <type>
                <classname>months_type</classname>
              </type>
              <parameter name="m">
                <paramtype>const <classname>months_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-" cv="const">
              <type>
                <classname>months_type</classname>
              </type>
              <parameter name="m">
                <paramtype>const <classname>months_type</classname> &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="num">
              <paramtype>int_rep</paramtype>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="sv">
              <paramtype>special_values</paramtype>
            </parameter>
          </constructor>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_facet.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="date_facet">
          <template>
      <template-type-parameter name="date_type"/>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="OutItrT"><default>std::ostreambuf_iterator&lt;CharT, std::char_traits&lt;CharT&gt; &gt;</default></template-type-parameter>
    </template>
          <description>
            <para>TODO: ... Format flags are:</para>
            <para>A =&gt; long_weekday_format - Full name Ex: Tuesday a =&gt; short_weekday_format - Three letter abbreviation Ex: Tue B =&gt; long_month_format - Full name Ex: October b =&gt; short_month_format - Three letter abbreviation Ex: Oct x =&gt; standard_format_specifier - defined by the locale Y-%b-%d =&gt; default_date_format - YYYY-Mon-dd</para>
            <para>Default month format == b Default weekday format == a </para>
          </description>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <typedef name="day_of_week_type">
            <type>date_type::day_of_week_type</type>
          </typedef>
          <typedef name="day_type">
            <type>date_type::day_type</type>
          </typedef>
          <typedef name="month_type">
            <type>date_type::month_type</type>
          </typedef>
          <typedef name="period_type">
            <type><classname>boost::date_time::period</classname>&lt; date_type, duration_type &gt;</type>
          </typedef>
          <typedef name="string_type">
            <type>std::basic_string&lt; CharT &gt;</type>
          </typedef>
          <typedef name="char_type">
            <type>CharT</type>
          </typedef>
          <typedef name="period_formatter_type">
            <type><classname>boost::date_time::period_formatter</classname>&lt; CharT &gt;</type>
          </typedef>
          <typedef name="special_values_formatter_type">
            <type><classname>boost::date_time::special_values_formatter</classname>&lt; CharT &gt;</type>
          </typedef>
          <typedef name="input_collection_type">
            <type>std::vector&lt; std::basic_string&lt; CharT &gt; &gt;</type>
          </typedef>
          <typedef name="date_gen_formatter_type">
            <type>date_generator_formatter&lt; date_type, CharT &gt;</type>
          </typedef>
          <typedef name="partial_date_type">
            <type><classname>partial_date</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="nth_kday_type">
            <type><classname>nth_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="first_kday_type">
            <type><classname>first_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="last_kday_type">
            <type><classname>last_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="kday_after_type">
            <type><classname>first_kday_after</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="kday_before_type">
            <type><classname>first_kday_before</classname>&lt; date_type &gt;</type>
          </typedef>
          <method-group name="public member functions">
            <method name="format" cv="">
              <type>void</type>
              <parameter name="format">
                <paramtype>const char_type *const</paramtype>
              </parameter>
            </method>
            <method name="set_iso_format" cv="">
              <type>virtual void</type>
            </method>
            <method name="set_iso_extended_format" cv="">
              <type>virtual void</type>
            </method>
            <method name="month_format" cv="">
              <type>void</type>
              <parameter name="format">
                <paramtype>const char_type *const</paramtype>
              </parameter>
            </method>
            <method name="weekday_format" cv="">
              <type>void</type>
              <parameter name="format">
                <paramtype>const char_type *const</paramtype>
              </parameter>
            </method>
            <method name="period_formatter" cv="">
              <type>void</type>
              <parameter name="period_formatter">
                <paramtype>
                  <classname>period_formatter_type</classname>
                </paramtype>
              </parameter>
            </method>
            <method name="special_value_formatting" cv="">
              <type>void</type>
              <parameter name="svf">
                <paramtype>const <classname>special_values_formatter_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="short_weekday_names" cv="">
              <type>void</type>
              <parameter name="short_weekday_names">
                <paramtype>const input_collection_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="long_weekday_names" cv="">
              <type>void</type>
              <parameter name="long_weekday_names">
                <paramtype>const input_collection_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="short_month_names" cv="">
              <type>void</type>
              <parameter name="short_month_names">
                <paramtype>const input_collection_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="long_month_names" cv="">
              <type>void</type>
              <parameter name="long_month_names">
                <paramtype>const input_collection_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="date_gen_phrase_strings" cv="">
              <type>void</type>
              <parameter name="new_strings">
                <paramtype>const input_collection_type &amp;</paramtype>
              </parameter>
              <parameter name="beg_pos">
                <paramtype>typename date_gen_formatter_type::phrase_elements</paramtype>
                <default>date_gen_formatter_type::first</default>
              </parameter>
            </method>
            <method name="put" cv="const">
              <type>OutItrT</type>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="fill_char">
                <paramtype>char_type</paramtype>
              </parameter>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="put" cv="const">
              <type>OutItrT</type>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="fill_char">
                <paramtype>char_type</paramtype>
              </parameter>
              <parameter name="m">
                <paramtype>const month_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="put" cv="const">
              <type>OutItrT</type>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="fill_char">
                <paramtype>char_type</paramtype>
              </parameter>
              <parameter name="day">
                <paramtype>const day_type &amp;</paramtype>
              </parameter>
              <purpose>puts the day of month </purpose>
            </method>
            <method name="put" cv="const">
              <type>OutItrT</type>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="fill_char">
                <paramtype>char_type</paramtype>
              </parameter>
              <parameter name="dow">
                <paramtype>const day_of_week_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="put" cv="const">
              <type>OutItrT</type>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="fill_char">
                <paramtype>char_type</paramtype>
              </parameter>
              <parameter name="p">
                <paramtype>const <classname>period_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="put" cv="const">
              <type>OutItrT</type>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="fill_char">
                <paramtype>char_type</paramtype>
              </parameter>
              <parameter name="pd">
                <paramtype>const <classname>partial_date_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="put" cv="const">
              <type>OutItrT</type>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="fill_char">
                <paramtype>char_type</paramtype>
              </parameter>
              <parameter name="nkd">
                <paramtype>const <classname>nth_kday_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="put" cv="const">
              <type>OutItrT</type>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="fill_char">
                <paramtype>char_type</paramtype>
              </parameter>
              <parameter name="fkd">
                <paramtype>const <classname>first_kday_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="put" cv="const">
              <type>OutItrT</type>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="fill_char">
                <paramtype>char_type</paramtype>
              </parameter>
              <parameter name="lkd">
                <paramtype>const <classname>last_kday_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="put" cv="const">
              <type>OutItrT</type>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="fill_char">
                <paramtype>char_type</paramtype>
              </parameter>
              <parameter name="fkb">
                <paramtype>const <classname>kday_before_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="put" cv="const">
              <type>OutItrT</type>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="fill_char">
                <paramtype>char_type</paramtype>
              </parameter>
              <parameter name="fka">
                <paramtype>const <classname>kday_after_type</classname> &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="a_ref">
              <paramtype>::size_t</paramtype>
              <default>0</default>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="format">
              <paramtype>const char_type *</paramtype>
            </parameter>
            <parameter name="short_month_names">
              <paramtype>const input_collection_type &amp;</paramtype>
            </parameter>
            <parameter name="ref_count">
              <paramtype>::size_t</paramtype>
              <default>0</default>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="format">
              <paramtype>const char_type *</paramtype>
            </parameter>
            <parameter name="period_formatter">
              <paramtype>
                <classname>period_formatter_type</classname>
              </paramtype>
              <default>period_formatter_type()</default>
            </parameter>
            <parameter name="special_values_formatter">
              <paramtype>
                <classname>special_values_formatter_type</classname>
              </paramtype>
              <default>special_values_formatter_type()</default>
            </parameter>
            <parameter name="dg_formatter">
              <paramtype>date_gen_formatter_type</paramtype>
              <default>date_gen_formatter_type()</default>
            </parameter>
            <parameter name="ref_count">
              <paramtype>::size_t</paramtype>
              <default>0</default>
            </parameter>
          </constructor>
          <data-member name="long_weekday_format" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="short_weekday_format" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="long_month_format" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="short_month_format" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="default_period_separator" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="standard_format_specifier" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="iso_format_specifier" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="iso_format_extended_specifier" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="default_date_format" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="id" specifiers="static">
            <type>std::locale::id</type>
          </data-member>
          <method-group name="protected member functions">
            <method name="do_put_special" cv="const">
              <type>virtual OutItrT</type>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="fill_char">
                <paramtype>char_type</paramtype>
              </parameter>
              <parameter name="sv">
                <paramtype>const boost::date_time::special_values</paramtype>
              </parameter>
            </method>
            <method name="do_put_tm" cv="const">
              <type>virtual OutItrT</type>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="fill_char">
                <paramtype>char_type</paramtype>
              </parameter>
              <parameter name="tm_value">
                <paramtype>const tm &amp;</paramtype>
              </parameter>
              <parameter name="a_format">
                <paramtype>string_type</paramtype>
              </parameter>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_format_simple.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="simple_format">
          <template>
      <template-type-parameter name="charT"/>
    </template>
          <purpose>Class to provide simple basic formatting rules. </purpose>
          <method-group name="public static functions">
            <method name="not_a_date" cv="">
              <type>const charT *</type>
              <purpose>String used printed is date is invalid. </purpose>
            </method>
            <method name="pos_infinity" cv="">
              <type>const charT *</type>
              <purpose>String used to for positive infinity value. </purpose>
            </method>
            <method name="neg_infinity" cv="">
              <type>const charT *</type>
              <purpose>String used to for positive infinity value. </purpose>
            </method>
            <method name="month_format" cv="">
              <type>month_format_spec</type>
              <purpose>Describe month format. </purpose>
            </method>
            <method name="date_order" cv="">
              <type>ymd_order_spec</type>
            </method>
            <method name="has_date_sep_chars" cv="">
              <type>bool</type>
              <purpose>This format uses '-' to separate date elements. </purpose>
            </method>
            <method name="year_sep_char" cv="">
              <type>charT</type>
              <purpose>Char to sep? </purpose>
            </method>
            <method name="month_sep_char" cv="">
              <type>charT</type>
              <purpose>char between year-month </purpose>
            </method>
            <method name="day_sep_char" cv="">
              <type>charT</type>
              <purpose>Char to separate month-day. </purpose>
            </method>
            <method name="hour_sep_char" cv="">
              <type>charT</type>
              <purpose>char between date-hours </purpose>
            </method>
            <method name="minute_sep_char" cv="">
              <type>charT</type>
              <purpose>char between hour and minute </purpose>
            </method>
            <method name="second_sep_char" cv="">
              <type>charT</type>
              <purpose>char for second </purpose>
            </method>
          </method-group>
        </class>
        <class-specialization name="simple_format">
          <template>
    </template>
          <specialization>
            <template-arg>wchar_t</template-arg>
          </specialization>
          <purpose>Specialization of formmating rules for wchar_t. </purpose>
          <method-group name="public static functions">
            <method name="not_a_date" cv="">
              <type>const wchar_t *</type>
              <purpose>String used printed is date is invalid. </purpose>
            </method>
            <method name="pos_infinity" cv="">
              <type>const wchar_t *</type>
              <purpose>String used to for positive infinity value. </purpose>
            </method>
            <method name="neg_infinity" cv="">
              <type>const wchar_t *</type>
              <purpose>String used to for positive infinity value. </purpose>
            </method>
            <method name="month_format" cv="">
              <type>month_format_spec</type>
              <purpose>Describe month format. </purpose>
            </method>
            <method name="date_order" cv="">
              <type>ymd_order_spec</type>
            </method>
            <method name="has_date_sep_chars" cv="">
              <type>bool</type>
              <purpose>This format uses '-' to separate date elements. </purpose>
            </method>
            <method name="year_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>Char to sep? </purpose>
            </method>
            <method name="month_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>char between year-month </purpose>
            </method>
            <method name="day_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>Char to separate month-day. </purpose>
            </method>
            <method name="hour_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>char between date-hours </purpose>
            </method>
            <method name="minute_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>char between hour and minute </purpose>
            </method>
            <method name="second_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>char for second </purpose>
            </method>
          </method-group>
        </class-specialization>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_formatting.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="month_formatter">
          <template>
      <template-type-parameter name="month_type"/>
      <template-type-parameter name="format_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>Formats a month as as string into an ostream. </purpose>
          <method-group name="public static functions">
            <method name="format_month" cv="">
              <type>std::basic_ostream&lt; charT &gt; &amp;</type>
              <parameter name="month">
                <paramtype>const month_type &amp;</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>std::basic_ostream&lt; charT &gt; &amp;</paramtype>
              </parameter>
              <purpose>Formats a month as as string into an ostream. </purpose>
              <description>
                <para>This function demands that month_type provide functions for converting to short and long strings if that capability is used. </para>
              </description>
            </method>
            <method name="format_month" cv="">
              <type>std::ostream &amp;</type>
              <parameter name="month">
                <paramtype>const month_type &amp;</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>std::ostream &amp;</paramtype>
              </parameter>
              <purpose>Formats a month as as string into an ostream. </purpose>
              <description>
                <para>This function demands that month_type provide functions for converting to short and long strings if that capability is used. </para>
              </description>
            </method>
          </method-group>
        </class>
        <class name="ymd_formatter">
          <template>
      <template-type-parameter name="ymd_type"/>
      <template-type-parameter name="format_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>Convert ymd to a standard string formatting policies. </purpose>
          <method-group name="public static functions">
            <method name="ymd_to_string" cv="">
              <type>std::basic_string&lt; charT &gt;</type>
              <parameter name="ymd">
                <paramtype>ymd_type</paramtype>
              </parameter>
              <purpose>Convert ymd to a standard string formatting policies. </purpose>
              <description>
                <para>This is standard code for handling date formatting with year-month-day based date information. This function uses the format_type to control whether the string will contain separator characters, and if so what the character will be. In addtion, it can format the month as either an integer or a string as controled by the formatting policy </para>
              </description>
            </method>
            <method name="ymd_to_string" cv="">
              <type>std::string</type>
              <parameter name="ymd">
                <paramtype>ymd_type</paramtype>
              </parameter>
              <purpose>Convert ymd to a standard string formatting policies. </purpose>
              <description>
                <para>This is standard code for handling date formatting with year-month-day based date information. This function uses the format_type to control whether the string will contain separator characters, and if so what the character will be. In addtion, it can format the month as either an integer or a string as controled by the formatting policy </para>
              </description>
            </method>
          </method-group>
        </class>
        <class name="date_formatter">
          <template>
      <template-type-parameter name="date_type"/>
      <template-type-parameter name="format_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>Convert a date to string using format policies. </purpose>
          <typedef name="string_type">
            <type>std::basic_string&lt; charT &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="date_to_string" cv="">
              <type>string_type</type>
              <parameter name="d">
                <paramtype>date_type</paramtype>
              </parameter>
              <purpose>Convert to a date to standard string using format policies. </purpose>
            </method>
            <method name="date_to_string" cv="">
              <type>std::string</type>
              <parameter name="d">
                <paramtype>date_type</paramtype>
              </parameter>
              <purpose>Convert to a date to standard string using format policies. </purpose>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_formatting_limited.hpp">
    <namespace name="boost">
      <namespace name="date_time"/>
    </namespace>
  </header>
  <header name="boost/date_time/date_formatting_locales.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="ostream_month_formatter">
          <template>
      <template-type-parameter name="facet_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>Formats a month as as string into an ostream. </purpose>
          <typedef name="month_type">
            <type>facet_type::month_type</type>
          </typedef>
          <typedef name="ostream_type">
            <type>std::basic_ostream&lt; charT &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="format_month" cv="">
              <type>void</type>
              <parameter name="month">
                <paramtype>const month_type &amp;</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>ostream_type &amp;</paramtype>
              </parameter>
              <parameter name="f">
                <paramtype>const facet_type &amp;</paramtype>
              </parameter>
              <purpose>Formats a month as as string into an output iterator. </purpose>
            </method>
          </method-group>
        </class>
        <class name="ostream_weekday_formatter">
          <template>
      <template-type-parameter name="weekday_type"/>
      <template-type-parameter name="facet_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>Formats a weekday. </purpose>
          <typedef name="month_type">
            <type>facet_type::month_type</type>
          </typedef>
          <typedef name="ostream_type">
            <type>std::basic_ostream&lt; charT &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="format_weekday" cv="">
              <type>void</type>
              <parameter name="wd">
                <paramtype>const weekday_type &amp;</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>ostream_type &amp;</paramtype>
              </parameter>
              <parameter name="f">
                <paramtype>const facet_type &amp;</paramtype>
              </parameter>
              <parameter name="as_long_string">
                <paramtype>bool</paramtype>
              </parameter>
              <purpose>Formats a month as as string into an output iterator. </purpose>
            </method>
          </method-group>
        </class>
        <class name="ostream_ymd_formatter">
          <template>
      <template-type-parameter name="ymd_type"/>
      <template-type-parameter name="facet_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>Convert ymd to a standard string formatting policies. </purpose>
          <typedef name="month_type">
            <type>ymd_type::month_type</type>
          </typedef>
          <typedef name="month_formatter_type">
            <type><classname>ostream_month_formatter</classname>&lt; facet_type, charT &gt;</type>
          </typedef>
          <typedef name="ostream_type">
            <type>std::basic_ostream&lt; charT &gt;</type>
          </typedef>
          <typedef name="foo_type">
            <type>std::basic_string&lt; charT &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="ymd_put" cv="">
              <type>void</type>
              <parameter name="ymd">
                <paramtype>ymd_type</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>ostream_type &amp;</paramtype>
              </parameter>
              <parameter name="f">
                <paramtype>const facet_type &amp;</paramtype>
              </parameter>
              <purpose>Convert ymd to a standard string formatting policies. </purpose>
              <description>
                <para>This is standard code for handling date formatting with year-month-day based date information. This function uses the format_type to control whether the string will contain separator characters, and if so what the character will be. In addtion, it can format the month as either an integer or a string as controled by the formatting policy </para>
              </description>
            </method>
          </method-group>
        </class>
        <class name="ostream_date_formatter">
          <template>
      <template-type-parameter name="date_type"/>
      <template-type-parameter name="facet_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>Convert a date to string using format policies. </purpose>
          <typedef name="ostream_type">
            <type>std::basic_ostream&lt; charT &gt;</type>
          </typedef>
          <typedef name="ymd_type">
            <type>date_type::ymd_type</type>
          </typedef>
          <method-group name="public static functions">
            <method name="date_put" cv="">
              <type>void</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>ostream_type &amp;</paramtype>
              </parameter>
              <parameter name="f">
                <paramtype>const facet_type &amp;</paramtype>
              </parameter>
              <purpose>Put date into an ostream. </purpose>
            </method>
            <method name="date_put" cv="">
              <type>void</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>ostream_type &amp;</paramtype>
              </parameter>
              <purpose>Put date into an ostream. </purpose>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_generator_formatter.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="date_generator_formatter">
          <template>
      <template-type-parameter name="date_type"/>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="OutItrT"><default>std::ostreambuf_iterator&lt;CharT, std::char_traits&lt;CharT&gt; &gt;</default></template-type-parameter>
    </template>
          <typedef name="partial_date_type">
            <type><classname>partial_date</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="nth_kday_type">
            <type><classname>nth_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="first_kday_type">
            <type><classname>first_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="last_kday_type">
            <type><classname>last_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="kday_after_type">
            <type><classname>first_kday_after</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="kday_before_type">
            <type><classname>first_kday_before</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="char_type">
            <type>CharT</type>
          </typedef>
          <typedef name="string_type">
            <type>std::basic_string&lt; char_type &gt;</type>
          </typedef>
          <typedef name="collection_type">
            <type>std::vector&lt; string_type &gt;</type>
          </typedef>
          <enum name="phrase_elements">
            <enumvalue name="first">
              <default>0</default>
            </enumvalue>
            <enumvalue name="second"/>
            <enumvalue name="third"/>
            <enumvalue name="fourth"/>
            <enumvalue name="fifth"/>
            <enumvalue name="last"/>
            <enumvalue name="before"/>
            <enumvalue name="after"/>
            <enumvalue name="of"/>
            <enumvalue name="number_of_phrase_elements"/>
          </enum>
          <method-group name="public member functions">
            <method name="elements" cv="">
              <type>void</type>
              <parameter name="new_strings">
                <paramtype>const collection_type &amp;</paramtype>
              </parameter>
              <parameter name="beg_pos">
                <paramtype>phrase_elements</paramtype>
                <default>first</default>
              </parameter>
            </method>
            <method name="put_partial_date" cv="const">
              <type>OutItrT</type>
              <template>
          <template-type-parameter name="facet_type"/>
        </template>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="a_fill">
                <paramtype>CharT</paramtype>
              </parameter>
              <parameter name="pd">
                <paramtype>const <classname>partial_date_type</classname> &amp;</paramtype>
              </parameter>
              <parameter name="facet">
                <paramtype>const facet_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="put_nth_kday" cv="const">
              <type>OutItrT</type>
              <template>
          <template-type-parameter name="facet_type"/>
        </template>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="a_fill">
                <paramtype>CharT</paramtype>
              </parameter>
              <parameter name="nkd">
                <paramtype>const <classname>nth_kday_type</classname> &amp;</paramtype>
              </parameter>
              <parameter name="facet">
                <paramtype>const facet_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="put_first_kday" cv="const">
              <type>OutItrT</type>
              <template>
          <template-type-parameter name="facet_type"/>
        </template>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="a_fill">
                <paramtype>CharT</paramtype>
              </parameter>
              <parameter name="fkd">
                <paramtype>const <classname>first_kday_type</classname> &amp;</paramtype>
              </parameter>
              <parameter name="facet">
                <paramtype>const facet_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="put_last_kday" cv="const">
              <type>OutItrT</type>
              <template>
          <template-type-parameter name="facet_type"/>
        </template>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="a_fill">
                <paramtype>CharT</paramtype>
              </parameter>
              <parameter name="lkd">
                <paramtype>const <classname>last_kday_type</classname> &amp;</paramtype>
              </parameter>
              <parameter name="facet">
                <paramtype>const facet_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="put_kday_before" cv="const">
              <type>OutItrT</type>
              <template>
          <template-type-parameter name="facet_type"/>
        </template>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="a_fill">
                <paramtype>CharT</paramtype>
              </parameter>
              <parameter name="fkb">
                <paramtype>const <classname>kday_before_type</classname> &amp;</paramtype>
              </parameter>
              <parameter name="facet">
                <paramtype>const facet_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="put_kday_after" cv="const">
              <type>OutItrT</type>
              <template>
          <template-type-parameter name="facet_type"/>
        </template>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="a_fill">
                <paramtype>CharT</paramtype>
              </parameter>
              <parameter name="fka">
                <paramtype>const <classname>kday_after_type</classname> &amp;</paramtype>
              </parameter>
              <parameter name="facet">
                <paramtype>const facet_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor/>
          <data-member name="first_string" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="second_string" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="third_string" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="fourth_string" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="fifth_string" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="last_string" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="before_string" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="after_string" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="of_string" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <method-group name="private member functions">
            <method name="put_string" cv="const">
              <type>OutItrT</type>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="str">
                <paramtype>const string_type &amp;</paramtype>
              </parameter>
              <purpose>helper function to put the various member string into stream </purpose>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_generators.hpp">
    <para>Definition and implementation of date algorithm templates</para>
    <namespace name="boost">
      <namespace name="date_time">
        <class name="year_based_generator">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>Base class for all generators that take a year and produce a date. </purpose>
          <description>
            <para>This class is a base class for polymorphic function objects that take a year and produce a concrete date. 
</para>
          </description>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="year_type">
            <type>calendar_type::year_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_date" cv="const">
              <type>virtual date_type</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor/>
          <destructor/>
        </class>
        <class name="partial_date">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <inherit access="public">boost::date_time::year_based_generator&lt; date_type &gt;</inherit>
          <purpose>Generates a date by applying the year to the given month and day. </purpose>
          <description>
            <para>Example usage: <programlisting>    partial_date pd(1, Jan);
    partial_date pd2(70);
    date d = pd.get_date(2002); //2002-Jan-01
    date d2 = pd2.get_date(2002); //2002-Mar-10
</programlisting></para>
          </description>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="day_type">
            <type>calendar_type::day_type</type>
          </typedef>
          <typedef name="month_type">
            <type>calendar_type::month_type</type>
          </typedef>
          <typedef name="year_type">
            <type>calendar_type::year_type</type>
          </typedef>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <typedef name="duration_rep">
            <type>duration_type::duration_rep</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_date" cv="const">
              <type>date_type</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
              <purpose>Return a concrete date when provided with a year specific year. </purpose>
              <description>
                <para>Will throw an 'invalid_argument' exception if a partial_date object, instantiated with Feb-29, has get_date called with a non-leap year. Example: <programlisting> partial_date pd(29, Feb);
 pd.get_date(2003); // throws invalid_argument exception
 pg.get_date(2000); // returns 2000-2-29
</programlisting></para>
              </description>
            </method>
            <method name="operator()" cv="const">
              <type>date_type</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>partial_date</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&lt;" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>partial_date</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="month" cv="const">
              <type>month_type</type>
            </method>
            <method name="day" cv="const">
              <type>day_type</type>
            </method>
          </method-group>
          <constructor>
            <parameter name="d">
              <paramtype>day_type</paramtype>
            </parameter>
            <parameter name="m">
              <paramtype>month_type</paramtype>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="days">
              <paramtype>duration_rep</paramtype>
            </parameter>
            <purpose>Partial date created from number of days into year. Range 1-366. </purpose>
            <description>
              <para>Allowable values range from 1 to 366. 1=Jan1, 366=Dec31. If argument exceeds range, partial_date will be created with closest in-range value. 60 will always be Feb29, if get_date() is called with a non-leap year an exception will be thrown </para>
            </description>
          </constructor>
        </class>
        <class name="nth_kday_of_month">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <inherit access="public">boost::date_time::year_based_generator&lt; date_type &gt;</inherit>
          <purpose>Useful generator functor for finding holidays. </purpose>
          <description>
            <para>Based on the idea in Cal. Calc. for finding holidays that are the 'first Monday of September'. When instantiated with 'fifth' kday of month, the result will be the last kday of month which can be the fourth or fifth depending on the structure of the month.</para>
            <para>The algorithm here basically guesses for the first day of the month. Then finds the first day of the correct type. That is, if the first of the month is a Tuesday and it needs Wenesday then we simply increment by a day and then we can add the length of a week until we get to the 'nth kday'. There are probably more efficient algorithms based on using a mod 7, but this one works reasonably well for basic applications. </para>
          </description>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="day_of_week_type">
            <type>calendar_type::day_of_week_type</type>
          </typedef>
          <typedef name="month_type">
            <type>calendar_type::month_type</type>
          </typedef>
          <typedef name="year_type">
            <type>calendar_type::year_type</type>
          </typedef>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <enum name="week_num">
            <enumvalue name="first">
              <default>1</default>
            </enumvalue>
            <enumvalue name="second"/>
            <enumvalue name="third"/>
            <enumvalue name="fourth"/>
            <enumvalue name="fifth"/>
          </enum>
          <method-group name="public member functions">
            <method name="get_date" cv="const">
              <type>date_type</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
              <purpose>Return a concrete date when provided with a year specific year. </purpose>
            </method>
            <method name="month" cv="const">
              <type>month_type</type>
            </method>
            <method name="nth_week" cv="const">
              <type>week_num</type>
            </method>
            <method name="day_of_week" cv="const">
              <type>day_of_week_type</type>
            </method>
            <method name="nth_week_as_str" cv="const">
              <type>const char *</type>
            </method>
          </method-group>
          <constructor>
            <parameter name="week_no">
              <paramtype>week_num</paramtype>
            </parameter>
            <parameter name="dow">
              <paramtype>day_of_week_type</paramtype>
            </parameter>
            <parameter name="m">
              <paramtype>month_type</paramtype>
            </parameter>
          </constructor>
        </class>
        <class name="first_kday_of_month">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <inherit access="public">boost::date_time::year_based_generator&lt; date_type &gt;</inherit>
          <purpose>Useful generator functor for finding holidays and daylight savings. </purpose>
          <description>
            <para>Similar to nth_kday_of_month, but requires less paramters </para>
          </description>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="day_of_week_type">
            <type>calendar_type::day_of_week_type</type>
          </typedef>
          <typedef name="month_type">
            <type>calendar_type::month_type</type>
          </typedef>
          <typedef name="year_type">
            <type>calendar_type::year_type</type>
          </typedef>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_date" cv="const">
              <type>date_type</type>
              <parameter name="year">
                <paramtype>year_type</paramtype>
              </parameter>
              <purpose>Return a concrete date when provided with a year specific year. </purpose>
            </method>
            <method name="month" cv="const">
              <type>month_type</type>
            </method>
            <method name="day_of_week" cv="const">
              <type>day_of_week_type</type>
            </method>
          </method-group>
          <constructor>
            <parameter name="dow">
              <paramtype>day_of_week_type</paramtype>
              <description>
                <para>The day of week, eg: Sunday, Monday, etc </para>
              </description>
            </parameter>
            <parameter name="m">
              <paramtype>month_type</paramtype>
              <description>
                <para>The month of the year, eg: Jan, Feb, Mar, etc </para>
              </description>
            </parameter>
            <purpose>Specify the first 'Sunday' in 'April' spec. </purpose>
            <description>
              <para>
</para>
            </description>
          </constructor>
        </class>
        <class name="last_kday_of_month">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <inherit access="public">boost::date_time::year_based_generator&lt; date_type &gt;</inherit>
          <purpose>Calculate something like Last Sunday of January. </purpose>
          <description>
            <para>Useful generator functor for finding holidays and daylight savings Get the last day of the month and then calculate the difference to the last previous day. 
</para>
          </description>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="day_of_week_type">
            <type>calendar_type::day_of_week_type</type>
          </typedef>
          <typedef name="month_type">
            <type>calendar_type::month_type</type>
          </typedef>
          <typedef name="year_type">
            <type>calendar_type::year_type</type>
          </typedef>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_date" cv="const">
              <type>date_type</type>
              <parameter name="year">
                <paramtype>year_type</paramtype>
              </parameter>
              <purpose>Return a concrete date when provided with a year specific year. </purpose>
            </method>
            <method name="month" cv="const">
              <type>month_type</type>
            </method>
            <method name="day_of_week" cv="const">
              <type>day_of_week_type</type>
            </method>
          </method-group>
          <constructor>
            <parameter name="dow">
              <paramtype>day_of_week_type</paramtype>
              <description>
                <para>The day of week, eg: Sunday, Monday, etc </para>
              </description>
            </parameter>
            <parameter name="m">
              <paramtype>month_type</paramtype>
              <description>
                <para>The month of the year, eg: Jan, Feb, Mar, etc </para>
              </description>
            </parameter>
            <purpose>Specify the date spec like last 'Sunday' in 'April' spec. </purpose>
            <description>
              <para>
</para>
            </description>
          </constructor>
        </class>
        <class name="first_kday_after">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>Calculate something like "First Sunday after Jan 1,2002. </purpose>
          <description>
            <para>Date generator that takes a date and finds kday after <programlisting>     typedef boost::date_time::first_kday_after&lt;date&gt; firstkdayafter;
     firstkdayafter fkaf(Monday);
     fkaf.get_date(date(2002,Feb,1));
</programlisting></para>
          </description>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="day_of_week_type">
            <type>calendar_type::day_of_week_type</type>
          </typedef>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_date" cv="const">
              <type>date_type</type>
              <parameter name="start_day">
                <paramtype>date_type</paramtype>
              </parameter>
              <purpose>Return next kday given. </purpose>
            </method>
            <method name="day_of_week" cv="const">
              <type>day_of_week_type</type>
            </method>
          </method-group>
          <constructor>
            <parameter name="dow">
              <paramtype>day_of_week_type</paramtype>
            </parameter>
          </constructor>
        </class>
        <class name="first_kday_before">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>Calculate something like "First Sunday before Jan 1,2002. </purpose>
          <description>
            <para>Date generator that takes a date and finds kday after <programlisting>     typedef boost::date_time::first_kday_before&lt;date&gt; firstkdaybefore;
     firstkdaybefore fkbf(Monday);
     fkbf.get_date(date(2002,Feb,1));
</programlisting></para>
          </description>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="day_of_week_type">
            <type>calendar_type::day_of_week_type</type>
          </typedef>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_date" cv="const">
              <type>date_type</type>
              <parameter name="start_day">
                <paramtype>date_type</paramtype>
              </parameter>
              <purpose>Return next kday given. </purpose>
            </method>
            <method name="day_of_week" cv="const">
              <type>day_of_week_type</type>
            </method>
          </method-group>
          <constructor>
            <parameter name="dow">
              <paramtype>day_of_week_type</paramtype>
            </parameter>
          </constructor>
        </class>
        <function name="nth_as_str">
          <type>BOOST_DATE_TIME_DECL const char *</type>
          <parameter name="n">
            <paramtype>int</paramtype>
          </parameter>
          <purpose>Returns nth arg as string. 1 -&gt; "first", 2 -&gt; "second", max is 5. </purpose>
        </function>
        <function name="days_until_weekday">
          <type>date_type::duration_type</type>
          <template>
          <template-type-parameter name="date_type"/>
          <template-type-parameter name="weekday_type"/>
        </template>
          <parameter name="d">
            <paramtype>const date_type &amp;</paramtype>
          </parameter>
          <parameter name="wd">
            <paramtype>const weekday_type &amp;</paramtype>
          </parameter>
          <purpose>Calculates the number of days until the next weekday. </purpose>
          <description>
            <para>Calculates the number of days until the next weekday. If the date given falls on a Sunday and the given weekday is Tuesday the result will be 2 days </para>
          </description>
        </function>
        <function name="days_before_weekday">
          <type>date_type::duration_type</type>
          <template>
          <template-type-parameter name="date_type"/>
          <template-type-parameter name="weekday_type"/>
        </template>
          <parameter name="d">
            <paramtype>const date_type &amp;</paramtype>
          </parameter>
          <parameter name="wd">
            <paramtype>const weekday_type &amp;</paramtype>
          </parameter>
          <purpose>Calculates the number of days since the previous weekday. </purpose>
          <description>
            <para>Calculates the number of days since the previous weekday If the date given falls on a Sunday and the given weekday is Tuesday the result will be 5 days. The answer will be a positive number because Tuesday is 5 days before Sunday, not -5 days before. </para>
          </description>
        </function>
        <function name="next_weekday">
          <type>date_type</type>
          <template>
          <template-type-parameter name="date_type"/>
          <template-type-parameter name="weekday_type"/>
        </template>
          <parameter name="d">
            <paramtype>const date_type &amp;</paramtype>
          </parameter>
          <parameter name="wd">
            <paramtype>const weekday_type &amp;</paramtype>
          </parameter>
          <purpose>Generates a date object representing the date of the following weekday from the given date. </purpose>
          <description>
            <para>Generates a date object representing the date of the following weekday from the given date. If the date given is 2004-May-9 (a Sunday) and the given weekday is Tuesday then the resulting date will be 2004-May-11. </para>
          </description>
        </function>
        <function name="previous_weekday">
          <type>date_type</type>
          <template>
          <template-type-parameter name="date_type"/>
          <template-type-parameter name="weekday_type"/>
        </template>
          <parameter name="d">
            <paramtype>const date_type &amp;</paramtype>
          </parameter>
          <parameter name="wd">
            <paramtype>const weekday_type &amp;</paramtype>
          </parameter>
          <purpose>Generates a date object representing the date of the previous weekday from the given date. </purpose>
          <description>
            <para>Generates a date object representing the date of the previous weekday from the given date. If the date given is 2004-May-9 (a Sunday) and the given weekday is Tuesday then the resulting date will be 2004-May-4. </para>
          </description>
        </function>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_iterator.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="date_itr_base">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>Base date iterator type. </purpose>
          <description>
            <para>This class provides the skeleton for the creation of iterators. New and interesting interators can be created by plugging in a new function that derives the next value from the current state. generation of various types of -based information.</para>
            <para><emphasis role="bold">Template Parameters</emphasis> </para>
            <para><emphasis role="bold">date_type</emphasis> </para>
            <para>The date_type is a concrete date_type. The date_type must define a duration_type and a calendar_type. </para>
          </description>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <typedef name="value_type">
            <type>date_type</type>
          </typedef>
          <typedef name="iterator_category">
            <type>std::input_iterator_tag</type>
          </typedef>
          <method-group name="public member functions">
            <method name="operator++" cv="">
              <type><classname>date_itr_base</classname> &amp;</type>
            </method>
            <method name="operator--" cv="">
              <type><classname>date_itr_base</classname> &amp;</type>
            </method>
            <method name="get_offset" cv="const">
              <type>virtual duration_type</type>
              <parameter name="current">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="get_neg_offset" cv="const">
              <type>virtual duration_type</type>
              <parameter name="current">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator *" cv="">
              <type>date_type</type>
            </method>
            <method name="operator-&gt;" cv="">
              <type>date_type *</type>
            </method>
            <method name="operator&lt;" cv="">
              <type>bool</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&lt;=" cv="">
              <type>bool</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&gt;" cv="">
              <type>bool</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&gt;=" cv="">
              <type>bool</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator==" cv="">
              <type>bool</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator!=" cv="">
              <type>bool</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="d">
              <paramtype>date_type</paramtype>
            </parameter>
          </constructor>
          <destructor/>
        </class>
        <class name="date_itr">
          <template>
      <template-type-parameter name="offset_functor"/>
      <template-type-parameter name="date_type"/>
    </template>
          <inherit access="public">boost::date_time::date_itr_base&lt; date_type &gt;</inherit>
          <purpose>Overrides the base date iterator providing hook for functors. </purpose>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <method-group name="public member functions"/>
          <constructor>
            <parameter name="d">
              <paramtype>date_type</paramtype>
            </parameter>
            <parameter name="factor">
              <paramtype>int</paramtype>
              <default>1</default>
            </parameter>
          </constructor>
          <method-group name="private member functions">
            <method name="get_offset" cv="const">
              <type>virtual duration_type</type>
              <parameter name="current">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="get_neg_offset" cv="const">
              <type>virtual duration_type</type>
              <parameter name="current">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
        </class>
        <enum name="date_resolutions">
          <enumvalue name="day"/>
          <enumvalue name="week"/>
          <enumvalue name="months"/>
          <enumvalue name="year"/>
          <enumvalue name="decade"/>
          <enumvalue name="century"/>
          <enumvalue name="NumDateResolutions"/>
          <purpose>An iterator over dates with varying resolution (day, week, month, year, etc). </purpose>
        </enum>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_names_put.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="date_names_put">
          <template>
      <template-type-parameter name="Config"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
      <template-type-parameter name="OutputIterator"><default>std::ostreambuf_iterator&lt;charT&gt;</default></template-type-parameter>
    </template>
          <purpose>Output facet base class for gregorian dates. </purpose>
          <description>
            <para>This class is a base class for date facets used to localize the names of months and the names of days in the week.</para>
            <para>Requirements of Config<itemizedlist>
<listitem><para>define an enumeration month_enum that enumerates the months. The enumeration should be '1' based eg: Jan==1</para></listitem><listitem><para>define as_short_string and as_long_string</para></listitem></itemizedlist>
</para>
            <para>(see langer &amp; kreft p334). </para>
          </description>
          <typedef name="iter_type">
            <type>OutputIterator</type>
          </typedef>
          <typedef name="month_type">
            <type>Config::month_type</type>
          </typedef>
          <typedef name="month_enum">
            <type>Config::month_enum</type>
          </typedef>
          <typedef name="weekday_enum">
            <type>Config::weekday_enum</type>
          </typedef>
          <typedef name="special_value_enum">
            <type>Config::special_value_enum</type>
          </typedef>
          <typedef name="string_type">
            <type>std::basic_string&lt; charT &gt;</type>
          </typedef>
          <method-group name="public member functions">
            <method name="__get_id" cv="const">
              <type>std::locale::id &amp;</type>
              <parameter name="">
                <paramtype>void</paramtype>
              </parameter>
            </method>
            <method name="put_special_value" cv="const">
              <type>void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="sv">
                <paramtype>special_value_enum</paramtype>
              </parameter>
            </method>
            <method name="put_month_short" cv="const">
              <type>void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="moy">
                <paramtype>month_enum</paramtype>
              </parameter>
            </method>
            <method name="put_month_long" cv="const">
              <type>void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="moy">
                <paramtype>month_enum</paramtype>
              </parameter>
            </method>
            <method name="put_weekday_short" cv="const">
              <type>void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="wd">
                <paramtype>weekday_enum</paramtype>
              </parameter>
            </method>
            <method name="put_weekday_long" cv="const">
              <type>void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="wd">
                <paramtype>weekday_enum</paramtype>
              </parameter>
            </method>
            <method name="has_date_sep_chars" cv="const">
              <type>bool</type>
            </method>
            <method name="year_sep_char" cv="const">
              <type>void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="month_sep_char" cv="const">
              <type>void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <purpose>char between year-month </purpose>
            </method>
            <method name="day_sep_char" cv="const">
              <type>void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <purpose>Char to separate month-day. </purpose>
            </method>
            <method name="date_order" cv="const">
              <type>ymd_order_spec</type>
              <purpose>Determines the order to put the date elements. </purpose>
            </method>
            <method name="month_format" cv="const">
              <type>month_format_spec</type>
              <purpose>Determines if month is displayed as integer, short or long string. </purpose>
            </method>
          </method-group>
          <constructor/>
          <data-member name="id" specifiers="static">
            <type>std::locale::id</type>
            <purpose>Generate storage location for a std::locale::id. </purpose>
          </data-member>
          <method-group name="protected member functions">
            <method name="do_put_month_short" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="moy">
                <paramtype>month_enum</paramtype>
              </parameter>
              <purpose>Default facet implementation uses month_type defaults. </purpose>
            </method>
            <method name="do_put_month_long" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="moy">
                <paramtype>month_enum</paramtype>
              </parameter>
              <purpose>Default facet implementation uses month_type defaults. </purpose>
            </method>
            <method name="do_put_special_value" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="sv">
                <paramtype>special_value_enum</paramtype>
              </parameter>
              <purpose>Default facet implementation for special value types. </purpose>
            </method>
            <method name="do_put_weekday_short" cv="const">
              <type>virtual void</type>
              <parameter name="">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="">
                <paramtype>weekday_enum</paramtype>
              </parameter>
            </method>
            <method name="do_put_weekday_long" cv="const">
              <type>virtual void</type>
              <parameter name="">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="">
                <paramtype>weekday_enum</paramtype>
              </parameter>
            </method>
            <method name="do_has_date_sep_chars" cv="const">
              <type>virtual bool</type>
            </method>
            <method name="do_year_sep_char" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="do_month_sep_char" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <purpose>char between year-month </purpose>
            </method>
            <method name="do_day_sep_char" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <purpose>Char to separate month-day. </purpose>
            </method>
            <method name="do_date_order" cv="const">
              <type>virtual ymd_order_spec</type>
              <purpose>Default for date order. </purpose>
            </method>
            <method name="do_month_format" cv="const">
              <type>virtual month_format_spec</type>
              <purpose>Default month format. </purpose>
            </method>
            <method name="put_string" cv="const">
              <type>void</type>
              <parameter name="oi">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="s">
                <paramtype>const charT *const</paramtype>
              </parameter>
            </method>
            <method name="put_string" cv="const">
              <type>void</type>
              <parameter name="oi">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="s1">
                <paramtype>const string_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
        </class>
        <class name="all_date_names_put">
          <template>
      <template-type-parameter name="Config"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
      <template-type-parameter name="OutputIterator"><default>std::ostreambuf_iterator&lt;charT&gt;</default></template-type-parameter>
    </template>
          <inherit access="public">boost::date_time::date_names_put&lt; Config, charT, OutputIterator &gt;</inherit>
          <purpose>An date name output facet that takes an array of char* to define strings. </purpose>
          <typedef name="iter_type">
            <type>OutputIterator</type>
          </typedef>
          <typedef name="month_enum">
            <type>Config::month_enum</type>
          </typedef>
          <typedef name="weekday_enum">
            <type>Config::weekday_enum</type>
          </typedef>
          <typedef name="special_value_enum">
            <type>Config::special_value_enum</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_short_month_names" cv="const">
              <type>const charT *const *</type>
            </method>
            <method name="get_long_month_names" cv="const">
              <type>const charT *const *</type>
            </method>
            <method name="get_special_value_names" cv="const">
              <type>const charT *const *</type>
            </method>
            <method name="get_short_weekday_names" cv="const">
              <type>const charT *const *</type>
            </method>
            <method name="get_long_weekday_names" cv="const">
              <type>const charT *const *</type>
            </method>
          </method-group>
          <constructor>
            <parameter name="month_short_names">
              <paramtype>const charT *const</paramtype>
            </parameter>
            <parameter name="month_long_names">
              <paramtype>const charT *const</paramtype>
            </parameter>
            <parameter name="special_value_names">
              <paramtype>const charT *const</paramtype>
            </parameter>
            <parameter name="weekday_short_names">
              <paramtype>const charT *const</paramtype>
            </parameter>
            <parameter name="weekday_long_names">
              <paramtype>const charT *const</paramtype>
            </parameter>
            <parameter name="separator_char">
              <paramtype>charT</paramtype>
              <default>'-'</default>
            </parameter>
            <parameter name="order_spec">
              <paramtype>ymd_order_spec</paramtype>
              <default>ymd_order_iso</default>
            </parameter>
            <parameter name="month_format">
              <paramtype>month_format_spec</paramtype>
              <default>month_as_short_string</default>
            </parameter>
          </constructor>
          <method-group name="protected member functions">
            <method name="do_put_month_short" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="moy">
                <paramtype>month_enum</paramtype>
              </parameter>
              <purpose>Generic facet that takes array of chars. </purpose>
            </method>
            <method name="do_put_month_long" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="moy">
                <paramtype>month_enum</paramtype>
              </parameter>
              <purpose>Long month names. </purpose>
            </method>
            <method name="do_put_special_value" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="sv">
                <paramtype>special_value_enum</paramtype>
              </parameter>
              <purpose>Special values names. </purpose>
            </method>
            <method name="do_put_weekday_short" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="wd">
                <paramtype>weekday_enum</paramtype>
              </parameter>
            </method>
            <method name="do_put_weekday_long" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="wd">
                <paramtype>weekday_enum</paramtype>
              </parameter>
            </method>
            <method name="do_month_sep_char" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <purpose>char between year-month </purpose>
            </method>
            <method name="do_day_sep_char" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <purpose>Char to separate month-day. </purpose>
            </method>
            <method name="do_date_order" cv="const">
              <type>virtual ymd_order_spec</type>
              <purpose>Set the date ordering. </purpose>
            </method>
            <method name="do_month_format" cv="const">
              <type>virtual month_format_spec</type>
              <purpose>Set the date ordering. </purpose>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_parsing.hpp"/>
  <header name="boost/date_time/dst_rules.hpp">
    <para>Contains template class to provide static dst rule calculations</para>
    <namespace name="boost">
      <namespace name="date_time">
        <class name="dst_calculator">
          <template>
      <template-type-parameter name="date_type_"/>
      <template-type-parameter name="time_duration_type_"/>
    </template>
          <purpose>Dynamic class used to caluclate dst transition information. </purpose>
          <typedef name="time_duration_type">
            <type>time_duration_type_</type>
          </typedef>
          <typedef name="date_type">
            <type>date_type_</type>
          </typedef>
          <method-group name="public static functions">
            <method name="process_local_dst_start_day" cv="">
              <type>time_is_dst_result</type>
              <parameter name="time_of_day">
                <paramtype>const time_duration_type &amp;</paramtype>
                <description>
                  <para>Time offset in the day for the local time </para>
                </description>
              </parameter>
              <parameter name="dst_start_offset_minutes">
                <paramtype>unsigned int</paramtype>
                <description>
                  <para>Local day offset for start of dst </para>
                </description>
              </parameter>
              <parameter name="dst_length_minutes">
                <paramtype>long</paramtype>
                <description>
                  <para>Number of minutes to adjust clock forward </para>
                </description>
              </parameter>
              <purpose>Check the local time offset when on dst start day. </purpose>
              <description>
                <para>On this dst transition, the time label between the transition boundary and the boudary + the offset are invalid times. If before the boundary then still not in dst. 

</para>
              </description>
            </method>
            <method name="process_local_dst_end_day" cv="">
              <type>time_is_dst_result</type>
              <parameter name="time_of_day">
                <paramtype>const time_duration_type &amp;</paramtype>
                <description>
                  <para>Time offset in the day for the local time </para>
                </description>
              </parameter>
              <parameter name="dst_end_offset_minutes">
                <paramtype>unsigned int</paramtype>
                <description>
                  <para>Local time of day for end of dst </para>
                </description>
              </parameter>
              <parameter name="dst_length_minutes">
                <paramtype>long</paramtype>
              </parameter>
              <purpose>Check the local time offset when on the last day of dst. </purpose>
              <description>
                <para>This is the calculation for the DST end day. On that day times prior to the conversion time - dst_length (1 am in US) are still in dst. Times between the above and the switch time are ambiguous. Times after the start_offset are not in dst. 

</para>
              </description>
            </method>
            <method name="local_is_dst" cv="">
              <type>time_is_dst_result</type>
              <parameter name="current_day">
                <paramtype>const date_type &amp;</paramtype>
                <description>
                  <para>The day to check for dst </para>
                </description>
              </parameter>
              <parameter name="time_of_day">
                <paramtype>const time_duration_type &amp;</paramtype>
                <description>
                  <para>Time offset within the day to check </para>
                </description>
              </parameter>
              <parameter name="dst_start_day">
                <paramtype>const date_type &amp;</paramtype>
                <description>
                  <para>Starting day of dst for the given locality </para>
                </description>
              </parameter>
              <parameter name="dst_start_offset">
                <paramtype>const time_duration_type &amp;</paramtype>
                <description>
                  <para>Time offset within day for dst boundary </para>
                </description>
              </parameter>
              <parameter name="dst_end_day">
                <paramtype>const date_type &amp;</paramtype>
                <description>
                  <para>Ending day of dst for the given locality </para>
                </description>
              </parameter>
              <parameter name="dst_end_offset">
                <paramtype>const time_duration_type &amp;</paramtype>
                <description>
                  <para>Time offset within day given in dst for dst boundary </para>
                </description>
              </parameter>
              <parameter name="dst_length_minutes">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <purpose>Calculates if the given local time is dst or not. </purpose>
              <description>
                <para>Determines if the time is really in DST or not. Also checks for invalid and ambiguous. 

</para>
              </description>
            </method>
            <method name="local_is_dst" cv="">
              <type>time_is_dst_result</type>
              <parameter name="current_day">
                <paramtype>const date_type &amp;</paramtype>
                <description>
                  <para>The day to check for dst </para>
                </description>
              </parameter>
              <parameter name="time_of_day">
                <paramtype>const time_duration_type &amp;</paramtype>
                <description>
                  <para>Time offset within the day to check </para>
                </description>
              </parameter>
              <parameter name="dst_start_day">
                <paramtype>const date_type &amp;</paramtype>
                <description>
                  <para>Starting day of dst for the given locality </para>
                </description>
              </parameter>
              <parameter name="dst_start_offset_minutes">
                <paramtype>unsigned int</paramtype>
                <description>
                  <para>Offset within day for dst boundary (eg 120 for US which is 02:00:00) </para>
                </description>
              </parameter>
              <parameter name="dst_end_day">
                <paramtype>const date_type &amp;</paramtype>
                <description>
                  <para>Ending day of dst for the given locality </para>
                </description>
              </parameter>
              <parameter name="dst_end_offset_minutes">
                <paramtype>unsigned int</paramtype>
                <description>
                  <para>Offset within day given in dst for dst boundary (eg 120 for US which is 02:00:00) </para>
                </description>
              </parameter>
              <parameter name="dst_length_minutes">
                <paramtype>long</paramtype>
                <description>
                  <para>Length of dst adjusment (eg: 60 for US) </para>
                </description>
              </parameter>
              <purpose>Calculates if the given local time is dst or not. </purpose>
              <description>
                <para>Determines if the time is really in DST or not. Also checks for invalid and ambiguous. 

</para>
              </description>
            </method>
          </method-group>
        </class>
        <class name="dst_calc_engine">
          <template>
      <template-type-parameter name="date_type"/>
      <template-type-parameter name="time_duration_type"/>
      <template-type-parameter name="dst_traits"/>
    </template>
          <purpose>Compile-time configurable daylight savings time calculation engine. </purpose>
          <typedef name="year_type">
            <type>date_type::year_type</type>
          </typedef>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="dstcalc">
            <type><classname>dst_calculator</classname>&lt; date_type, time_duration_type &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="local_is_dst" cv="">
              <type>time_is_dst_result</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <parameter name="td">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <purpose>Calculates if the given local time is dst or not. </purpose>
              <description>
                <para>Determines if the time is really in DST or not. Also checks for invalid and ambiguous. 
</para>
              </description>
            </method>
            <method name="is_dst_boundary_day" cv="">
              <type>bool</type>
              <parameter name="d">
                <paramtype>date_type</paramtype>
              </parameter>
            </method>
            <method name="dst_offset" cv="">
              <type>time_duration_type</type>
              <purpose>The time of day for the dst transition (eg: typically 01:00:00 or 02:00:00). </purpose>
            </method>
            <method name="local_dst_start_day" cv="">
              <type>date_type</type>
              <parameter name="year">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
            <method name="local_dst_end_day" cv="">
              <type>date_type</type>
              <parameter name="year">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
          </method-group>
        </class>
        <class name="us_dst_rules">
          <template>
      <template-type-parameter name="date_type_"/>
      <template-type-parameter name="time_duration_type_"/>
      <template-nontype-parameter name="dst_start_offset_minutes"><type>unsigned int</type><default>120</default></template-nontype-parameter>
      <template-nontype-parameter name="dst_length_minutes"><type>short</type><default>60</default></template-nontype-parameter>
    </template>
          <purpose>Depricated: Class to calculate dst boundaries for US time zones. </purpose>
          <typedef name="time_duration_type">
            <type>time_duration_type_</type>
          </typedef>
          <typedef name="date_type">
            <type>date_type_</type>
          </typedef>
          <typedef name="year_type">
            <type>date_type::year_type</type>
          </typedef>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="lkday">
            <type><classname>date_time::last_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="fkday">
            <type><classname>date_time::first_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="dstcalc">
            <type><classname>dst_calculator</classname>&lt; date_type, time_duration_type &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="local_is_dst" cv="">
              <type>time_is_dst_result</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <parameter name="td">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <purpose>Calculates if the given local time is dst or not. </purpose>
              <description>
                <para>Determines if the time is really in DST or not. Also checks for invalid and ambiguous. 
</para>
              </description>
            </method>
            <method name="is_dst_boundary_day" cv="">
              <type>bool</type>
              <parameter name="d">
                <paramtype>date_type</paramtype>
              </parameter>
            </method>
            <method name="local_dst_start_day" cv="">
              <type>date_type</type>
              <parameter name="year">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
            <method name="local_dst_end_day" cv="">
              <type>date_type</type>
              <parameter name="year">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
            <method name="dst_offset" cv="">
              <type>time_duration_type</type>
            </method>
          </method-group>
        </class>
        <class name="null_dst_rules">
          <template>
      <template-type-parameter name="date_type_"/>
      <template-type-parameter name="time_duration_type_"/>
    </template>
          <purpose>Used for local time adjustments in places that don't use dst. </purpose>
          <typedef name="time_duration_type">
            <type>time_duration_type_</type>
          </typedef>
          <typedef name="date_type">
            <type>date_type_</type>
          </typedef>
          <method-group name="public static functions">
            <method name="local_is_dst" cv="">
              <type>time_is_dst_result</type>
              <parameter name="">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <parameter name="">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <purpose>Calculates if the given local time is dst or not. </purpose>
              <description>
                <para>
</para>
              </description>
            </method>
            <method name="utc_is_dst" cv="">
              <type>time_is_dst_result</type>
              <parameter name="">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <parameter name="">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <purpose>Calculates if the given utc time is in dst. </purpose>
            </method>
            <method name="is_dst_boundary_day" cv="">
              <type>bool</type>
              <parameter name="d">
                <paramtype>date_type</paramtype>
              </parameter>
            </method>
            <method name="dst_offset" cv="">
              <type>time_duration_type</type>
            </method>
          </method-group>
        </class>
        <enum name="time_is_dst_result">
          <enumvalue name="is_not_in_dst"/>
          <enumvalue name="is_in_dst"/>
          <enumvalue name="ambiguous"/>
          <enumvalue name="invalid_time_label"/>
        </enum>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/dst_transition_generators.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="dst_day_calc_rule">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>Defines base interface for calculating start and end date of daylight savings. </purpose>
          <typedef name="year_type">
            <type>date_type::year_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="start_day" cv="const">
              <type>virtual date_type</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
            <method name="end_day" cv="const">
              <type>virtual date_type</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
          </method-group>
          <destructor/>
        </class>
        <class name="day_calc_dst_rule">
          <template>
      <template-type-parameter name="spec"/>
    </template>
          <inherit access="public">boost::date_time::dst_day_calc_rule&lt; spec::date_type &gt;</inherit>
          <purpose>Canonical form for a class that provides day rule calculation. </purpose>
          <description>
            <para>This class is used to generate specific sets of dst rules</para>
            <para>
</para>
          </description>
          <typedef name="date_type">
            <type>spec::date_type</type>
          </typedef>
          <typedef name="year_type">
            <type>date_type::year_type</type>
          </typedef>
          <typedef name="start_rule">
            <type>spec::start_rule</type>
          </typedef>
          <typedef name="end_rule">
            <type>spec::end_rule</type>
          </typedef>
          <method-group name="public member functions">
            <method name="start_day" cv="const">
              <type>virtual date_type</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
            <method name="end_day" cv="const">
              <type>virtual date_type</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="dst_start">
              <paramtype>start_rule</paramtype>
            </parameter>
            <parameter name="dst_end">
              <paramtype>end_rule</paramtype>
            </parameter>
          </constructor>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/filetime_functions.hpp">
    <para>Function(s) for converting between a FILETIME structure and a time object. This file is only available on systems that have BOOST_HAS_FTIME defined.</para>
    <namespace name="boost">
      <namespace name="date_time">
        <function name="time_from_ftime">
          <type>time_type</type>
          <template>
          <template-type-parameter name="time_type"/>
        </template>
          <parameter name="ft">
            <paramtype>const FILETIME &amp;</paramtype>
          </parameter>
          <purpose>Create a time object from an initialized FILETIME struct. </purpose>
          <description>
            <para>Create a time object from an initialized FILETIME struct. A FILETIME struct holds 100-nanosecond units (0.0000001). When built with microsecond resolution the FILETIME's sub second value will be truncated. Nanosecond resolution has no truncation. </para>
          </description>
        </function>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/format_date_parser.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="format_date_parser">
          <template>
      <template-type-parameter name="date_type"/>
      <template-type-parameter name="charT"/>
    </template>
          <purpose>Class with generic date parsing using a format string. </purpose>
          <description>
            <para>The following is the set of recognized format specifiers<itemizedlist>
<listitem><para>a - Short weekday name</para></listitem><listitem><para>A - Long weekday name</para></listitem><listitem><para>b - Abbreviated month name</para></listitem><listitem><para>B - Full month name</para></listitem><listitem><para>d - Day of the month as decimal</para></listitem><listitem><para>j - Day of year as decimal from 1 to 366</para></listitem><listitem><para>m - Month name as a decimal 01 to 12</para></listitem><listitem><para>U - Week number 00 to 53 with first Sunday as the first day of week 1?</para></listitem><listitem><para>w - Weekday as decimal number 0 to 6 where Sunday == 0</para></listitem><listitem><para>W - Week number 00 to 53 where Monday is first day of week 1</para></listitem><listitem><para>x - facet default date representation</para></listitem><listitem><para>y - Year without the century - eg: 04 for 2004</para></listitem><listitem><para>Y - Year with century</para></listitem></itemizedlist>
</para>
            <para>The weekday specifiers (a and A) do not add to the date construction, but they provide a way to skip over the weekday names for formats that provide them.</para>
            <para>todo -- Another interesting feature that this approach could provide is an option to fill in any missing fields with the current values from the clock. So if you have m-%d the parser would detect the missing year value and fill it in using the clock.</para>
            <para>todo -- What to do with the x. x in the classic facet is just bad... </para>
          </description>
          <typedef name="string_type">
            <type>std::basic_string&lt; charT &gt;</type>
          </typedef>
          <typedef name="stringstream_type">
            <type>std::basic_stringstream&lt; charT &gt;</type>
          </typedef>
          <typedef name="stream_itr_type">
            <type>std::istreambuf_iterator&lt; charT &gt;</type>
          </typedef>
          <typedef name="const_itr">
            <type>string_type::const_iterator</type>
          </typedef>
          <typedef name="year_type">
            <type>date_type::year_type</type>
          </typedef>
          <typedef name="month_type">
            <type>date_type::month_type</type>
          </typedef>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <typedef name="parse_tree_type">
            <type><classname>string_parse_tree</classname>&lt; charT &gt;</type>
          </typedef>
          <typedef name="match_results">
            <type>parse_tree_type::parse_match_result_type</type>
          </typedef>
          <typedef name="input_collection_type">
            <type>std::vector&lt; std::basic_string&lt; charT &gt; &gt;</type>
          </typedef>
          <method-group name="public member functions">
            <method name="format" cv="const">
              <type>string_type</type>
            </method>
            <method name="format" cv="">
              <type>void</type>
              <parameter name="format">
                <paramtype>string_type</paramtype>
              </parameter>
            </method>
            <method name="parse_date" cv="const">
              <type>date_type</type>
              <parameter name="value">
                <paramtype>const string_type &amp;</paramtype>
              </parameter>
              <parameter name="format">
                <paramtype>const string_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="parse_date" cv="const">
              <type>date_type</type>
              <parameter name="sitr">
                <paramtype>std::istreambuf_iterator&lt; charT &gt; &amp;</paramtype>
              </parameter>
              <parameter name="stream_end">
                <paramtype>std::istreambuf_iterator&lt; charT &gt; &amp;</paramtype>
              </parameter>
            </method>
            <method name="parse_date" cv="const">
              <type>date_type</type>
              <parameter name="sitr">
                <paramtype>std::istreambuf_iterator&lt; charT &gt; &amp;</paramtype>
              </parameter>
              <parameter name="stream_end">
                <paramtype>std::istreambuf_iterator&lt; charT &gt; &amp;</paramtype>
              </parameter>
              <parameter name="format">
                <paramtype>string_type</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="format">
              <paramtype>const string_type &amp;</paramtype>
            </parameter>
            <parameter name="month_short_names">
              <paramtype>const input_collection_type &amp;</paramtype>
            </parameter>
            <parameter name="month_long_names">
              <paramtype>const input_collection_type &amp;</paramtype>
            </parameter>
            <parameter name="weekday_short_names">
              <paramtype>const input_collection_type &amp;</paramtype>
            </parameter>
            <parameter name="weekday_long_names">
              <paramtype>const input_collection_type &amp;</paramtype>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="format">
              <paramtype>const string_type &amp;</paramtype>
            </parameter>
            <parameter name="locale">
              <paramtype>const std::locale &amp;</paramtype>
            </parameter>
          </constructor>
        </class>
        <function name="fixed_string_to_int">
          <type>int_type</type>
          <template>
          <template-type-parameter name="int_type"/>
          <template-type-parameter name="charT"/>
        </template>
          <parameter name="itr">
            <paramtype>std::istreambuf_iterator&lt; charT &gt; &amp;</paramtype>
          </parameter>
          <parameter name="length">
            <paramtype>unsigned int</paramtype>
          </parameter>
          <purpose>Helper function for parsing fixed length strings into integers. </purpose>
        </function>
        <function name="var_string_to_int">
          <type>int_type</type>
          <template>
          <template-type-parameter name="int_type"/>
          <template-type-parameter name="charT"/>
        </template>
          <parameter name="itr">
            <paramtype>std::istreambuf_iterator&lt; charT &gt; &amp;</paramtype>
          </parameter>
          <parameter name="max_length">
            <paramtype>unsigned int</paramtype>
          </parameter>
          <purpose>Helper function for parsing fixed length strings into integers. </purpose>
        </function>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/gregorian_calendar.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="gregorian_calendar_base">
          <template>
      <template-type-parameter name="ymd_type_"/>
      <template-type-parameter name="date_int_type_"/>
    </template>
          <purpose>An implementation of the Gregorian calendar. </purpose>
          <description>
            <para>This is a parameterized implementation of a proleptic Gregorian Calendar that can be used in the creation of date systems or just to perform calculations. All the methods of this class are static functions, so the intent is to never create instances of this class. 
</para>
          </description>
          <typedef name="ymd_type">
            <purpose>define a type a date split into components </purpose>
            <type>ymd_type_</type>
          </typedef>
          <typedef name="month_type">
            <purpose>define a type for representing months </purpose>
            <type>ymd_type::month_type</type>
          </typedef>
          <typedef name="day_type">
            <purpose>define a type for representing days </purpose>
            <type>ymd_type::day_type</type>
          </typedef>
          <typedef name="year_type">
            <purpose>Type to hold a stand alone year value (eg: 2002). </purpose>
            <type>ymd_type::year_type</type>
          </typedef>
          <typedef name="date_int_type">
            <purpose>Define the integer type to use for internal calculations. </purpose>
            <type>date_int_type_</type>
          </typedef>
          <method-group name="public static functions">
            <method name="day_of_week" cv="">
              <type>unsigned short</type>
              <parameter name="ymd">
                <paramtype>const ymd_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="week_number" cv="">
              <type>int</type>
              <parameter name="ymd">
                <paramtype>const ymd_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="day_number" cv="">
              <type>date_int_type</type>
              <parameter name="ymd">
                <paramtype>const ymd_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="julian_day_number" cv="">
              <type>date_int_type</type>
              <parameter name="ymd">
                <paramtype>const ymd_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="modjulian_day_number" cv="">
              <type>long</type>
              <parameter name="ymd">
                <paramtype>const ymd_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="from_day_number" cv="">
              <type>ymd_type</type>
              <parameter name="">
                <paramtype>date_int_type</paramtype>
              </parameter>
            </method>
            <method name="from_julian_day_number" cv="">
              <type>ymd_type</type>
              <parameter name="">
                <paramtype>date_int_type</paramtype>
              </parameter>
            </method>
            <method name="from_modjulian_day_number" cv="">
              <type>ymd_type</type>
              <parameter name="">
                <paramtype>long</paramtype>
              </parameter>
            </method>
            <method name="is_leap_year" cv="">
              <type>bool</type>
              <parameter name="">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
            <method name="end_of_month_day" cv="">
              <type>unsigned short</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
              <parameter name="m">
                <paramtype>month_type</paramtype>
              </parameter>
            </method>
            <method name="epoch" cv="">
              <type>ymd_type</type>
            </method>
            <method name="days_in_week" cv="">
              <type>unsigned short</type>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/int_adapter.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="int_adapter">
          <template>
      <template-type-parameter name="int_type_"/>
    </template>
          <purpose>Adapter to create integer types with +-infinity, and not a value. </purpose>
          <description>
            <para>This class is used internally in counted date/time representations. It adds the floating point like features of infinities and not a number. It also provides mathmatical operations with consideration to special values following these rules: <programlisting>  +infinity  -  infinity  == Not A Number (NAN)
   infinity  *  non-zero  == infinity
   infinity  *  zero      == NAN
  +infinity  * -integer   == -infinity
   infinity  /  infinity  == NAN
   infinity  *  infinity  == infinity 
 *
</programlisting></para>
          </description>
          <typedef name="int_type">
            <type>int_type_</type>
          </typedef>
          <method-group name="public member functions">
            <method name="is_infinity" cv="const">
              <type>bool</type>
            </method>
            <method name="is_pos_infinity" cv="const">
              <type>bool</type>
            </method>
            <method name="is_neg_infinity" cv="const">
              <type>bool</type>
            </method>
            <method name="is_nan" cv="const">
              <type>bool</type>
            </method>
            <method name="is_special" cv="const">
              <type>bool</type>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const int &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator!=" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator!=" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const int &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&lt;" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&lt;" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const int &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&gt;" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="as_number" cv="const">
              <type>int_type</type>
            </method>
            <method name="as_special" cv="const">
              <type>special_values</type>
              <purpose>Returns either special value type or is_not_special. </purpose>
            </method>
            <method name="operator+" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <template>
          <template-type-parameter name="rhs_type"/>
        </template>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname>&lt; rhs_type &gt; &amp;</paramtype>
              </parameter>
              <description>
                <para>Operator allows for adding dissimilar int_adapter types. The return type will match that of the the calling object's type </para>
              </description>
            </method>
            <method name="operator+" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator-" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <template>
          <template-type-parameter name="rhs_type"/>
        </template>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname>&lt; rhs_type &gt; &amp;</paramtype>
              </parameter>
              <description>
                <para>Operator allows for subtracting dissimilar int_adapter types. The return type will match that of the the calling object's type </para>
              </description>
            </method>
            <method name="operator-" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator *" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator *" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int</paramtype>
              </parameter>
              <description>
                <para>Provided for cases when automatic conversion from 'int' to 'int_adapter' causes incorrect results. </para>
              </description>
            </method>
            <method name="operator/" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator/" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int</paramtype>
              </parameter>
              <description>
                <para>Provided for cases when automatic conversion from 'int' to 'int_adapter' causes incorrect results. </para>
              </description>
            </method>
            <method name="operator%" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator%" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int</paramtype>
              </parameter>
              <description>
                <para>Provided for cases when automatic conversion from 'int' to 'int_adapter' causes incorrect results. </para>
              </description>
            </method>
          </method-group>
          <constructor>
            <parameter name="v">
              <paramtype>int_type</paramtype>
            </parameter>
          </constructor>
          <method-group name="public static functions">
            <method name="has_infinity" cv="">
              <type>bool</type>
            </method>
            <method name="pos_infinity" cv="">
              <type>const <classname>int_adapter</classname></type>
            </method>
            <method name="neg_infinity" cv="">
              <type>const <classname>int_adapter</classname></type>
            </method>
            <method name="not_a_number" cv="">
              <type>const <classname>int_adapter</classname></type>
            </method>
            <method name="BOOST_PREVENT_MACRO_SUBSTITUTION" cv="">
              <type><classname>int_adapter</classname> max</type>
            </method>
            <method name="BOOST_PREVENT_MACRO_SUBSTITUTION" cv="">
              <type><classname>int_adapter</classname> min</type>
            </method>
            <method name="from_special" cv="">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="sv">
                <paramtype>special_values</paramtype>
              </parameter>
            </method>
            <method name="is_inf" cv="">
              <type>bool</type>
              <parameter name="v">
                <paramtype>int_type</paramtype>
              </parameter>
            </method>
            <method name="is_neg_inf" cv="">
              <type>bool</type>
              <parameter name="v">
                <paramtype>int_type</paramtype>
              </parameter>
            </method>
            <method name="is_pos_inf" cv="">
              <type>bool</type>
              <parameter name="v">
                <paramtype>int_type</paramtype>
              </parameter>
            </method>
            <method name="is_not_a_number" cv="">
              <type>bool</type>
              <parameter name="v">
                <paramtype>int_type</paramtype>
              </parameter>
            </method>
            <method name="to_special" cv="">
              <type>special_values</type>
              <parameter name="v">
                <paramtype>int_type</paramtype>
              </parameter>
              <purpose>Returns either special value type or is_not_special. </purpose>
            </method>
            <method name="maxcount" cv="">
              <type>int_type</type>
            </method>
          </method-group>
          <method-group name="private member functions">
            <method name="compare" cv="const">
              <type>int</type>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname> &amp;</paramtype>
              </parameter>
              <purpose>returns -1, 0, 1, or 2 if 'this' is &lt;, ==, &gt;, or 'nan comparison' rhs </purpose>
            </method>
            <method name="mult_div_specials" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname> &amp;</paramtype>
              </parameter>
              <purpose>Assumes at least 'this' or 'rhs' is a special value. </purpose>
            </method>
            <method name="mult_div_specials" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int &amp;</paramtype>
              </parameter>
              <purpose>Assumes 'this' is a special value. </purpose>
            </method>
          </method-group>
        </class>
        <function name="operator&lt;&lt;">
          <type>std::basic_ostream&lt; charT, traits &gt; &amp;</type>
          <template>
          <template-type-parameter name="charT"/>
          <template-type-parameter name="traits"/>
          <template-type-parameter name="int_type"/>
        </template>
          <parameter name="os">
            <paramtype>std::basic_ostream&lt; charT, traits &gt; &amp;</paramtype>
          </parameter>
          <parameter name="ia">
            <paramtype>const <classname>int_adapter</classname>&lt; int_type &gt; &amp;</paramtype>
          </parameter>
          <description>
            <para>Expected output is either a numeric representation or a special values representation.
 Ex. "12", "+infinity", "not-a-number", etc. </para>
          </description>
        </function>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/iso_format.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="iso_format_base">
          <template>
      <template-type-parameter name="charT"/>
    </template>
          <purpose>Class to provide common iso formatting spec. </purpose>
          <method-group name="public static functions">
            <method name="month_format" cv="">
              <type>month_format_spec</type>
              <purpose>Describe month format -- its an integer in iso format. </purpose>
            </method>
            <method name="not_a_date" cv="">
              <type>const charT *</type>
              <purpose>String used printed is date is invalid. </purpose>
            </method>
            <method name="pos_infinity" cv="">
              <type>const charT *</type>
              <purpose>String used to for positive infinity value. </purpose>
            </method>
            <method name="neg_infinity" cv="">
              <type>const charT *</type>
              <purpose>String used to for positive infinity value. </purpose>
            </method>
            <method name="year_sep_char" cv="">
              <type>charT</type>
              <purpose>ISO char for a year -- used in durations. </purpose>
            </method>
            <method name="month_sep_char" cv="">
              <type>charT</type>
              <purpose>ISO char for a month. </purpose>
            </method>
            <method name="day_sep_char" cv="">
              <type>charT</type>
              <purpose>ISO char for a day. </purpose>
            </method>
            <method name="hour_sep_char" cv="">
              <type>charT</type>
              <purpose>char for minute </purpose>
            </method>
            <method name="minute_sep_char" cv="">
              <type>charT</type>
              <purpose>char for minute </purpose>
            </method>
            <method name="second_sep_char" cv="">
              <type>charT</type>
              <purpose>char for second </purpose>
            </method>
            <method name="period_start_char" cv="">
              <type>charT</type>
              <purpose>ISO char for a period. </purpose>
            </method>
            <method name="time_start_char" cv="">
              <type>charT</type>
              <purpose>Used in time in mixed strings to set start of time. </purpose>
            </method>
            <method name="week_start_char" cv="">
              <type>charT</type>
              <purpose>Used in mixed strings to identify start of a week number. </purpose>
            </method>
            <method name="period_sep_char" cv="">
              <type>charT</type>
              <purpose>Separators for periods. </purpose>
            </method>
            <method name="time_sep_char" cv="">
              <type>charT</type>
              <purpose>Separator for hh:mm:ss. </purpose>
            </method>
            <method name="fractional_time_sep_char" cv="">
              <type>charT</type>
              <purpose>Preferred Separator for hh:mm:ss,decimal_fraction. </purpose>
            </method>
            <method name="is_component_sep" cv="">
              <type>bool</type>
              <parameter name="sep">
                <paramtype>charT</paramtype>
              </parameter>
            </method>
            <method name="is_fractional_time_sep" cv="">
              <type>bool</type>
              <parameter name="sep">
                <paramtype>charT</paramtype>
              </parameter>
            </method>
            <method name="is_timezone_sep" cv="">
              <type>bool</type>
              <parameter name="sep">
                <paramtype>charT</paramtype>
              </parameter>
            </method>
            <method name="element_sep_char" cv="">
              <type>charT</type>
            </method>
          </method-group>
        </class>
        <class-specialization name="iso_format_base">
          <template>
    </template>
          <specialization>
            <template-arg>wchar_t</template-arg>
          </specialization>
          <purpose>Class to provide common iso formatting spec. </purpose>
          <method-group name="public static functions">
            <method name="month_format" cv="">
              <type>month_format_spec</type>
              <purpose>Describe month format -- its an integer in iso format. </purpose>
            </method>
            <method name="not_a_date" cv="">
              <type>const wchar_t *</type>
              <purpose>String used printed is date is invalid. </purpose>
            </method>
            <method name="pos_infinity" cv="">
              <type>const wchar_t *</type>
              <purpose>String used to for positive infinity value. </purpose>
            </method>
            <method name="neg_infinity" cv="">
              <type>const wchar_t *</type>
              <purpose>String used to for positive infinity value. </purpose>
            </method>
            <method name="year_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>ISO char for a year -- used in durations. </purpose>
            </method>
            <method name="month_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>ISO char for a month. </purpose>
            </method>
            <method name="day_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>ISO char for a day. </purpose>
            </method>
            <method name="hour_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>char for minute </purpose>
            </method>
            <method name="minute_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>char for minute </purpose>
            </method>
            <method name="second_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>char for second </purpose>
            </method>
            <method name="period_start_char" cv="">
              <type>wchar_t</type>
              <purpose>ISO char for a period. </purpose>
            </method>
            <method name="time_start_char" cv="">
              <type>wchar_t</type>
              <purpose>Used in time in mixed strings to set start of time. </purpose>
            </method>
            <method name="week_start_char" cv="">
              <type>wchar_t</type>
              <purpose>Used in mixed strings to identify start of a week number. </purpose>
            </method>
            <method name="period_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>Separators for periods. </purpose>
            </method>
            <method name="time_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>Separator for hh:mm:ss. </purpose>
            </method>
            <method name="fractional_time_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>Preferred Separator for hh:mm:ss,decimal_fraction. </purpose>
            </method>
            <method name="is_component_sep" cv="">
              <type>bool</type>
              <parameter name="sep">
                <paramtype>wchar_t</paramtype>
              </parameter>
            </method>
            <method name="is_fractional_time_sep" cv="">
              <type>bool</type>
              <parameter name="sep">
                <paramtype>wchar_t</paramtype>
              </parameter>
            </method>
            <method name="is_timezone_sep" cv="">
              <type>bool</type>
              <parameter name="sep">
                <paramtype>wchar_t</paramtype>
              </parameter>
            </method>
            <method name="element_sep_char" cv="">
              <type>wchar_t</type>
            </method>
          </method-group>
        </class-specialization>
        <class name="iso_format">
          <template>
      <template-type-parameter name="charT"/>
    </template>
          <inherit access="public">boost::date_time::iso_format_base&lt; charT &gt;</inherit>
          <purpose>Format description for iso normal YYYYMMDD. </purpose>
          <method-group name="public static functions">
            <method name="has_date_sep_chars" cv="">
              <type>bool</type>
              <purpose>The ios standard format doesn't use char separators. </purpose>
            </method>
          </method-group>
        </class>
        <class name="iso_extended_format">
          <template>
      <template-type-parameter name="charT"/>
    </template>
          <inherit access="public">boost::date_time::iso_format_base&lt; charT &gt;</inherit>
          <purpose>Extended format uses seperators YYYY-MM-DD. </purpose>
          <method-group name="public static functions">
            <method name="has_date_sep_chars" cv="">
              <type>bool</type>
              <purpose>Extended format needs char separators. </purpose>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/local_time_adjustor.hpp">
    <para>Time adjustment calculations for local times</para>
    <namespace name="boost">
      <namespace name="date_time">
        <class name="utc_adjustment">
          <template>
      <template-type-parameter name="time_duration_type"/>
      <template-nontype-parameter name="hours"><type>short</type></template-nontype-parameter>
      <template-nontype-parameter name="minutes"><type>unsigned short</type><default>0</default></template-nontype-parameter>
    </template>
          <purpose>Provides a base offset adjustment from utc. </purpose>
          <method-group name="public static functions">
            <method name="local_to_utc_base_offset" cv="">
              <type>time_duration_type</type>
            </method>
            <method name="utc_to_local_base_offset" cv="">
              <type>time_duration_type</type>
            </method>
          </method-group>
        </class>
        <class name="dynamic_local_time_adjustor">
          <template>
      <template-type-parameter name="time_type"/>
      <template-type-parameter name="dst_rules"/>
    </template>
          <purpose>Allow sliding utc adjustment with fixed dst rules. </purpose>
          <typedef name="time_duration_type">
            <type>time_type::time_duration_type</type>
          </typedef>
          <typedef name="date_type">
            <type>time_type::date_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="utc_offset" cv="">
              <type>time_duration_type</type>
              <parameter name="is_dst">
                <paramtype>bool</paramtype>
              </parameter>
              <purpose>Presumes local time. </purpose>
            </method>
          </method-group>
          <constructor>
            <parameter name="utc_offset">
              <paramtype>time_duration_type</paramtype>
            </parameter>
          </constructor>
        </class>
        <class name="static_local_time_adjustor">
          <template>
      <template-type-parameter name="time_type"/>
      <template-type-parameter name="dst_rules"/>
      <template-type-parameter name="utc_offset_rules"/>
    </template>
          <purpose>Embed the rules for local time adjustments at compile time. </purpose>
          <typedef name="time_duration_type">
            <type>time_type::time_duration_type</type>
          </typedef>
          <typedef name="date_type">
            <type>time_type::date_type</type>
          </typedef>
          <method-group name="public static functions">
            <method name="utc_to_local_offset" cv="">
              <type>time_duration_type</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
                <description>
                  <para>UTC time to calculate offset to local time This adjustment depends on the following observations about the workings of the DST boundary offset. Since UTC time labels are monotonically increasing we can determine if a given local time is in DST or not and therefore adjust the offset appropriately.</para>
                </description>
              </parameter>
              <purpose>Calculates the offset from a utc time to local based on dst and utc offset. </purpose>
              <description>
                <para>
The logic is as follows. Starting with UTC time use the offset to create a label for an non-dst adjusted local time. Then call dst_rules::local_is_dst with the non adjust local time. The results of this function will either unabiguously decide that the initial local time is in dst or return an illegal or ambiguous result. An illegal result only occurs at the end of dst (where labels are skipped) and indicates that dst has ended. An ambiguous result means that we need to recheck by making a dst adjustment and then rechecking. If the dst offset is added to the utc time and the recheck proves non-ambiguous then we are past the boundary. If it is still ambiguous then we are ahead of the boundary and dst is still in effect.</para>
                <para>TODO -- check if all dst offsets are positive. If not then the algorithm needs to check for this and reverse the illegal/ambiguous logic. </para>
              </description>
            </method>
            <method name="local_to_utc_offset" cv="">
              <type>time_duration_type</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
              <parameter name="dst">
                <paramtype>date_time::dst_flags</paramtype>
                <default>date_time::calculate</default>
              </parameter>
              <purpose>Get the offset to UTC given a local time. </purpose>
            </method>
          </method-group>
        </class>
        <class name="local_adjustor">
          <template>
      <template-type-parameter name="time_type"/>
      <template-nontype-parameter name="utc_offset"><type>short</type></template-nontype-parameter>
      <template-type-parameter name="dst_rule"/>
    </template>
          <purpose>Template that simplifies the creation of local time calculator. </purpose>
          <description>
            <para>Use this template to create the timezone to utc convertors as required.</para>
            <para>This class will also work for other regions that don't use dst and have a utc offset which is an integral number of hours.</para>
            <para><emphasis role="bold">Template Parameters</emphasis>  -time_type -- Time class to use -utc_offset -- Number hours local time is adjust from utc -use_dst -- true (default) if region uses dst, false otherwise For example: <programlisting>  //eastern timezone is utc-5
     typedef date_time::local_adjustor&lt;ptime, -5, us_dst&gt; us_eastern;
     typedef date_time::local_adjustor&lt;ptime, -6, us_dst&gt; us_central;
     typedef date_time::local_adjustor&lt;ptime, -7, us_dst&gt; us_mountain;
     typedef date_time::local_adjustor&lt;ptime, -8, us_dst&gt; us_pacific;
     typedef date_time::local_adjustor&lt;ptime, -7, no_dst&gt; us_arizona;
</programlisting></para>
          </description>
          <typedef name="time_duration_type">
            <type>time_type::time_duration_type</type>
          </typedef>
          <typedef name="date_type">
            <type>time_type::date_type</type>
          </typedef>
          <typedef name="dst_adjustor">
            <type><classname>static_local_time_adjustor</classname>&lt; time_type, dst_rule, <classname>utc_adjustment</classname>&lt; time_duration_type, utc_offset &gt; &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="utc_to_local" cv="">
              <type>time_type</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
              <purpose>Convert a utc time to local time. </purpose>
            </method>
            <method name="local_to_utc" cv="">
              <type>time_type</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
              <parameter name="dst">
                <paramtype>date_time::dst_flags</paramtype>
                <default>date_time::calculate</default>
              </parameter>
              <purpose>Convert a local time to utc. </purpose>
            </method>
          </method-group>
        </class>
        <function name="dummy_to_prevent_msvc6_ice">
          <type>void</type>
        </function>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/local_time_base.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="local_time_base">
          <template>
      <template-type-parameter name="utc_time_type"/>
      <template-type-parameter name="tz_type"/>
    </template>
          <method-group name="public member functions">
            <method name="zone" cv="const">
              <type>boost::shared_ptr&lt; tz_type &gt;</type>
            </method>
          </method-group>
          <constructor>
            <parameter name="t">
              <paramtype>utc_time_type</paramtype>
            </parameter>
            <parameter name="tz">
              <paramtype>boost::shared_ptr&lt; tz_type &gt;</paramtype>
            </parameter>
            <parameter name="dst_flag">
              <paramtype>bool</paramtype>
            </parameter>
          </constructor>
          <destructor/>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/local_timezone_defs.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <struct name="us_dst_trait">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>Specification for daylight savings start rules in US. </purpose>
          <description>
            <para>This class is used to configure dst_calc_engine template typically as follows: <programlisting>          using namespace boost::gregorian;
          using namespace boost::posix_time;
          typedef us_dst_trait&lt;date&gt; us_dst_traits;
          typedef boost::date_time::dst_calc_engine&lt;date, time_duration, 
                                                    us_dst_traits&gt;  
                                                    us_dst_calc;
          //calculate the 2002 transition day of USA April 7 2002
          date dst_start = us_dst_calc::local_dst_start_day(2002); 

          //calculate the 2002 transition day of USA Oct 27 2002
          date dst_end = us_dst_calc::local_dst_end_day(2002); 
                                                    
          //check if a local time is in dst or not -- posible answers
          //are yes, no, invalid time label, ambiguous
          ptime t(...some time...);  
          if (us_dst::local_is_dst(t.date(), t.time_of_day()) 
              == boost::date_time::is_not_in_dst) 
          {

          }
</programlisting>This generates a type suitable for the calculation of dst transitions for the United States. Of course other templates can be used for other locales. </para>
          </description>
          <typedef name="day_of_week_type">
            <type>date_type::day_of_week_type</type>
          </typedef>
          <typedef name="month_type">
            <type>date_type::month_type</type>
          </typedef>
          <typedef name="start_rule_functor">
            <type><classname>date_time::first_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="end_rule_functor">
            <type><classname>date_time::last_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="start_day" cv="">
              <type>day_of_week_type</type>
            </method>
            <method name="start_month" cv="">
              <type>month_type</type>
            </method>
            <method name="end_day" cv="">
              <type>day_of_week_type</type>
            </method>
            <method name="end_month" cv="">
              <type>month_type</type>
            </method>
            <method name="dst_start_offset_minutes" cv="">
              <type>int</type>
            </method>
            <method name="dst_end_offset_minutes" cv="">
              <type>int</type>
            </method>
            <method name="dst_shift_length_minutes" cv="">
              <type>int</type>
            </method>
          </method-group>
        </struct>
        <struct name="eu_dst_trait">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>Rules for daylight savings start in the EU (Last Sun in Mar). </purpose>
          <description>
            <para>These amount to the following:<itemizedlist>
<listitem><para>Start of dst day is last Sunday in March</para></listitem><listitem><para>End day of dst is last Sunday in Oct</para></listitem><listitem><para>Going forward switch time is 2:00 am (offset 120 minutes)</para></listitem><listitem><para>Going back switch time is 3:00 am (off set 180 minutes)</para></listitem><listitem><para>Shift duration is one hour (60 minutes) </para></listitem></itemizedlist>
</para>
          </description>
          <typedef name="day_of_week_type">
            <type>date_type::day_of_week_type</type>
          </typedef>
          <typedef name="month_type">
            <type>date_type::month_type</type>
          </typedef>
          <typedef name="start_rule_functor">
            <type><classname>date_time::last_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="end_rule_functor">
            <type><classname>date_time::last_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="start_day" cv="">
              <type>day_of_week_type</type>
            </method>
            <method name="start_month" cv="">
              <type>month_type</type>
            </method>
            <method name="end_day" cv="">
              <type>day_of_week_type</type>
            </method>
            <method name="end_month" cv="">
              <type>month_type</type>
            </method>
            <method name="dst_start_offset_minutes" cv="">
              <type>int</type>
            </method>
            <method name="dst_end_offset_minutes" cv="">
              <type>int</type>
            </method>
            <method name="dst_shift_length_minutes" cv="">
              <type>int</type>
            </method>
          </method-group>
        </struct>
        <struct name="uk_dst_trait">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <inherit access="public">boost::date_time::eu_dst_trait&lt; date_type &gt;</inherit>
          <purpose>Alternative dst traits for some parts of the United Kingdom. </purpose>
          <method-group name="public static functions">
            <method name="dst_start_offset_minutes" cv="">
              <type>int</type>
            </method>
            <method name="dst_end_offset_minutes" cv="">
              <type>int</type>
            </method>
            <method name="dst_shift_length_minutes" cv="">
              <type>int</type>
            </method>
          </method-group>
        </struct>
        <struct name="acst_dst_trait">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <typedef name="day_of_week_type">
            <type>date_type::day_of_week_type</type>
          </typedef>
          <typedef name="month_type">
            <type>date_type::month_type</type>
          </typedef>
          <typedef name="start_rule_functor">
            <type><classname>date_time::last_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="end_rule_functor">
            <type><classname>date_time::last_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="start_day" cv="">
              <type>day_of_week_type</type>
            </method>
            <method name="start_month" cv="">
              <type>month_type</type>
            </method>
            <method name="end_day" cv="">
              <type>day_of_week_type</type>
            </method>
            <method name="end_month" cv="">
              <type>month_type</type>
            </method>
            <method name="dst_start_offset_minutes" cv="">
              <type>int</type>
            </method>
            <method name="dst_end_offset_minutes" cv="">
              <type>int</type>
            </method>
            <method name="dst_shift_length_minutes" cv="">
              <type>int</type>
            </method>
          </method-group>
        </struct>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/locale_config.hpp"/>
  <header name="boost/date_time/microsec_time_clock.hpp">
    <para>This file contains a high resolution time clock implementation.</para>
    <namespace name="boost">
      <namespace name="date_time">
        <class name="microsec_clock">
          <template>
      <template-type-parameter name="time_type"/>
    </template>
          <purpose>A clock providing microsecond level resolution. </purpose>
          <description>
            <para>A high precision clock that measures the local time at a resolution up to microseconds and adjusts to the resolution of the time system. For example, for the a library configuration with nano second resolution, the last 3 places of the fractional seconds will always be 000 since there are 1000 nano-seconds in a micro second. </para>
          </description>
          <typedef name="date_type">
            <type>time_type::date_type</type>
          </typedef>
          <typedef name="time_duration_type">
            <type>time_type::time_duration_type</type>
          </typedef>
          <typedef name="resolution_traits_type">
            <type>time_duration_type::rep_type</type>
          </typedef>
          <method-group name="public static functions">
            <method name="local_time" cv="">
              <type>time_type</type>
              <template>
          <template-type-parameter name="time_zone_type"/>
        </template>
              <parameter name="tz_ptr">
                <paramtype>shared_ptr&lt; time_zone_type &gt;</paramtype>
              </parameter>
              <purpose>return a local time object for the given zone, based on computer clock </purpose>
            </method>
            <method name="local_time" cv="">
              <type>time_type</type>
              <purpose>Return the local time based on computer clock settings. </purpose>
            </method>
            <method name="universal_time" cv="">
              <type>time_type</type>
              <purpose>Get the current day in universal date as a ymd_type. </purpose>
            </method>
          </method-group>
          <method-group name="private static functions">
            <method name="create_time" cv="">
              <type>time_type</type>
              <parameter name="tz">
                <paramtype>TZ_FOR_CREATE</paramtype>
              </parameter>
            </method>
            <method name="local_time" cv="">
              <type>time_type</type>
              <purpose>Return the local time based on computer clock settings. </purpose>
            </method>
            <method name="universal_time" cv="">
              <type>time_type</type>
              <purpose>Return the UTC time based on computer settings. </purpose>
            </method>
            <method name="create_time" cv="">
              <type>time_type</type>
              <parameter name="ft">
                <paramtype>FILETIME &amp;</paramtype>
              </parameter>
              <parameter name="tz">
                <paramtype>TZ_FOR_CREATE</paramtype>
              </parameter>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/parse_format_base.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <enum name="month_format_spec">
          <enumvalue name="month_as_integer"/>
          <enumvalue name="month_as_short_string"/>
          <enumvalue name="month_as_long_string"/>
          <purpose>Enum for distinguishing parsing and formatting options. </purpose>
        </enum>
        <enum name="ymd_order_spec">
          <enumvalue name="ymd_order_iso"/>
          <enumvalue name="ymd_order_dmy"/>
          <enumvalue name="ymd_order_us"/>
          <purpose>Enum for distinguishing the order of Month, Day, &amp; Year. </purpose>
          <description>
            <para>Enum for distinguishing the order in which Month, Day, &amp; Year will appear in a date string </para>
          </description>
        </enum>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/period.hpp">
    <para>This file contain the implementation of the period abstraction. This is basically the same idea as a range. Although this class is intended for use in the time library, it is pretty close to general enough for other numeric uses.</para>
    <namespace name="boost">
      <namespace name="date_time">
        <class name="period">
          <template>
      <template-type-parameter name="point_rep"/>
      <template-type-parameter name="duration_rep"/>
    </template>
          <purpose>Provides generalized period type useful in date-time systems. </purpose>
          <description>
            <para>This template uses a class to represent a time point within the period and another class to represent a duration. As a result, this class is not appropriate for use when the number and duration representation are the same (eg: in the regular number domain).</para>
            <para>A period can be specified by providing either the starting point and a duration or the starting point and the end point( end is NOT part of the period but 1 unit past it. A period will be "invalid" if either start_point &gt;= end_point or the given duration is &lt; 0. Any valid period will return false for is_null().</para>
            <para>Zero length periods are considered valid. In this case the start point is exactly 1 unit less than the end point, in other words start is equal to last.</para>
            <para>In the case that the begin and last are the same, the period has a length of zero units. For example, suppose this is a period of days. That is, each time-point represents a single day. If the start and the last is the same day then the period is zero length.</para>
            <para>The best way to handle periods is usually to provide a start point and a duration. So, day1 + 7 days is a week period which includes all of the first day and 6 more days (eg: Sun to Sat). </para>
          </description>
          <typedef name="point_type">
            <type>point_rep</type>
          </typedef>
          <typedef name="duration_type">
            <type>duration_rep</type>
          </typedef>
          <method-group name="public member functions">
            <method name="begin" cv="const">
              <type>point_rep</type>
              <purpose>Return the first element in the period. </purpose>
            </method>
            <method name="end" cv="const">
              <type>point_rep</type>
              <purpose>Return one past the last element. </purpose>
            </method>
            <method name="last" cv="const">
              <type>point_rep</type>
              <purpose>Return the last item in the period. </purpose>
            </method>
            <method name="length" cv="const">
              <type>duration_rep</type>
              <purpose>Return the length of the period. </purpose>
            </method>
            <method name="is_null" cv="const">
              <type>bool</type>
              <purpose>True if period is ill formed (length less than zero). </purpose>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>period</classname> &amp;</paramtype>
              </parameter>
              <purpose>Equality operator. </purpose>
            </method>
            <method name="operator&lt;" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>period</classname> &amp;</paramtype>
              </parameter>
              <purpose>Strict as defined by rhs.last &lt;= lhs.last. </purpose>
            </method>
            <method name="shift" cv="">
              <type>void</type>
              <parameter name="d">
                <paramtype>const duration_rep &amp;</paramtype>
              </parameter>
              <purpose>Shift the start and end by the specified amount. </purpose>
            </method>
            <method name="contains" cv="const">
              <type>bool</type>
              <parameter name="point">
                <paramtype>const point_rep &amp;</paramtype>
              </parameter>
              <purpose>True if the point is inside the period. </purpose>
            </method>
            <method name="contains" cv="const">
              <type>bool</type>
              <parameter name="other">
                <paramtype>const <classname>period</classname> &amp;</paramtype>
              </parameter>
              <purpose>True if this period fully contains (or equals) the other period. </purpose>
            </method>
            <method name="intersects" cv="const">
              <type>bool</type>
              <parameter name="other">
                <paramtype>const <classname>period</classname> &amp;</paramtype>
              </parameter>
              <purpose>True if the periods overlap in any way. </purpose>
            </method>
            <method name="is_adjacent" cv="const">
              <type>bool</type>
              <parameter name="other">
                <paramtype>const <classname>period</classname> &amp;</paramtype>
              </parameter>
              <purpose>True if periods are next to each other without a gap. </purpose>
            </method>
            <method name="is_before" cv="const">
              <type>bool</type>
              <parameter name="point">
                <paramtype>const point_rep &amp;</paramtype>
              </parameter>
              <purpose>True if all of the period is prior to the passed point or end &lt;= t. </purpose>
            </method>
            <method name="is_after" cv="const">
              <type>bool</type>
              <parameter name="point">
                <paramtype>const point_rep &amp;</paramtype>
              </parameter>
              <purpose>True if all of the period is prior or t &lt; start. </purpose>
            </method>
            <method name="intersection" cv="const">
              <type>
                <classname>period</classname>
              </type>
              <parameter name="other">
                <paramtype>const <classname>period</classname> &amp;</paramtype>
              </parameter>
              <purpose>Returns the period of intersection or invalid range no intersection. </purpose>
            </method>
            <method name="merge" cv="const">
              <type>
                <classname>period</classname>
              </type>
              <parameter name="other">
                <paramtype>const <classname>period</classname> &amp;</paramtype>
              </parameter>
              <purpose>Returns the union of intersecting periods -- or null period. </purpose>
            </method>
            <method name="span" cv="const">
              <type>
                <classname>period</classname>
              </type>
              <parameter name="other">
                <paramtype>const <classname>period</classname> &amp;</paramtype>
              </parameter>
              <purpose>Combine two periods with earliest start and latest end. </purpose>
              <description>
                <para>Combines two periods and any gap between them such that start = min(p1.start, p2.start) end = max(p1.end , p2.end) <programlisting>        [---p1---)
                       [---p2---)
 result:
        [-----------p3----------) 
   *
</programlisting></para>
              </description>
            </method>
          </method-group>
          <constructor>
            <parameter name="first_point">
              <paramtype>point_rep</paramtype>
            </parameter>
            <parameter name="end_point">
              <paramtype>point_rep</paramtype>
            </parameter>
            <purpose>create a period from begin to last eg: [begin,end) </purpose>
            <description>
              <para>If end &lt;= begin then the period will be invalid </para>
            </description>
          </constructor>
          <constructor>
            <parameter name="first_point">
              <paramtype>point_rep</paramtype>
            </parameter>
            <parameter name="len">
              <paramtype>duration_rep</paramtype>
            </parameter>
            <purpose>create a period as [begin, begin+len) </purpose>
            <description>
              <para>If len is &lt; 0 then the period will be invalid </para>
            </description>
          </constructor>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/period_formatter.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="period_formatter">
          <template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="OutItrT"><default>std::ostreambuf_iterator&lt;CharT, std::char_traits&lt;CharT&gt; &gt;</default></template-type-parameter>
    </template>
          <purpose>Not a facet, but a class used to specify and control period formats. </purpose>
          <description>
            <para>Provides settings for the following:<itemizedlist>
<listitem><para>period_separator -- default '/'</para></listitem><listitem><para>period_open_start_delimeter -- default '['</para></listitem><listitem><para>period_open_range_end_delimeter -- default ')'</para></listitem><listitem><para>period_closed_range_end_delimeter -- default ']'</para></listitem><listitem><para>display_as_open_range, display_as_closed_range -- default open_range</para></listitem></itemizedlist>
</para>
            <para>Thus the default formatting for a period is as follows: <programlisting>  [period.start()/period.last()]
   *
</programlisting>So for a typical date_period this would be <programlisting>  [2004-Jan-04/2004-Feb-01]
   *
</programlisting>where the date formatting is controlled by the date facet </para>
          </description>
          <typedef name="string_type">
            <type>std::basic_string&lt; CharT &gt;</type>
          </typedef>
          <typedef name="char_type">
            <type>CharT</type>
          </typedef>
          <typedef name="const_itr_type">
            <type>std::basic_string&lt; char_type &gt;::const_iterator</type>
          </typedef>
          <enum name="range_display_options">
            <enumvalue name="AS_OPEN_RANGE"/>
            <enumvalue name="AS_CLOSED_RANGE"/>
          </enum>
          <method-group name="public member functions">
            <method name="put_period_separator" cv="const">
              <type>OutItrT</type>
              <parameter name="oitr">
                <paramtype>OutItrT &amp;</paramtype>
              </parameter>
              <purpose>Puts the characters between period elements into stream -- default is /. </purpose>
            </method>
            <method name="put_period_start_delimeter" cv="const">
              <type>OutItrT</type>
              <parameter name="oitr">
                <paramtype>OutItrT &amp;</paramtype>
              </parameter>
              <purpose>Puts the period start characters into stream -- default is [. </purpose>
            </method>
            <method name="put_period_end_delimeter" cv="const">
              <type>OutItrT</type>
              <parameter name="oitr">
                <paramtype>OutItrT &amp;</paramtype>
              </parameter>
              <purpose>Puts the period end characters into stream as controled by open/closed range setting. </purpose>
            </method>
            <method name="range_option" cv="const">
              <type>range_display_options</type>
            </method>
            <method name="range_option" cv="const">
              <type>void</type>
              <parameter name="option">
                <paramtype>range_display_options</paramtype>
              </parameter>
              <purpose>Reset the range_option control. </purpose>
            </method>
            <method name="put_period" cv="const">
              <type>OutItrT</type>
              <template>
          <template-type-parameter name="period_type"/>
          <template-type-parameter name="facet_type"/>
        </template>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="a_fill">
                <paramtype>char_type</paramtype>
              </parameter>
              <parameter name="p">
                <paramtype>const period_type &amp;</paramtype>
              </parameter>
              <parameter name="facet">
                <paramtype>const facet_type &amp;</paramtype>
              </parameter>
              <purpose>Generic code to output a period -- no matter the period type. </purpose>
              <description>
                <para>This generic code will output any period using a facet to to output the 'elements'. For example, in the case of a date_period the elements will be instances of a date which will be formatted according the to setup in the passed facet parameter.</para>
                <para>The steps for formatting a period are always the same:<itemizedlist>
<listitem><para>put the start delimiter</para></listitem><listitem><para>put start element</para></listitem><listitem><para>put the separator</para></listitem><listitem><para>put either last or end element depending on range settings</para></listitem><listitem><para>put end delimeter depending on range settings</para></listitem></itemizedlist>
</para>
                <para>Thus for a typical date period the result might look like this: <programlisting>    [March 01, 2004/June 07, 2004]   &lt;-- closed range
    [March 01, 2004/June 08, 2004)   &lt;-- open range

     *
</programlisting></para>
              </description>
            </method>
          </method-group>
          <constructor>
            <parameter name="range_option">
              <paramtype>range_display_options</paramtype>
              <default>AS_CLOSED_RANGE</default>
            </parameter>
            <parameter name="period_separator">
              <paramtype>const char_type *const</paramtype>
              <default>default_period_separator</default>
            </parameter>
            <parameter name="period_start_delimeter">
              <paramtype>const char_type *const</paramtype>
              <default>default_period_start_delimeter</default>
            </parameter>
            <parameter name="period_open_range_end_delimeter">
              <paramtype>const char_type *const</paramtype>
              <default>default_period_open_range_end_delimeter</default>
            </parameter>
            <parameter name="period_closed_range_end_delimeter">
              <paramtype>const char_type *const</paramtype>
              <default>default_period_closed_range_end_delimeter</default>
            </parameter>
            <purpose>Constructor that sets up period formatter options -- default should suffice most cases. </purpose>
          </constructor>
          <data-member name="default_period_separator" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="default_period_start_delimeter" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="default_period_open_range_end_delimeter" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="default_period_closed_range_end_delimeter" specifiers="static">
            <type>const char_type</type>
          </data-member>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/special_defs.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <enum name="special_values">
          <enumvalue name="not_a_date_time"/>
          <enumvalue name="neg_infin"/>
          <enumvalue name="pos_infin"/>
          <enumvalue name="min_date_time"/>
          <enumvalue name="max_date_time"/>
          <enumvalue name="not_special"/>
          <enumvalue name="NumSpecialValues"/>
        </enum>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/special_values_formatter.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="special_values_formatter">
          <template>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="OutItrT"><default>std::ostreambuf_iterator&lt;CharT, std::char_traits&lt;CharT&gt; &gt;</default></template-type-parameter>
    </template>
          <purpose>Class that provides generic formmatting ostream formatting for special values. </purpose>
          <description>
            <para>This class provides for the formmating of special values to an output stream. In particular, it produces strings for the values of negative and positive infinity as well as not_a_date_time.</para>
            <para>While not a facet, this class is used by the date and time facets for formatting special value types. </para>
          </description>
          <typedef name="string_type">
            <type>std::basic_string&lt; CharT &gt;</type>
          </typedef>
          <typedef name="char_type">
            <type>CharT</type>
          </typedef>
          <typedef name="collection_type">
            <type>std::vector&lt; string_type &gt;</type>
          </typedef>
          <method-group name="public member functions">
            <method name="put_special" cv="const">
              <type>OutItrT</type>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="value">
                <paramtype>const boost::date_time::special_values</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <purpose>Construct special values formatter using default strings. </purpose>
            <description>
              <para>Default strings are not-a-date-time -infinity +infinity </para>
            </description>
          </constructor>
          <constructor>
            <parameter name="begin">
              <paramtype>const char_type *const *</paramtype>
            </parameter>
            <parameter name="end">
              <paramtype>const char_type *const *</paramtype>
            </parameter>
            <purpose>Construct special values formatter from array of strings. </purpose>
            <description>
              <para>This constructor will take pair of iterators from an array of strings that represent the special values and copy them for use in formatting special values. <programlisting>  const char* const special_value_names[]={"nadt","-inf","+inf" };

  special_value_formatter svf(&amp;special_value_names[0], &amp;special_value_names[3]);
     *
</programlisting></para>
            </description>
          </constructor>
          <data-member name="default_special_value_names" specifiers="static">
            <type>const char_type</type>
            <purpose>Storage for the strings used to indicate special values. </purpose>
          </data-member>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/string_parse_tree.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <struct name="parse_match_result">
          <template>
      <template-type-parameter name="charT"/>
    </template>
          <typedef name="string_type">
            <type>std::basic_string&lt; charT &gt;</type>
          </typedef>
          <method-group name="public member functions">
            <method name="remaining" cv="const">
              <type>string_type</type>
            </method>
            <method name="last_char" cv="const">
              <type>charT</type>
            </method>
            <method name="has_remaining" cv="const">
              <type>bool</type>
            </method>
          </method-group>
          <constructor/>
          <data-member name="cache">
            <type>string_type</type>
          </data-member>
          <data-member name="match_depth">
            <type>unsigned short</type>
          </data-member>
          <data-member name="current_match">
            <type>unsigned short</type>
          </data-member>
        </struct>
        <struct name="string_parse_tree">
          <template>
      <template-type-parameter name="charT"/>
    </template>
          <purpose>Recursive data structure to allow efficient parsing of various strings. </purpose>
          <description>
            <para>This class provides a quick lookup by building what amounts to a tree data structure. It also features a match function which can can handle nasty input interators by caching values as it recurses the tree so that it can backtrack as needed. </para>
          </description>
          <typedef name="ptree_coll">
            <type>std::multimap&lt; charT, <classname>string_parse_tree</classname> &gt;</type>
          </typedef>
          <typedef name="value_type">
            <type>ptree_coll::value_type</type>
          </typedef>
          <typedef name="iterator">
            <type>ptree_coll::iterator</type>
          </typedef>
          <typedef name="const_iterator">
            <type>ptree_coll::const_iterator</type>
          </typedef>
          <typedef name="string_type">
            <type>std::basic_string&lt; charT &gt;</type>
          </typedef>
          <typedef name="collection_type">
            <type>std::vector&lt; std::basic_string&lt; charT &gt; &gt;</type>
          </typedef>
          <typedef name="parse_match_result_type">
            <type>parse_match_result&lt; charT &gt;</type>
          </typedef>
          <method-group name="public member functions">
            <method name="insert" cv="">
              <type>void</type>
              <parameter name="s">
                <paramtype>const string_type &amp;</paramtype>
              </parameter>
              <parameter name="value">
                <paramtype>unsigned short</paramtype>
              </parameter>
            </method>
            <method name="match" cv="const">
              <type>unsigned short</type>
              <parameter name="sitr">
                <paramtype>std::istreambuf_iterator&lt; charT &gt; &amp;</paramtype>
              </parameter>
              <parameter name="stream_end">
                <paramtype>std::istreambuf_iterator&lt; charT &gt; &amp;</paramtype>
              </parameter>
              <parameter name="result">
                <paramtype>parse_match_result_type &amp;</paramtype>
              </parameter>
              <parameter name="level">
                <paramtype>unsigned int &amp;</paramtype>
              </parameter>
            </method>
            <method name="match" cv="const">
              <type>parse_match_result_type</type>
              <parameter name="sitr">
                <paramtype>std::istreambuf_iterator&lt; charT &gt; &amp;</paramtype>
              </parameter>
              <parameter name="stream_end">
                <paramtype>std::istreambuf_iterator&lt; charT &gt; &amp;</paramtype>
              </parameter>
            </method>
            <method name="printme" cv="">
              <type>void</type>
              <parameter name="os">
                <paramtype>std::ostream &amp;</paramtype>
              </parameter>
              <parameter name="level">
                <paramtype>int &amp;</paramtype>
              </parameter>
            </method>
            <method name="print" cv="">
              <type>void</type>
              <parameter name="os">
                <paramtype>std::ostream &amp;</paramtype>
              </parameter>
            </method>
            <method name="printmatch" cv="">
              <type>void</type>
              <parameter name="os">
                <paramtype>std::ostream &amp;</paramtype>
              </parameter>
              <parameter name="c">
                <paramtype>charT</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="names">
              <paramtype>collection_type</paramtype>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="value">
              <paramtype>unsigned short</paramtype>
              <default>0</default>
            </parameter>
          </constructor>
          <data-member name="m_next_chars">
            <type>ptree_coll</type>
          </data-member>
          <data-member name="m_value">
            <type>unsigned short</type>
          </data-member>
        </struct>
        <function name="operator&lt;&lt;">
          <type>std::basic_ostream&lt; charT &gt; &amp;</type>
          <template>
          <template-type-parameter name="charT"/>
        </template>
          <parameter name="os">
            <paramtype>std::basic_ostream&lt; charT &gt; &amp;</paramtype>
          </parameter>
          <parameter name="mr">
            <paramtype>parse_match_result&lt; charT &gt; &amp;</paramtype>
          </parameter>
        </function>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/strings_from_facet.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <function name="gather_month_strings">
          <type>std::vector&lt; std::basic_string&lt; charT &gt; &gt;</type>
          <template>
          <template-type-parameter name="charT"/>
        </template>
          <parameter name="locale">
            <paramtype>const std::locale &amp;</paramtype>
            <description>
              <para>The locale to use when gathering the strings </para>
            </description>
          </parameter>
          <parameter name="short_strings">
            <paramtype>bool</paramtype>
            <default>true</default>
            <description>
              <para>True(default) to gather short strings, false for long strings. </para>
            </description>
          </parameter>
          <purpose>This function gathers up all the month strings from a std::locale. </purpose>
          <description>
            <para>Using the time_put facet, this function creates a collection of all the month strings from a locale. This is handy when building custom date parsers or formatters that need to be localized.</para>
            <para>

</para>
          </description>
          <returns>
            <para>A vector of strings containing the strings in order. eg: Jan, Feb, Mar, etc. </para>
          </returns>
        </function>
        <function name="gather_weekday_strings">
          <type>std::vector&lt; std::basic_string&lt; charT &gt; &gt;</type>
          <template>
          <template-type-parameter name="charT"/>
        </template>
          <parameter name="locale">
            <paramtype>const std::locale &amp;</paramtype>
            <description>
              <para>The locale to use when gathering the strings </para>
            </description>
          </parameter>
          <parameter name="short_strings">
            <paramtype>bool</paramtype>
            <default>true</default>
            <description>
              <para>True(default) to gather short strings, false for long strings. </para>
            </description>
          </parameter>
          <purpose>This function gathers up all the weekday strings from a std::locale. </purpose>
          <description>
            <para>Using the time_put facet, this function creates a collection of all the weekday strings from a locale starting with the string for 'Sunday'. This is handy when building custom date parsers or formatters that need to be localized.</para>
            <para>

</para>
          </description>
          <returns>
            <para>A vector of strings containing the weekdays in order. eg: Sun, Mon, Tue, Wed, Thu, Fri, Sat </para>
          </returns>
        </function>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time.hpp">
    <para>This file contains the interface for the time associated classes.</para>
    <namespace name="boost">
      <namespace name="date_time">
        <class name="base_time">
          <template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="time_system"/>
    </template>
          <purpose>Representation of a precise moment in time, including the date. </purpose>
          <description>
            <para>This class is a skeleton for the interface of a temporal type with a resolution that is higher than a day. It is intended that this class be the base class and that the actual time class be derived using the BN pattern. In this way, the derived class can make decisions such as 'should there be a default constructor' and what should it set its value to, should there be optional constructors say allowing only an time_durations that generate a time from a clock,etc. So, in fact multiple time types can be created for a time_system with different construction policies, and all of them can perform basic operations by only writing a copy constructor. Finally, compiler errors are also shorter.</para>
            <para>The real behavior of the time class is provided by the time_system template parameter. This class must provide all the logic for addition, subtraction, as well as define all the interface types. </para>
          </description>
          <typedef name="time_type">
            <type>T</type>
          </typedef>
          <typedef name="time_rep_type">
            <type>time_system::time_rep_type</type>
          </typedef>
          <typedef name="date_type">
            <type>time_system::date_type</type>
          </typedef>
          <typedef name="date_duration_type">
            <type>time_system::date_duration_type</type>
          </typedef>
          <typedef name="time_duration_type">
            <type>time_system::time_duration_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="date" cv="const">
              <type>date_type</type>
            </method>
            <method name="time_of_day" cv="const">
              <type>time_duration_type</type>
            </method>
            <method name="zone_name" cv="const">
              <type>std::string</type>
              <parameter name="as_offset">
                <paramtype>bool</paramtype>
                <default>false</default>
              </parameter>
              <description>
                <para>Optional bool parameter will return time zone as an offset (ie "+07:00"). Empty string is returned for classes that do not use a time_zone </para>
              </description>
            </method>
            <method name="zone_abbrev" cv="const">
              <type>std::string</type>
              <parameter name="as_offset">
                <paramtype>bool</paramtype>
                <default>false</default>
              </parameter>
              <description>
                <para>Optional bool parameter will return time zone as an offset (ie "+07:00"). Empty string is returned for classes that do not use a time_zone </para>
              </description>
            </method>
            <method name="is_not_a_date_time" cv="const">
              <type>bool</type>
              <purpose>check to see if date is not a value </purpose>
            </method>
            <method name="is_infinity" cv="const">
              <type>bool</type>
              <purpose>check to see if date is one of the infinity values </purpose>
            </method>
            <method name="is_pos_infinity" cv="const">
              <type>bool</type>
              <purpose>check to see if date is greater than all possible dates </purpose>
            </method>
            <method name="is_neg_infinity" cv="const">
              <type>bool</type>
              <purpose>check to see if date is greater than all possible dates </purpose>
            </method>
            <method name="is_special" cv="const">
              <type>bool</type>
              <purpose>check to see if time is a special value </purpose>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
              <purpose>Equality operator -- others generated by boost::equality_comparable. </purpose>
            </method>
            <method name="operator&lt;" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
              <purpose>Equality operator -- others generated by boost::less_than_comparable. </purpose>
            </method>
            <method name="operator-" cv="const">
              <type>time_duration_type</type>
              <parameter name="rhs">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
              <purpose>difference between two times </purpose>
            </method>
            <method name="operator+" cv="const">
              <type>time_type</type>
              <parameter name="dd">
                <paramtype>const date_duration_type &amp;</paramtype>
              </parameter>
              <purpose>add date durations </purpose>
            </method>
            <method name="operator+=" cv="">
              <type>time_type</type>
              <parameter name="dd">
                <paramtype>const date_duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-" cv="const">
              <type>time_type</type>
              <parameter name="dd">
                <paramtype>const date_duration_type &amp;</paramtype>
              </parameter>
              <purpose>subtract date durations </purpose>
            </method>
            <method name="operator-=" cv="">
              <type>time_type</type>
              <parameter name="dd">
                <paramtype>const date_duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator+" cv="const">
              <type>time_type</type>
              <parameter name="td">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <purpose>add time durations </purpose>
            </method>
            <method name="operator+=" cv="">
              <type>time_type</type>
              <parameter name="td">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-" cv="const">
              <type>time_type</type>
              <parameter name="rhs">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <purpose>subtract time durations </purpose>
            </method>
            <method name="operator-=" cv="">
              <type>time_type</type>
              <parameter name="td">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="day">
              <paramtype>const date_type &amp;</paramtype>
            </parameter>
            <parameter name="td">
              <paramtype>const time_duration_type &amp;</paramtype>
            </parameter>
            <parameter name="dst">
              <paramtype>dst_flags</paramtype>
              <default>not_dst</default>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="sv">
              <paramtype>special_values</paramtype>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="rhs">
              <paramtype>const time_rep_type &amp;</paramtype>
            </parameter>
          </constructor>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_clock.hpp">
    <para>This file contains the interface for clock devices.</para>
    <namespace name="boost">
      <namespace name="date_time">
        <class name="second_clock">
          <template>
      <template-type-parameter name="time_type"/>
    </template>
          <purpose>A clock providing time level services based on C time_t capabilities. </purpose>
          <description>
            <para>This clock provides resolution to the 1 second level </para>
          </description>
          <typedef name="date_type">
            <type>time_type::date_type</type>
          </typedef>
          <typedef name="time_duration_type">
            <type>time_type::time_duration_type</type>
          </typedef>
          <method-group name="public static functions">
            <method name="local_time" cv="">
              <type>time_type</type>
            </method>
            <method name="universal_time" cv="">
              <type>time_type</type>
              <purpose>Get the current day in universal date as a ymd_type. </purpose>
            </method>
            <method name="local_time" cv="">
              <type>time_type</type>
              <template>
          <template-type-parameter name="time_zone_type"/>
        </template>
              <parameter name="tz_ptr">
                <paramtype>boost::shared_ptr&lt; time_zone_type &gt;</paramtype>
              </parameter>
            </method>
          </method-group>
          <method-group name="private static functions">
            <method name="create_time" cv="">
              <type>time_type</type>
              <parameter name="current">
                <paramtype>::std::tm *</paramtype>
              </parameter>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_defs.hpp">
    <para>This file contains nice definitions for handling the resoluion of various time reprsentations.</para>
    <namespace name="boost">
      <namespace name="date_time">
        <enum name="time_resolutions">
          <enumvalue name="sec"/>
          <enumvalue name="tenth"/>
          <enumvalue name="hundreth"/>
          <enumvalue name="milli"/>
          <enumvalue name="ten_thousandth"/>
          <enumvalue name="micro"/>
          <enumvalue name="nano"/>
          <enumvalue name="NumResolutions"/>
          <purpose>Defines some nice types for handling time level resolutions. </purpose>
        </enum>
        <enum name="dst_flags">
          <enumvalue name="not_dst"/>
          <enumvalue name="is_dst"/>
          <enumvalue name="calculate"/>
          <purpose>Flags for daylight savings or summer time. </purpose>
        </enum>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_duration.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="time_duration">
          <template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="rep_type"/>
    </template>
          <purpose>Represents some amount of elapsed time measure to a given resolution. </purpose>
          <description>
            <para>This class represents a standard set of capabilities for all counted time durations. Time duration implementations should derive from this class passing their type as the first template parameter. This design allows the subclass duration types to provide custom construction policies or other custom features not provided here.</para>
            <para>
</para>
          </description>
          <typedef name="duration_type">
            <type>T</type>
          </typedef>
          <typedef name="traits_type">
            <type>rep_type</type>
          </typedef>
          <typedef name="day_type">
            <type>rep_type::day_type</type>
          </typedef>
          <typedef name="hour_type">
            <type>rep_type::hour_type</type>
          </typedef>
          <typedef name="min_type">
            <type>rep_type::min_type</type>
          </typedef>
          <typedef name="sec_type">
            <type>rep_type::sec_type</type>
          </typedef>
          <typedef name="fractional_seconds_type">
            <type>rep_type::fractional_seconds_type</type>
          </typedef>
          <typedef name="tick_type">
            <type>rep_type::tick_type</type>
          </typedef>
          <typedef name="impl_type">
            <type>rep_type::impl_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="hours" cv="const">
              <type>hour_type</type>
              <purpose>Returns number of hours in the duration. </purpose>
            </method>
            <method name="minutes" cv="const">
              <type>min_type</type>
              <purpose>Returns normalized number of minutes. </purpose>
            </method>
            <method name="seconds" cv="const">
              <type>sec_type</type>
              <purpose>Returns normalized number of seconds (0..60). </purpose>
            </method>
            <method name="total_seconds" cv="const">
              <type>sec_type</type>
              <purpose>Returns total number of seconds truncating any fractional seconds. </purpose>
            </method>
            <method name="total_milliseconds" cv="const">
              <type>tick_type</type>
              <purpose>Returns total number of milliseconds truncating any fractional seconds. </purpose>
            </method>
            <method name="total_nanoseconds" cv="const">
              <type>tick_type</type>
              <purpose>Returns total number of nanoseconds truncating any sub millisecond values. </purpose>
            </method>
            <method name="total_microseconds" cv="const">
              <type>tick_type</type>
              <purpose>Returns total number of microseconds truncating any sub microsecond values. </purpose>
            </method>
            <method name="fractional_seconds" cv="const">
              <type>fractional_seconds_type</type>
              <purpose>Returns count of fractional seconds at given resolution. </purpose>
            </method>
            <method name="invert_sign" cv="const">
              <type>duration_type</type>
            </method>
            <method name="is_negative" cv="const">
              <type>bool</type>
            </method>
            <method name="operator&lt;" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>time_duration</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>time_duration</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-" cv="const">
              <type>duration_type</type>
              <purpose>unary- Allows for time_duration td = -td1 </purpose>
            </method>
            <method name="operator-" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator+" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator/" cv="">
              <type>duration_type</type>
              <parameter name="divisor">
                <paramtype>int</paramtype>
              </parameter>
            </method>
            <method name="operator-=" cv="">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator+=" cv="">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator/=" cv="">
              <type>duration_type</type>
              <parameter name="divisor">
                <paramtype>int</paramtype>
              </parameter>
              <purpose>Division operations on a duration with an integer. </purpose>
            </method>
            <method name="operator *" cv="const">
              <type>duration_type</type>
              <parameter name="rhs">
                <paramtype>int</paramtype>
              </parameter>
              <purpose>Multiplication operations an a duration with an integer. </purpose>
            </method>
            <method name="operator *=" cv="">
              <type>duration_type</type>
              <parameter name="divisor">
                <paramtype>int</paramtype>
              </parameter>
            </method>
            <method name="ticks" cv="const">
              <type>tick_type</type>
            </method>
            <method name="is_special" cv="const">
              <type>bool</type>
              <purpose>Is ticks_ a special value? </purpose>
            </method>
            <method name="is_pos_infinity" cv="const">
              <type>bool</type>
              <purpose>Is duration pos-infinity. </purpose>
            </method>
            <method name="is_neg_infinity" cv="const">
              <type>bool</type>
              <purpose>Is duration neg-infinity. </purpose>
            </method>
            <method name="is_not_a_date_time" cv="const">
              <type>bool</type>
              <purpose>Is duration not-a-date-time. </purpose>
            </method>
            <method name="get_rep" cv="const">
              <type>impl_type</type>
              <purpose>Used for special_values output. </purpose>
            </method>
          </method-group>
          <constructor/>
          <constructor>
            <parameter name="hours">
              <paramtype>hour_type</paramtype>
            </parameter>
            <parameter name="minutes">
              <paramtype>min_type</paramtype>
            </parameter>
            <parameter name="seconds">
              <paramtype>sec_type</paramtype>
              <default>0</default>
            </parameter>
            <parameter name="frac_sec">
              <paramtype>fractional_seconds_type</paramtype>
              <default>0</default>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="other">
              <paramtype>const <classname>time_duration</classname>&lt; T, rep_type &gt; &amp;</paramtype>
            </parameter>
            <purpose>Construct from another time_duration (Copy constructor). </purpose>
          </constructor>
          <constructor>
            <parameter name="sv">
              <paramtype>special_values</paramtype>
            </parameter>
            <purpose>Construct from special_values. </purpose>
          </constructor>
          <method-group name="public static functions">
            <method name="unit" cv="">
              <type>duration_type</type>
              <purpose>Returns smallest representable duration. </purpose>
            </method>
            <method name="ticks_per_second" cv="">
              <type>tick_type</type>
              <purpose>Return the number of ticks in a second. </purpose>
            </method>
            <method name="resolution" cv="">
              <type>time_resolutions</type>
              <purpose>Provide the resolution of this duration type. </purpose>
            </method>
            <method name="num_fractional_digits" cv="">
              <type>unsigned short</type>
              <purpose>Returns number of possible digits in fractional seconds. </purpose>
            </method>
          </method-group>
          <method-group name="protected member functions"/>
          <constructor>
            <parameter name="in">
              <paramtype>impl_type</paramtype>
            </parameter>
          </constructor>
        </class>
        <class name="subsecond_duration">
          <template>
      <template-type-parameter name="base_duration"/>
      <template-nontype-parameter name="frac_of_second"><type>boost::int64_t</type></template-nontype-parameter>
    </template>
          <purpose>Template for instantiating derived adjusting durations. </purpose>
          <typedef name="traits_type">
            <type>base_duration::traits_type</type>
          </typedef>
          <method-group name="public member functions"/>
          <constructor>
            <parameter name="ss">
              <paramtype>boost::int64_t</paramtype>
            </parameter>
          </constructor>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_facet.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="time_facet">
          <template>
      <template-type-parameter name="time_type"/>
      <template-type-parameter name="CharT"/>
      <template-type-parameter name="OutItrT"><default>std::ostreambuf_iterator&lt;CharT, std::char_traits&lt;CharT&gt; &gt;</default></template-type-parameter>
    </template>
          <inherit access="public">boost::date_time::date_facet&lt; time_type::date_type, CharT, OutItrT &gt;</inherit>
          <description>
            <para>TODO: ... NOTE: whitespace will be trimmed from ends of format string. Ex. (" %H:%M " becomes "01:30") Format flags are: c =&gt; default format - enables addition of more flags to default (ie. "%c %z") f =&gt; fractional seconds ".123456" F =&gt; fractional seconds or none: like frac sec but empty if frac sec == 0 s =&gt; seconds w/ fractional sec "1098631085" TODO what does this one do?? S =&gt; seconds "02" z =&gt; abbreviated time zone "EDT" Z =&gt; full time zone name "Eastern Daylight Time" </para>
          </description>
          <typedef name="date_type">
            <type>time_type::date_type</type>
          </typedef>
          <typedef name="time_duration_type">
            <type>time_type::time_duration_type</type>
          </typedef>
          <typedef name="period_type">
            <type><classname>boost::date_time::period</classname>&lt; time_type, time_duration_type &gt;</type>
          </typedef>
          <typedef name="base_type">
            <type><classname>boost::date_time::date_facet</classname>&lt; boost::gregorian::date, CharT, OutItrT &gt;</type>
          </typedef>
          <typedef name="string_type">
            <type>base_type::string_type</type>
          </typedef>
          <typedef name="char_type">
            <type>base_type::char_type</type>
          </typedef>
          <typedef name="period_formatter_type">
            <type>base_type::period_formatter_type</type>
          </typedef>
          <typedef name="special_values_formatter_type">
            <type>base_type::special_values_formatter_type</type>
          </typedef>
          <typedef name="date_gen_formatter_type">
            <type>base_type::date_gen_formatter_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="time_duration_format" cv="">
              <type>void</type>
              <parameter name="format">
                <paramtype>const char_type *const</paramtype>
              </parameter>
              <purpose>Changes format for time_duration. </purpose>
            </method>
            <method name="set_iso_format" cv="">
              <type>virtual void</type>
            </method>
            <method name="set_iso_extended_format" cv="">
              <type>virtual void</type>
            </method>
            <method name="put" cv="const">
              <type>OutItrT</type>
              <parameter name="a_next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="a_fill">
                <paramtype>char_type</paramtype>
              </parameter>
              <parameter name="a_time">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="put" cv="const">
              <type>OutItrT</type>
              <parameter name="a_next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="a_fill">
                <paramtype>char_type</paramtype>
              </parameter>
              <parameter name="a_time_dur">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <purpose>put function for time_duration </purpose>
            </method>
            <method name="put" cv="const">
              <type>OutItrT</type>
              <parameter name="next">
                <paramtype>OutItrT</paramtype>
              </parameter>
              <parameter name="a_ios">
                <paramtype>std::ios_base &amp;</paramtype>
              </parameter>
              <parameter name="fill">
                <paramtype>char_type</paramtype>
              </parameter>
              <parameter name="p">
                <paramtype>const <classname>period_type</classname> &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="a_ref">
              <paramtype>::size_t</paramtype>
              <default>0</default>
            </parameter>
            <purpose>sets default formats for ptime, local_date_time, and time_duration </purpose>
          </constructor>
          <constructor>
            <parameter name="a_format">
              <paramtype>const char_type *</paramtype>
            </parameter>
            <parameter name="period_formatter">
              <paramtype>period_formatter_type</paramtype>
              <default>period_formatter_type()</default>
            </parameter>
            <parameter name="special_value_formatter">
              <paramtype>const special_values_formatter_type &amp;</paramtype>
              <default>special_values_formatter_type()</default>
            </parameter>
            <parameter name="dg_formatter">
              <paramtype>date_gen_formatter_type</paramtype>
              <default>date_gen_formatter_type()</default>
            </parameter>
            <parameter name="a_ref">
              <paramtype>::size_t</paramtype>
              <default>0</default>
            </parameter>
          </constructor>
          <data-member name="fractional_seconds_format" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="fractional_seconds_or_none_format" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="seconds_with_fractional_seconds_format" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="seconds_format" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="standard_format" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="zone_abbrev_format" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="zone_name_format" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="zone_iso_format" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="zone_iso_extended_format" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="duration_seperator" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="iso_time_format_specifier" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="iso_time_format_extended_specifier" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="default_time_format" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="default_time_duration_format" specifiers="static">
            <type>const char_type</type>
          </data-member>
          <data-member name="id" specifiers="static">
            <type>std::locale::id</type>
          </data-member>
          <method-group name="protected static functions">
            <method name="fractional_seconds_as_string" cv="">
              <type>string_type</type>
              <parameter name="a_time">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <parameter name="null_when_zero">
                <paramtype>bool</paramtype>
              </parameter>
            </method>
          </method-group>
          <method-group name="private member functions">
            <method name="set_duration_seperator_from_facet" cv="">
              <type>void</type>
              <purpose>Use the std facet to figure out the seperator. </purpose>
              <description>
                <para>Simple algorithm here -- print as X time and search for non-numeric character. This is assumed to be seperator. Would be better if the standard facet was enhanced. </para>
              </description>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_formatting_streams.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="ostream_time_duration_formatter">
          <template>
      <template-type-parameter name="time_duration_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>Put a time type into a stream using appropriate facets. </purpose>
          <typedef name="ostream_type">
            <type>std::basic_ostream&lt; charT &gt;</type>
          </typedef>
          <typedef name="fractional_seconds_type">
            <type>time_duration_type::fractional_seconds_type</type>
          </typedef>
          <method-group name="public static functions">
            <method name="duration_put" cv="">
              <type>void</type>
              <parameter name="td">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>ostream_type &amp;</paramtype>
              </parameter>
              <purpose>Put time into an ostream. </purpose>
            </method>
          </method-group>
        </class>
        <class name="ostream_time_formatter">
          <template>
      <template-type-parameter name="time_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>Put a time type into a stream using appropriate facets. </purpose>
          <typedef name="ostream_type">
            <type>std::basic_ostream&lt; charT &gt;</type>
          </typedef>
          <typedef name="date_type">
            <type>time_type::date_type</type>
          </typedef>
          <typedef name="time_duration_type">
            <type>time_type::time_duration_type</type>
          </typedef>
          <typedef name="duration_formatter">
            <type><classname>ostream_time_duration_formatter</classname>&lt; time_duration_type, charT &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="time_put" cv="">
              <type>void</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>ostream_type &amp;</paramtype>
              </parameter>
              <purpose>Put time into an ostream. </purpose>
            </method>
          </method-group>
        </class>
        <class name="ostream_time_period_formatter">
          <template>
      <template-type-parameter name="time_period_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>Put a time period into a stream using appropriate facets. </purpose>
          <typedef name="ostream_type">
            <type>std::basic_ostream&lt; charT &gt;</type>
          </typedef>
          <typedef name="time_type">
            <type>time_period_type::point_type</type>
          </typedef>
          <typedef name="time_formatter">
            <type><classname>ostream_time_formatter</classname>&lt; time_type, charT &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="period_put" cv="">
              <type>void</type>
              <parameter name="tp">
                <paramtype>const time_period_type &amp;</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>ostream_type &amp;</paramtype>
              </parameter>
              <purpose>Put time into an ostream. </purpose>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_iterator.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="time_itr">
          <template>
      <template-type-parameter name="time_type"/>
    </template>
          <purpose>Simple time iterator skeleton class. </purpose>
          <typedef name="time_duration_type">
            <type>time_type::time_duration_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="operator++" cv="">
              <type><classname>time_itr</classname> &amp;</type>
            </method>
            <method name="operator--" cv="">
              <type><classname>time_itr</classname> &amp;</type>
            </method>
            <method name="operator *" cv="">
              <type>time_type</type>
            </method>
            <method name="operator-&gt;" cv="">
              <type>time_type *</type>
            </method>
            <method name="operator&lt;" cv="">
              <type>bool</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&lt;=" cv="">
              <type>bool</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator!=" cv="">
              <type>bool</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator==" cv="">
              <type>bool</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&gt;" cv="">
              <type>bool</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&gt;=" cv="">
              <type>bool</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="t">
              <paramtype>time_type</paramtype>
            </parameter>
            <parameter name="d">
              <paramtype>time_duration_type</paramtype>
            </parameter>
          </constructor>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_parsing.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <function name="power">
          <type>int_type</type>
          <template>
          <template-type-parameter name="int_type"/>
        </template>
          <parameter name="base">
            <paramtype>int_type</paramtype>
          </parameter>
          <parameter name="exponent">
            <paramtype>int_type</paramtype>
          </parameter>
          <purpose>computes exponential math like 2^8 =&gt; 256, only works with positive integers </purpose>
        </function>
        <function name="parse_delimited_time_duration">
          <type>
            <classname>time_duration</classname>
          </type>
          <template>
          <template-type-parameter name="time_duration"/>
        </template>
          <parameter name="s">
            <paramtype>const std::string &amp;</paramtype>
          </parameter>
          <purpose>Creates a time_duration object from a delimited string. </purpose>
          <description>
            <para>Expected format for string is "[-]h[h][:mm][:ss][.fff]". A negative duration will be created if the first character in string is a '-', all other '-' will be treated as delimiters. Accepted delimiters are "-:,.". </para>
          </description>
        </function>
        <function name="split">
          <type>bool</type>
          <parameter name="s">
            <paramtype>const std::string &amp;</paramtype>
          </parameter>
          <parameter name="sep">
            <paramtype>char</paramtype>
          </parameter>
          <parameter name="first">
            <paramtype>std::string &amp;</paramtype>
          </parameter>
          <parameter name="second">
            <paramtype>std::string &amp;</paramtype>
          </parameter>
          <purpose>Utility function to split appart string. </purpose>
        </function>
        <function name="parse_delimited_time">
          <type>time_type</type>
          <template>
          <template-type-parameter name="time_type"/>
        </template>
          <parameter name="s">
            <paramtype>const std::string &amp;</paramtype>
          </parameter>
          <parameter name="sep">
            <paramtype>char</paramtype>
          </parameter>
        </function>
        <function name="parse_undelimited_time_duration">
          <type>
            <classname>time_duration</classname>
          </type>
          <template>
          <template-type-parameter name="time_duration"/>
        </template>
          <parameter name="s">
            <paramtype>const std::string &amp;</paramtype>
          </parameter>
          <purpose>Parse time duration part of an iso time of form: [-]hhmmss (eg: 120259 is 12 hours 2 min 59 seconds). </purpose>
        </function>
        <function name="parse_iso_time">
          <type>time_type</type>
          <template>
          <template-type-parameter name="time_type"/>
        </template>
          <parameter name="s">
            <paramtype>const std::string &amp;</paramtype>
          </parameter>
          <parameter name="sep">
            <paramtype>char</paramtype>
          </parameter>
          <purpose>Parse time string of form YYYYMMDDThhmmss where T is delimeter between date and time. </purpose>
        </function>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_resolution_traits.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <struct name="time_resolution_traits_bi32_impl">
          <purpose>traits struct for time_resolution_traits implementation type </purpose>
          <typedef name="int_type">
            <type>boost::int32_t</type>
          </typedef>
          <typedef name="impl_type">
            <type>boost::int32_t</type>
          </typedef>
          <method-group name="public static functions">
            <method name="as_number" cv="">
              <type>int_type</type>
              <parameter name="i">
                <paramtype>impl_type</paramtype>
              </parameter>
            </method>
            <method name="is_adapted" cv="">
              <type>bool</type>
              <purpose>Used to determine if implemented type is int_adapter or int. </purpose>
            </method>
          </method-group>
        </struct>
        <struct name="time_resolution_traits_adapted32_impl">
          <purpose>traits struct for time_resolution_traits implementation type </purpose>
          <typedef name="int_type">
            <type>boost::int32_t</type>
          </typedef>
          <typedef name="impl_type">
            <type><classname>boost::date_time::int_adapter</classname>&lt; boost::int32_t &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="as_number" cv="">
              <type>int_type</type>
              <parameter name="i">
                <paramtype>
                  <classname>impl_type</classname>
                </paramtype>
              </parameter>
            </method>
            <method name="is_adapted" cv="">
              <type>bool</type>
              <purpose>Used to determine if implemented type is int_adapter or int. </purpose>
            </method>
          </method-group>
        </struct>
        <struct name="time_resolution_traits_bi64_impl">
          <purpose>traits struct for time_resolution_traits implementation type </purpose>
          <typedef name="int_type">
            <type>boost::int64_t</type>
          </typedef>
          <typedef name="impl_type">
            <type>boost::int64_t</type>
          </typedef>
          <method-group name="public static functions">
            <method name="as_number" cv="">
              <type>int_type</type>
              <parameter name="i">
                <paramtype>impl_type</paramtype>
              </parameter>
            </method>
            <method name="is_adapted" cv="">
              <type>bool</type>
              <purpose>Used to determine if implemented type is int_adapter or int. </purpose>
            </method>
          </method-group>
        </struct>
        <struct name="time_resolution_traits_adapted64_impl">
          <purpose>traits struct for time_resolution_traits implementation type </purpose>
          <typedef name="int_type">
            <type>boost::int64_t</type>
          </typedef>
          <typedef name="impl_type">
            <type><classname>boost::date_time::int_adapter</classname>&lt; boost::int64_t &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="as_number" cv="">
              <type>int_type</type>
              <parameter name="i">
                <paramtype>
                  <classname>impl_type</classname>
                </paramtype>
              </parameter>
            </method>
            <method name="is_adapted" cv="">
              <type>bool</type>
              <purpose>Used to determine if implemented type is int_adapter or int. </purpose>
            </method>
          </method-group>
        </struct>
        <class name="time_resolution_traits">
          <template>
      <template-type-parameter name="frac_sec_type"/>
      <template-nontype-parameter name="res"><type>time_resolutions</type></template-nontype-parameter>
      <template-nontype-parameter name="resolution_adjust"><type>#if(defined(BOOST_MSVC)&amp;&amp;(_MSC_VER&lt;=1200)) boost::int64_t</type></template-nontype-parameter>
      <template-nontype-parameter name="resolution_adjust"><type>#else typename frac_sec_type::int_type</type></template-nontype-parameter>
      <template-nontype-parameter name="frac_digits"><type>#endif unsigned short</type></template-nontype-parameter>
      <template-type-parameter name="v_type"><default>boost::int32_t</default></template-type-parameter>
    </template>
          <typedef name="fractional_seconds_type">
            <type>frac_sec_type::int_type</type>
          </typedef>
          <typedef name="tick_type">
            <type>frac_sec_type::int_type</type>
          </typedef>
          <typedef name="impl_type">
            <type>frac_sec_type::impl_type</type>
          </typedef>
          <typedef name="day_type">
            <type>v_type</type>
          </typedef>
          <typedef name="hour_type">
            <type>v_type</type>
          </typedef>
          <typedef name="min_type">
            <type>v_type</type>
          </typedef>
          <typedef name="sec_type">
            <type>v_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="BOOST_STATIC_CONSTANT" cv="">
              <type/>
              <parameter name="">
                <paramtype>int</paramtype>
              </parameter>
              <parameter name="">
                <paramtype>ticks_per_second</paramtype>
                <default>resolution_adjust</default>
              </parameter>
            </method>
          </method-group>
          <method-group name="public static functions">
            <method name="as_number" cv="">
              <type>frac_sec_type::int_type</type>
              <parameter name="i">
                <paramtype>typename frac_sec_type::impl_type</paramtype>
              </parameter>
            </method>
            <method name="is_adapted" cv="">
              <type>bool</type>
            </method>
            <method name="resolution" cv="">
              <type>time_resolutions</type>
            </method>
            <method name="num_fractional_digits" cv="">
              <type>unsigned short</type>
            </method>
            <method name="res_adjust" cv="">
              <type>fractional_seconds_type</type>
            </method>
            <method name="to_tick_count" cv="">
              <type>tick_type</type>
              <parameter name="hours">
                <paramtype>hour_type</paramtype>
              </parameter>
              <parameter name="minutes">
                <paramtype>min_type</paramtype>
              </parameter>
              <parameter name="seconds">
                <paramtype>sec_type</paramtype>
              </parameter>
              <parameter name="fs">
                <paramtype>fractional_seconds_type</paramtype>
              </parameter>
              <purpose>Any negative argument results in a negative tick_count. </purpose>
            </method>
          </method-group>
        </class>
        <typedef name="milli_res">
          <type>time_resolution_traits&lt; <classname>time_resolution_traits_adapted32_impl</classname>, milli, 1000, 3 &gt;</type>
        </typedef>
        <typedef name="micro_res">
          <type>time_resolution_traits&lt; <classname>time_resolution_traits_adapted64_impl</classname>, micro, 1000000, 6 &gt;</type>
        </typedef>
        <typedef name="nano_res">
          <type>time_resolution_traits&lt; <classname>time_resolution_traits_adapted64_impl</classname>, nano, 1000000000, 9 &gt;</type>
        </typedef>
        <function name="absolute_value">
          <type>T</type>
          <template>
          <template-type-parameter name="T"/>
        </template>
          <parameter name="x">
            <paramtype>T</paramtype>
          </parameter>
          <purpose>Simple function to calculate absolute value of a numeric type. </purpose>
        </function>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_system_counted.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <struct name="counted_time_rep">
          <template>
      <template-type-parameter name="config"/>
    </template>
          <purpose>Time representation that uses a single integer count. </purpose>
          <typedef name="int_type">
            <type>config::int_type</type>
          </typedef>
          <typedef name="date_type">
            <type>config::date_type</type>
          </typedef>
          <typedef name="impl_type">
            <type>config::impl_type</type>
          </typedef>
          <typedef name="date_duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="ymd_type">
            <type>date_type::ymd_type</type>
          </typedef>
          <typedef name="time_duration_type">
            <type>config::time_duration_type</type>
          </typedef>
          <typedef name="resolution_traits">
            <type>config::resolution_traits</type>
          </typedef>
          <method-group name="public member functions">
            <method name="date" cv="const">
              <type>date_type</type>
            </method>
            <method name="day_count" cv="const">
              <type>unsigned long</type>
            </method>
            <method name="time_count" cv="const">
              <type>int_type</type>
            </method>
            <method name="tod" cv="const">
              <type>int_type</type>
            </method>
            <method name="is_pos_infinity" cv="const">
              <type>bool</type>
            </method>
            <method name="is_neg_infinity" cv="const">
              <type>bool</type>
            </method>
            <method name="is_not_a_date_time" cv="const">
              <type>bool</type>
            </method>
            <method name="is_special" cv="const">
              <type>bool</type>
            </method>
            <method name="get_rep" cv="const">
              <type>impl_type</type>
            </method>
          </method-group>
          <constructor>
            <parameter name="d">
              <paramtype>const date_type &amp;</paramtype>
            </parameter>
            <parameter name="tod">
              <paramtype>const time_duration_type &amp;</paramtype>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="count">
              <paramtype>int_type</paramtype>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="count">
              <paramtype>impl_type</paramtype>
            </parameter>
          </constructor>
          <method-group name="public static functions">
            <method name="frac_sec_per_day" cv="">
              <type>int_type</type>
            </method>
          </method-group>
        </struct>
        <class name="counted_time_system">
          <template>
      <template-type-parameter name="time_rep"/>
    </template>
          <purpose>An unadjusted time system implementation. </purpose>
          <typedef name="time_rep_type">
            <type>time_rep</type>
          </typedef>
          <typedef name="impl_type">
            <type>time_rep_type::impl_type</type>
          </typedef>
          <typedef name="time_duration_type">
            <type>time_rep_type::time_duration_type</type>
          </typedef>
          <typedef name="fractional_seconds_type">
            <type>time_duration_type::fractional_seconds_type</type>
          </typedef>
          <typedef name="date_type">
            <type>time_rep_type::date_type</type>
          </typedef>
          <typedef name="date_duration_type">
            <type>time_rep_type::date_duration_type</type>
          </typedef>
          <method-group name="public static functions">
            <method name="unused_var" cv="">
              <type>void</type>
              <template>
          <template-type-parameter name="T"/>
        </template>
              <parameter name="">
                <paramtype>const T &amp;</paramtype>
              </parameter>
            </method>
            <method name="get_time_rep" cv="">
              <type>time_rep_type</type>
              <parameter name="day">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <parameter name="tod">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <parameter name="dst">
                <paramtype>date_time::dst_flags</paramtype>
                <default>not_dst</default>
              </parameter>
            </method>
            <method name="get_time_rep" cv="">
              <type>time_rep_type</type>
              <parameter name="sv">
                <paramtype>special_values</paramtype>
              </parameter>
            </method>
            <method name="get_date" cv="">
              <type>date_type</type>
              <parameter name="val">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="get_time_of_day" cv="">
              <type>time_duration_type</type>
              <parameter name="val">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="zone_name" cv="">
              <type>std::string</type>
              <parameter name="">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="is_equal" cv="">
              <type>bool</type>
              <parameter name="lhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="rhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="is_less" cv="">
              <type>bool</type>
              <parameter name="lhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="rhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="add_days" cv="">
              <type>time_rep_type</type>
              <parameter name="base">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="dd">
                <paramtype>const date_duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="subtract_days" cv="">
              <type>time_rep_type</type>
              <parameter name="base">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="dd">
                <paramtype>const date_duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="subtract_time_duration" cv="">
              <type>time_rep_type</type>
              <parameter name="base">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="td">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="add_time_duration" cv="">
              <type>time_rep_type</type>
              <parameter name="base">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="td">
                <paramtype>time_duration_type</paramtype>
              </parameter>
            </method>
            <method name="subtract_times" cv="">
              <type>time_duration_type</type>
              <parameter name="lhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="rhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_system_split.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="split_timedate_system">
          <template>
      <template-type-parameter name="config"/>
      <template-nontype-parameter name="ticks_per_second"><type>boost::int32_t</type></template-nontype-parameter>
    </template>
          <purpose>An unadjusted time system implementation. </purpose>
          <typedef name="time_rep_type">
            <type>config::time_rep_type</type>
          </typedef>
          <typedef name="date_type">
            <type>config::date_type</type>
          </typedef>
          <typedef name="time_duration_type">
            <type>config::time_duration_type</type>
          </typedef>
          <typedef name="date_duration_type">
            <type>config::date_duration_type</type>
          </typedef>
          <typedef name="int_type">
            <type>config::int_type</type>
          </typedef>
          <typedef name="resolution_traits">
            <type>config::resolution_traits</type>
          </typedef>
          <typedef name="wrap_int_type">
            <type><classname>date_time::wrapping_int</classname>&lt; int_type, INT64_C(86400)*ticks_per_second</type>
          </typedef>
          <typedef name="wrap_int_type">
            <type><classname>date_time::wrapping_int</classname>&lt; int_type, ticks_per_day &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="get_time_rep" cv="">
              <type>time_rep_type</type>
              <parameter name="sv">
                <paramtype>special_values</paramtype>
              </parameter>
            </method>
            <method name="get_time_rep" cv="">
              <type>time_rep_type</type>
              <parameter name="day">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <parameter name="tod">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <parameter name="dst">
                <paramtype>date_time::dst_flags</paramtype>
                <default>not_dst</default>
              </parameter>
            </method>
            <method name="get_date" cv="">
              <type>date_type</type>
              <parameter name="val">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="get_time_of_day" cv="">
              <type>time_duration_type</type>
              <parameter name="val">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="zone_name" cv="">
              <type>std::string</type>
              <parameter name="">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="is_equal" cv="">
              <type>bool</type>
              <parameter name="lhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="rhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="is_less" cv="">
              <type>bool</type>
              <parameter name="lhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="rhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="add_days" cv="">
              <type>time_rep_type</type>
              <parameter name="base">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="dd">
                <paramtype>const date_duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="subtract_days" cv="">
              <type>time_rep_type</type>
              <parameter name="base">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="dd">
                <paramtype>const date_duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="subtract_time_duration" cv="">
              <type>time_rep_type</type>
              <parameter name="base">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="td">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="add_time_duration" cv="">
              <type>time_rep_type</type>
              <parameter name="base">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="td">
                <paramtype>time_duration_type</paramtype>
              </parameter>
            </method>
            <method name="subtract_times" cv="">
              <type>time_duration_type</type>
              <parameter name="lhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="rhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <method-group name="private member functions">
            <method name="BOOST_STATIC_CONSTANT" cv="">
              <type/>
              <parameter name="">
                <paramtype>int_type</paramtype>
              </parameter>
              <parameter name="">
                <paramtype>ticks_per_day</paramtype>
                <default>INT64_C(86400)*config::tick_per_second</default>
              </parameter>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_zone_base.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="time_zone_base">
          <template>
      <template-type-parameter name="time_type"/>
      <template-type-parameter name="CharT"><default>char</default></template-type-parameter>
    </template>
          <purpose>Interface class for dynamic time zones. </purpose>
          <description>
            <para>This class represents the base interface for all timezone representations. Subclasses may provide different systems for identifying a particular zone. For example some may provide a geographical based zone construction while others may specify the offset from GMT. Another possible implementation would be to convert from POSIX timezone strings. Regardless of the construction technique, this is the interface that these time zone types must provide.</para>
            <para>Note that this class is intended to be used as a shared resource (hence the derivation from boost::counted_base. </para>
          </description>
          <typedef name="string_type">
            <type>std::basic_string&lt; CharT &gt;</type>
          </typedef>
          <typedef name="year_type">
            <type>time_type::date_type::year_type</type>
          </typedef>
          <typedef name="time_duration_type">
            <type>time_type::time_duration_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="dst_zone_abbrev" cv="const">
              <type>virtual string_type</type>
              <purpose>String for the timezone when in daylight savings (eg: EDT). </purpose>
            </method>
            <method name="std_zone_abbrev" cv="const">
              <type>virtual string_type</type>
              <purpose>String for the zone when not in daylight savings (eg: EST). </purpose>
            </method>
            <method name="dst_zone_name" cv="const">
              <type>virtual string_type</type>
              <purpose>String for the timezone when in daylight savings (eg: Eastern Daylight Time). </purpose>
            </method>
            <method name="std_zone_name" cv="const">
              <type>virtual string_type</type>
              <purpose>String for the zone when not in daylight savings (eg: Eastern Standard Time). </purpose>
            </method>
            <method name="has_dst" cv="const">
              <type>virtual bool</type>
              <purpose>True if zone uses daylight savings adjustments otherwise false. </purpose>
            </method>
            <method name="dst_local_start_time" cv="const">
              <type>virtual time_type</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
              <purpose>Local time that DST starts -- undefined if has_dst is false. </purpose>
            </method>
            <method name="dst_local_end_time" cv="const">
              <type>virtual time_type</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
              <purpose>Local time that DST ends -- undefined if has_dst is false. </purpose>
            </method>
            <method name="base_utc_offset" cv="const">
              <type>virtual time_duration_type</type>
              <purpose>Base offset from UTC for zone (eg: -07:30:00). </purpose>
            </method>
            <method name="dst_offset" cv="const">
              <type>virtual time_duration_type</type>
              <purpose>Adjustment forward or back made while DST is in effect. </purpose>
            </method>
          </method-group>
          <constructor/>
          <destructor/>
        </class>
        <class name="dst_adjustment_offsets">
          <template>
      <template-type-parameter name="time_duration_type"/>
    </template>
          <purpose>Structure which holds the time offsets associated with daylight savings time. </purpose>
          <description>
            <para>
</para>
          </description>
          <method-group name="public member functions"/>
          <constructor>
            <parameter name="dst_adjust">
              <paramtype>const time_duration_type &amp;</paramtype>
            </parameter>
            <parameter name="dst_start_offset">
              <paramtype>const time_duration_type &amp;</paramtype>
            </parameter>
            <parameter name="dst_end_offset">
              <paramtype>const time_duration_type &amp;</paramtype>
            </parameter>
          </constructor>
          <data-member name="dst_adjust_">
            <type>time_duration_type</type>
            <purpose>Amount DST adjusts the clock eg: plus one hour. </purpose>
          </data-member>
          <data-member name="dst_start_offset_">
            <type>time_duration_type</type>
            <purpose>Time past midnight on start transition day that dst starts. </purpose>
          </data-member>
          <data-member name="dst_end_offset_">
            <type>time_duration_type</type>
            <purpose>Time past midnight on end transition day that dst ends. </purpose>
          </data-member>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_zone_names.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="time_zone_names_base">
          <template>
      <template-type-parameter name="CharT"><default>char</default></template-type-parameter>
    </template>
          <purpose>Base type that holds various string names for timezone output. </purpose>
          <description>
            <para>Class that holds various types of strings used for timezones. For example, for the western United States there is the full name: Pacific Standard Time and the abbreviated name: PST. During daylight savings there are additional names: Pacific Daylight Time and PDT.  CharT Allows class to support different character types </para>
          </description>
          <typedef name="string_type">
            <type>std::basic_string&lt; CharT &gt;</type>
          </typedef>
          <method-group name="public member functions">
            <method name="dst_zone_abbrev" cv="const">
              <type>string_type</type>
            </method>
            <method name="std_zone_abbrev" cv="const">
              <type>string_type</type>
            </method>
            <method name="dst_zone_name" cv="const">
              <type>string_type</type>
            </method>
            <method name="std_zone_name" cv="const">
              <type>string_type</type>
            </method>
          </method-group>
          <constructor>
            <parameter name="std_zone_name">
              <paramtype>const string_type &amp;</paramtype>
            </parameter>
            <parameter name="std_zone_abbrev">
              <paramtype>const string_type &amp;</paramtype>
            </parameter>
            <parameter name="dst_zone_name">
              <paramtype>const string_type &amp;</paramtype>
            </parameter>
            <parameter name="dst_zone_abbrev">
              <paramtype>const string_type &amp;</paramtype>
            </parameter>
          </constructor>
        </class>
        <typedef name="time_zone_names">
          <purpose>Specialization of timezone names for standard char. </purpose>
          <type><classname>time_zone_names_base</classname>&lt; char &gt;</type>
        </typedef>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/tz_db_base.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <struct name="data_not_accessible">
          <method-group name="public member functions"/>
          <constructor/>
          <constructor>
            <parameter name="filespec">
              <paramtype>const std::string &amp;</paramtype>
            </parameter>
          </constructor>
        </struct>
        <struct name="bad_field_count">
          <method-group name="public member functions"/>
          <constructor>
            <parameter name="s">
              <paramtype>const std::string &amp;</paramtype>
            </parameter>
          </constructor>
        </struct>
        <class name="tz_db_base">
          <template>
      <template-type-parameter name="time_zone_type"/>
      <template-type-parameter name="rule_type"/>
    </template>
          <purpose>Creates a database of time_zones from csv datafile. </purpose>
          <description>
            <para>The csv file containing the zone_specs used by the tz_db_base is intended to be customized by the library user. When customizing this file (or creating your own) the file must follow a specific format.</para>
            <para>This first line is expected to contain column headings and is therefore not processed by the tz_db_base.</para>
            <para>Each record (line) must have eleven fields. Some of those fields can be empty. Every field (even empty ones) must be enclosed in double-quotes. Ex: <programlisting> "America/Phoenix" &lt;- string enclosed in quotes
 ""                &lt;- empty field
</programlisting></para>
            <para>Some fields represent a length of time. The format of these fields must be: <programlisting> "{+|-}hh:mm[:ss]" &lt;- length-of-time format
</programlisting>Where the plus or minus is mandatory and the seconds are optional.</para>
            <para>Since some time zones do not use daylight savings it is not always necessary for every field in a zone_spec to contain a value. All zone_specs must have at least ID and GMT offset. Zones that use daylight savings must have all fields filled except: STD ABBR, STD NAME, DST NAME. You should take note that DST ABBR is mandatory for zones that use daylight savings (see field descriptions for further details).</para>
            <para>******* Fields and their description/details *********</para>
            <para>ID: Contains the identifying string for the zone_spec. Any string will do as long as it's unique. No two ID's can be the same.</para>
            <para>STD ABBR: STD NAME: DST ABBR: DST NAME: These four are all the names and abbreviations used by the time zone being described. While any string will do in these fields, care should be taken. These fields hold the strings that will be used in the output of many of the local_time classes. Ex: <programlisting> time_zone nyc = tz_db.time_zone_from_region("America/New_York");
 local_time ny_time(date(2004, Aug, 30), IS_DST, nyc);
 cout &lt;&lt; ny_time.to_long_string() &lt;&lt; endl;
 // 2004-Aug-30 00:00:00 Eastern Daylight Time
 cout &lt;&lt; ny_time.to_short_string() &lt;&lt; endl;
 // 2004-Aug-30 00:00:00 EDT
</programlisting></para>
            <para>NOTE: The exact format/function names may vary - see local_time documentation for further details.</para>
            <para>GMT offset: This is the number of hours added to utc to get the local time before any daylight savings adjustments are made. Some examples are: America/New_York offset -5 hours, &amp; Africa/Cairo offset +2 hours. The format must follow the length-of-time format described above.</para>
            <para>DST adjustment: The amount of time added to gmt_offset when daylight savings is in effect. The format must follow the length-of-time format described above.</para>
            <para>DST Start Date rule: This is a specially formatted string that describes the day of year in which the transition take place. It holds three fields of it's own, separated by semicolons. The first field indicates the "nth" weekday of the month. The possible values are: 1 (first), 2 (second), 3 (third), 4 (fourth), 5 (fifth), and -1 (last). The second field indicates the day-of-week from 0-6 (Sun=0). The third field indicates the month from 1-12 (Jan=1).</para>
            <para>Examples are: "-1;5;9"="Last Friday of September", "2;1;3"="Second Monday of March"</para>
            <para>Start time: Start time is the number of hours past midnight, on the day of the start transition, the transition takes place. More simply put, the time of day the transition is made (in 24 hours format). The format must follow the length-of-time format described above with the exception that it must always be positive.</para>
            <para>DST End date rule: See DST Start date rule. The difference here is this is the day daylight savings ends (transition to STD).</para>
            <para>End time: Same as Start time. </para>
          </description>
          <typedef name="charT">
            <type>char</type>
          </typedef>
          <typedef name="time_zone_base_type">
            <type>time_zone_type::base_type</type>
          </typedef>
          <typedef name="time_duration_type">
            <type>time_zone_type::time_duration_type</type>
          </typedef>
          <typedef name="time_zone_names">
            <type><classname>time_zone_names_base</classname>&lt; charT &gt;</type>
          </typedef>
          <typedef name="dst_adjustment_offsets">
            <type>dst_adjustment_offsets&lt; time_duration_type &gt;</type>
          </typedef>
          <typedef name="string_type">
            <type>std::basic_string&lt; charT &gt;</type>
          </typedef>
          <method-group name="public member functions">
            <method name="load_from_file" cv="">
              <type>void</type>
              <parameter name="pathspec">
                <paramtype>const std::string &amp;</paramtype>
              </parameter>
              <purpose>Process csv data file, may throw exceptions. </purpose>
              <description>
                <para>May throw data_not_accessible, or bad_field_count exceptions </para>
              </description>
            </method>
            <method name="add_record" cv="">
              <type>bool</type>
              <parameter name="id">
                <paramtype>const string_type &amp;</paramtype>
              </parameter>
              <parameter name="tz">
                <paramtype>boost::shared_ptr&lt; time_zone_base_type &gt;</paramtype>
              </parameter>
              <purpose>returns true if record successfully added to map </purpose>
              <description>
                <para>Takes an id string in the form of "America/Phoenix", and a time_zone object for that region. The id string must be a unique name that does not already exist in the database. </para>
              </description>
            </method>
            <method name="time_zone_from_region" cv="const">
              <type>boost::shared_ptr&lt; time_zone_base_type &gt;</type>
              <parameter name="region">
                <paramtype>const string_type &amp;</paramtype>
              </parameter>
              <purpose>Returns a time_zone object built from the specs for the given region. </purpose>
              <description>
                <para>Returns a time_zone object built from the specs for the given region. If region does not exist a local_time::record_not_found exception will be thrown </para>
              </description>
            </method>
            <method name="region_list" cv="const">
              <type>std::vector&lt; std::string &gt;</type>
              <purpose>Returns a vector of strings holding the time zone regions in the database. </purpose>
            </method>
          </method-group>
          <constructor>
            <purpose>Constructs an empty database. </purpose>
          </constructor>
          <method-group name="private member functions">
            <method name="parse_rules" cv="const">
              <type>rule_type *</type>
              <parameter name="sr">
                <paramtype>const string_type &amp;</paramtype>
              </parameter>
              <parameter name="er">
                <paramtype>const string_type &amp;</paramtype>
              </parameter>
              <purpose>parses rule specs for transition day rules </purpose>
            </method>
            <method name="get_week_num" cv="const">
              <type>week_num</type>
              <parameter name="nth">
                <paramtype>int</paramtype>
              </parameter>
              <purpose>helper function for parse_rules() </purpose>
            </method>
            <method name="split_rule_spec" cv="const">
              <type>void</type>
              <parameter name="nth">
                <paramtype>int &amp;</paramtype>
              </parameter>
              <parameter name="d">
                <paramtype>int &amp;</paramtype>
              </parameter>
              <parameter name="m">
                <paramtype>int &amp;</paramtype>
              </parameter>
              <parameter name="rule">
                <paramtype>string_type</paramtype>
              </parameter>
              <purpose>splits the [start|end]_date_rule string into 3 ints </purpose>
            </method>
            <method name="parse_string" cv="">
              <type>bool</type>
              <parameter name="s">
                <paramtype>string_type &amp;</paramtype>
              </parameter>
              <purpose>Take a line from the csv, turn it into a time_zone_type. </purpose>
              <description>
                <para>Take a line from the csv, turn it into a time_zone_type, and add it to the map. Zone_specs in csv file are expected to have eleven fields that describe the time zone. Returns true if zone_spec successfully added to database </para>
              </description>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/wrapping_int.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="wrapping_int">
          <template>
      <template-type-parameter name="int_type_"/>
      <template-nontype-parameter name="wrap_val"><type>int_type_</type></template-nontype-parameter>
    </template>
          <purpose>A wrapping integer used to support time durations. </purpose>
          <description>
            <para>In composite date and time types this type is used to wrap at the day boundary. </para>
          </description>
          <typedef name="int_type">
            <type>int_type_</type>
          </typedef>
          <method-group name="public member functions">
            <method name="as_int" cv="const">
              <type>int_type</type>
              <purpose>Explicit converion method. </purpose>
            </method>
            <method name="conversion-operator" cv="const">
              <type>int_type</type>
            </method>
            <method name="add" cv="">
              <type>int_type</type>
              <parameter name="v">
                <paramtype>int_type</paramtype>
              </parameter>
            </method>
            <method name="subtract" cv="">
              <type>int_type</type>
              <parameter name="v">
                <paramtype>int_type</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="v">
              <paramtype>int_type</paramtype>
            </parameter>
            <purpose>Add, return true if wrapped. </purpose>
          </constructor>
          <method-group name="public static functions">
            <method name="wrap_value" cv="">
              <type>int_type</type>
            </method>
          </method-group>
        </class>
        <class name="wrapping_int2">
          <template>
      <template-type-parameter name="int_type_"/>
      <template-nontype-parameter name="wrap_min"><type>int_type_</type></template-nontype-parameter>
      <template-nontype-parameter name="wrap_max"><type>int_type_</type></template-nontype-parameter>
    </template>
          <purpose>A wrapping integer used to wrap around at the top. </purpose>
          <description>
            <para>Bad name, quick impl to fix a bug -- fix later!! This allows the wrap to restart at a value other than 0. Currently this only works if wrap_min == 1 </para>
          </description>
          <typedef name="int_type">
            <type>int_type_</type>
          </typedef>
          <method-group name="public member functions">
            <method name="as_int" cv="const">
              <type>int_type</type>
              <purpose>Explicit converion method. </purpose>
            </method>
            <method name="conversion-operator" cv="const">
              <type>int_type</type>
            </method>
            <method name="add" cv="">
              <type>int_type</type>
              <parameter name="v">
                <paramtype>int_type</paramtype>
              </parameter>
              <purpose>Add, return number of wraps performed. </purpose>
            </method>
            <method name="subtract" cv="">
              <type>int_type</type>
              <parameter name="v">
                <paramtype>int_type</paramtype>
              </parameter>
              <purpose>Subtract will return '-d' if wrapping took place ('d' is the number of wraps). </purpose>
            </method>
          </method-group>
          <constructor>
            <parameter name="v">
              <paramtype>int_type</paramtype>
            </parameter>
            <description>
              <para>If initializing value is out of range of [wrap_min, wrap_max], value will be initialized to closest of min or max </para>
            </description>
          </constructor>
          <method-group name="public static functions">
            <method name="wrap_value" cv="">
              <type>unsigned long</type>
            </method>
            <method name="min_value" cv="">
              <type>unsigned long</type>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/year_month_day.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <struct name="year_month_day_base">
          <template>
      <template-type-parameter name="YearType"/>
      <template-type-parameter name="MonthType"/>
      <template-type-parameter name="DayType"/>
    </template>
          <purpose>Allow rapid creation of ymd triples of different types. </purpose>
          <typedef name="year_type">
            <type>YearType</type>
          </typedef>
          <typedef name="month_type">
            <type>MonthType</type>
          </typedef>
          <typedef name="day_type">
            <type>DayType</type>
          </typedef>
          <method-group name="public member functions"/>
          <constructor>
            <parameter name="year">
              <paramtype>YearType</paramtype>
            </parameter>
            <parameter name="month">
              <paramtype>MonthType</paramtype>
            </parameter>
            <parameter name="day">
              <paramtype>DayType</paramtype>
            </parameter>
            <purpose>A basic constructor. </purpose>
          </constructor>
          <data-member name="year">
            <type>YearType</type>
          </data-member>
          <data-member name="month">
            <type>MonthType</type>
          </data-member>
          <data-member name="day">
            <type>DayType</type>
          </data-member>
        </struct>
      </namespace>
    </namespace>
  </header>
</section>
