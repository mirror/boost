<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Regex++, template class and algorithm reference</TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">

<P>&nbsp; </P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=624>
<TR><TD WIDTH="50%" VALIGN="TOP">
<H3 ALIGN="RIGHT"><IMG SRC="../../c++boost.gif" WIDTH=276 HEIGHT=86 ALT="C++ Boost"></H3></TD>
<TD WIDTH="50%" VALIGN="TOP">
<H2 ALIGN="CENTER">Regex++, Template Class and Algorithm Reference.</H2>
<I><P>(version 3.04, 18 April 2000)</I> </P>
<I><PRE>Copyright (c) 1998-9
Dr John Maddock

Permission to use, copy, modify, distribute and sell this software
and its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear
in supporting documentation.&nbsp; Dr John Maddock makes no representations
about the suitability of this software for any purpose.&nbsp;&nbsp;
It is provided "as is" without express or implied warranty.</PRE></I></TD>
</TR>
</TABLE>

<P><HR></P>
<H3><A NAME="regbase"></A>class regbase</H3>
<P>#include &lt;<A HREF="../../boost/regex.hpp">boost/regex.hpp</A>&gt; </P>
<P>Class regbase is the template argument independent base class for reg_expression, the only public members are the <I>flag_type</I> enumerated values that determine how regular expressions are interpreted. </P>
<B><PRE>class</B> regbase
{
<B>public</B>:
&nbsp;&nbsp; <B>enum</B> flag_type_
&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; escape_in_lists = 1,&nbsp;                         <FONT COLOR="#000080">// '\\' special inside [...] 
</FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char_classes = escape_in_lists &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I><FONT COLOR="#000080">// [[:CLASS:]] allowed 
</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intervals = char_classes &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I><FONT COLOR="#000080">// {x,y} allowed 
</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; limited_ops = intervals &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I><FONT COLOR="#000080">// all of + ? and | are normal characters 
</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newline_alt = limited_ops &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I><FONT COLOR="#000080">// \n is the same as | 
</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bk_plus_qm = newline_alt &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I><FONT COLOR="#000080">// uses \+ and \? 
</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bk_braces = bk_plus_qm &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I><FONT COLOR="#000080">// uses \{ and \} 
</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bk_parens = bk_braces &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I><FONT COLOR="#000080">// uses \( and \) 
</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bk_refs = bk_parens &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I><FONT COLOR="#000080">// \d allowed 
</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bk_vbar = bk_refs &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I><FONT COLOR="#000080">// uses \| 
</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use_except = bk_vbar &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I><FONT COLOR="#000080">// exception on error 
</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; failbit = use_except &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I><FONT COLOR="#000080">// error flag 
</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; literal = failbit &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I><FONT COLOR="#000080">// all characters are literals 
</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icase = literal &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I><FONT COLOR="#000080">// characters are matched regardless of case 
</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nocollate = icase &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I><FONT COLOR="#000080">// don't use locale specific collation 
</I></FONT>
      basic = char_classes | intervals | limited_ops | bk_braces | bk_parens | bk_refs,
      extended = char_classes | intervals | bk_refs,
      normal = escape_in_lists | char_classes | intervals | bk_refs | nocollate,
      emacs = bk_braces | bk_parens | bk_refs | bk_vbar,
      awk = extended | escape_in_lists,
      grep = basic | newline_alt,
      egrep = extended | newline_alt,
      sed = basic,
      perl = normal
   }; 
   <B>typedef</B> <B>unsigned</B> <B>int</B> flag_type;
}; &nbsp; </PRE>
<P>&nbsp; <BR>
&nbsp; <BR>
&nbsp; </P>
<P>The enumerated type <I>regbase::flag_type</I> determines the syntax rules for regular expression compilation, the various flags have the following effects: <BR>
&nbsp; </P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=624>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>regbase::escape_in_lists</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>Allows the use of the escape "\" character in sets of characters, for example [\]] represents the set of characters containing only "]". If this flag is not set then "\" is an ordinary character inside sets.</TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>regbase::char_classes</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>When this bit is set, character classes [:classname:] are allowed inside character set declarations, for example "[[:word:]]" represents the set of all characters that belong to the character class "word".</TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>regbase:: intervals</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>When this bit is set, repetition intervals are allowed, for example "a{2,4}" represents a repeat of between 2 and 4 letter a's.</TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>regbase:: limited_ops</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>When this bit is set all of "+", "?" and "|" are ordinary characters in all situations.</TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>regbase:: newline_alt</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>When this bit is set, then the newline character "\n" has the same effect as the alternation operator "|".</TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>regbase:: bk_plus_qm</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>When this bit is set then "\+" represents the one or more repetition operator and "\?" represents the zero or one repetition operator. When this bit is not set then "+" and "?" are used instead.</TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>regbase:: bk_braces</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>When this bit is set then "\{" and "\}" are used for bounded repetitions and "{" and "}" are normal characters. This is the opposite of default behavior.</TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>regbase:: bk_parens</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>When this bit is set then "\(" and "\)" are used to group sub-expressions and "(" and ")" are ordinary characters, this is the opposite of default behaviour.</TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>regbase:: bk_refs</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>When this bit is set then back references are allowed.</TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>regbase:: bk_vbar</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>When this bit is set then "\|" represents the alternation operator and "|" is an ordinary character. This is the opposite of default behaviour.</TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>regbase:: use_except</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>When this bit is set then a <A HREF="#bad_expression">bad_expression</A> exception will be thrown on error.&nbsp; Use of this flag is deprecated - reg_expression will always throw on error.</TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>regbase:: failbit</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>This bit is set on error, if regbase::use_except is not set, then this bit should be checked to see if a regular expression is valid before usage.</TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>regbase::literal</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>All characters in the string are treated as literals, there are no special characters or escape sequences.</TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>regbase::icase</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>All characters in the string are matched regardless of case.</TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>regbase::nocollate</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>Locale specific collation is disabled when dealing with ranges in character set declarations.&nbsp; For example when this bit is set the expression [a-c] would match the characters a, b and c only regardless of locale, where as when this is not set , then [a-c] matches any character which collates in the range a to c.</TD>
<TD WIDTH="5%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>regbase::basic</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>Equivalent to the POSIX basic regular expression syntax: char_classes | intervals | limited_ops | bk_braces | bk_parens | bk_refs.</TD>
<TD WIDTH="5%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>Regbase::extended</TD>
<TD WIDTH="45%" VALIGN="TOP">
<P>Equivalent to the POSIX extended regular expression syntax: char_classes | intervals | bk_refs.</TD>
<TD WIDTH="5%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="TOP" HEIGHT=24>
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=24>
<P>regbase::normal</TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=24>
<P>This is the default setting, and represents how most people expect the library to behave. Equivalent to the POSIX extended syntax, but with locale specific collation disabled, and escape characters inside set declarations enabled: regbase::escape_in_lists | regbase::char_classes | regbase::intervals | regbase::bk_refs | regbase::nocollate.</TD>
<TD WIDTH="5%" VALIGN="TOP" HEIGHT=24>
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="TOP" HEIGHT=24>
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=24>
<P>regbase::emacs</TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=24>
<P>Provides compatability with the emacs editor, eqivalent to: bk_braces | bk_parens | bk_refs | bk_vbar.</TD>
<TD WIDTH="5%" VALIGN="TOP" HEIGHT=24>
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="TOP" HEIGHT=24>
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=24>
<P>regbase::awk </TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=24>
<P>Provides compatabilty with the Unix utility Awk, the same as POSIX extended regular expressions, but allows escapes inside bracket-expressions (character sets). Equivalent to extended | escape_in_lists.</TD>
<TD WIDTH="5%" VALIGN="TOP" HEIGHT=24>
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="TOP" HEIGHT=24>
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=24>
<P>regbase::grep</TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=24>
<P>Provides compatabilty with the Unix grep utility, the same as POSIX basic regular expressions, but with the newline character equivalent to the alternation operator. the same as basic | newline_alt.</TD>
<TD WIDTH="5%" VALIGN="TOP" HEIGHT=24>
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="TOP" HEIGHT=24>
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=24>
<P>regbase::egrep</TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=24>
<P>Provides compatabilty with the Unix egrep utility, the same as POSIX extended regular expressions, but with the newline character equivalent to the alternation operator. the same as extended | newline_alt.</TD>
<TD WIDTH="5%" VALIGN="TOP" HEIGHT=24>
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="TOP" HEIGHT=24>
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=24>
<P>regbase::sed</TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=24>
<P>Provides compatabilty with the Unix sed utility, the same as POSIX basic regular expressions.</TD>
<TD WIDTH="5%" VALIGN="TOP" HEIGHT=24>
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="TOP" HEIGHT=24>
<P>&nbsp;</TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=24>
<P>regbase::perl</TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=24>
<P>Provides compatibility with the perl programming language, the same as regbase::normal.</TD>
<TD WIDTH="5%" VALIGN="TOP" HEIGHT=24>
<P>&nbsp;</TD>
</TR>
</TABLE>

<P><HR></P>
<H3><A NAME="bad_expression"></A>Exception classes.</H3>
<P>#include &lt;<A HREF="../../boost/pattern_except.hpp">boost/pat_except.hpp</A>&gt; </P>
<P>An instance of <I>bad_expression</I> is thrown whenever a bad regular expression is encountered. </P>
<B><PRE>namespace</B> boost{

<B>class</B> bad_pattern : <B>public</B> std::runtime_error
{
<B>public</B>:
&nbsp;&nbsp; <B>explicit</B> bad_pattern(<B>const</B> std::string&amp; s) : std::runtime_error(s){};
};

<B>class</B> bad_expression : <B>public</B> bad_pattern
{
<B>public</B>:
&nbsp;&nbsp; bad_expression(<B>const</B> std::string&amp; s) : bad_pattern(s) {}
};


} // namespace boost</PRE>
<P>Footnotes: the class <I>bad_pattern </I>forms the base class for all pattern-matching exceptions, of which <I>bad_expression</I> is one. The choice of <I>std::runtime_error </I>as the base class for <I>bad_pattern</I> is moot, depending upon how the library is used exceptions may be either logic errors (programmer supplied expressions) or run time errors (user supplied expressions). </P>
<P><HR></P>
<H3><A NAME="reg_expression"></A>Class reg_expression</H3>
<P>#include &lt;<A HREF="../../boost/regex.hpp">boost/regex.hpp</A>&gt; </P>
<P>The template class <I>reg_expression </I>encapsulates regular expression parsing and compilation. The class derives from class <A HREF="#regbase"><I>regbase</I></A> and takes three template parameters: </P>
<B><I><P>charT</B></I>: determines the character type, i.e. either char or wchar_t. </P>
<B><I><P>traits</B></I>: determines the behaviour of the character type, for example whether character matching is case sensitive or not, and which character class names are recognized. A default traits class is provided: <A HREF="#regex_char_traits">regex_traits&lt;charT&gt;</A>. </P>
<B><I><P>Allocator</B></I>: the allocator class used to allocate memory by the class. </P>
<P>For ease of use there are two typedefs that define the two standard <I>reg_expression</I> instances, unless you want to use custom allocators, you won't need to use anything other than these: </P>
<B><PRE>namespace</B> boost{
<B>template</B> &lt;<B>class</B> charT, <B>class</B> traits = regex_traits&lt;charT&gt;, <B>class</B> Allocator = std::allocator&lt;charT&gt;&nbsp; &gt;
<B>class</B> reg_expression;
<B>typedef</B> reg_expression&lt;<B>char</B>&gt; regex;
<B>typedef</B> reg_expression&lt;<B>wchar_t&gt; </B>wregex;
}</PRE>
<P>The definition of <I>reg_expression</I> follows: it is based very closely on class basic_string, and fulfils the requirements for a container of <I>charT</I>. </P>
<B><PRE>namespace</B> boost{
<B>template</B> &lt;<B>class</B> charT, <B>class</B> traits = char_regex_traits&lt;charT&gt;, <B>class</B> Allocator = std::allocator&lt;charT&gt;&nbsp; &gt;
<B>class</B> reg_expression : <B>public</B> regbase
{
<B>public</B>: 
<I><FONT COLOR="#000080">   // typedefs: </I></FONT>&nbsp;
&nbsp; <B> typedef</B> charT char_type; 
&nbsp;&nbsp; <B>typedef</B> traits traits_type; 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// locale_type 
</I>&nbsp;&nbsp; <I>// placeholder for actual locale type used by the 
</I>&nbsp;&nbsp; <I>// traits class to localise *this. 
</I></FONT>&nbsp;&nbsp; <B>typedef</B> typename traits::locale_type locale_type; 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// value_type 
</I></FONT>&nbsp;&nbsp; <B>typedef</B> charT value_type; 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// reference, const_reference 
</I></FONT>&nbsp;&nbsp; <B>typedef</B> charT&amp; reference; 
&nbsp;&nbsp; <B>typedef</B> <B>const</B> charT&amp; const_reference; 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// iterator, const_iterator 
</I></FONT>&nbsp;&nbsp; <B>typedef</B> <B>const</B> charT* const_iterator; 
&nbsp;&nbsp; <B>typedef</B> const_iterator iterator; 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// difference_type 
</I></FONT>&nbsp;&nbsp; <B>typedef</B> <B>typename</B> Allocator::difference_type difference_type; 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// size_type 
</I></FONT>&nbsp;&nbsp; <B>typedef</B> <B>typename</B> Allocator::size_type size_type;&nbsp;
&nbsp;&nbsp; <I><FONT COLOR="#000080">// allocator_type 
</I></FONT> <B>  typedef</B> Allocator allocator_type; 
&nbsp;&nbsp; <B>typedef</B> Allocator alloc_type; 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// flag_type 
</I></FONT>&nbsp;&nbsp; <B>typedef</B> jm_uintfast32_t flag_type; 
<B>public</B>: 
&nbsp;  <FONT COLOR="#000080"><EM>// constructors</FONT></EM> 
&nbsp;  <STRONG>explicit</STRONG> reg_expression(<B>const</B> Allocator&amp; a = Allocator()); 
&nbsp;&nbsp; <STRONG>explicit</STRONG> reg_expression(<B>const</B> charT* p, flag_type f = regbase::normal, <B>const</B> Allocator&amp; a = Allocator()); 
&nbsp;&nbsp; reg_expression(<B>const</B> charT* p1, <B>const</B> charT* p2, flag_type f = regbase::normal, <B>const</B> Allocator&amp; a = Allocator()); 
&nbsp;&nbsp; reg_expression(<B>const</B> charT* p, size_type len, flag_type f, <B>const</B> Allocator&amp; a = Allocator()); 
&nbsp;&nbsp; reg_expression(<B>const</B> reg_expression&amp;); 
<B>&nbsp;&nbsp; template</B> &lt;<B>class</B> ST, <B>class</B> SA&gt; 
&nbsp;&nbsp; <STRONG>explicit</STRONG> reg_expression(<B>const</B> std::basic_string&lt;charT, ST, SA&gt;&amp; p, flag_type f = regbase::normal, <B>const</B> Allocator&amp; a = Allocator()); 
<B>&nbsp;&nbsp; template</B> &lt;<B>class</B> I&gt; 
&nbsp;&nbsp; reg_expression(I first, I last, flag_type f = regbase::normal, <B>const</B> Allocator&amp; a = Allocator()); 
&nbsp;&nbsp; ~reg_expression(); 
&nbsp;&nbsp; reg_expression&amp; <B>operator</B>=(<B>const</B> reg_expression&amp;); 
&nbsp;&nbsp; reg_expression&amp; <B>operator</B>=(<B>const</B> charT* ptr); 
<B>&nbsp;&nbsp; template</B> &lt;<B>class</B> ST, <B>class</B> SA&gt; 
&nbsp;&nbsp; reg_expression&amp; <B>operator</B>=(<B>const</B> std::basic_string&lt;charT, ST, SA&gt;&amp; p); 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// 
</I>&nbsp;&nbsp; <I>// assign: 
</I></FONT>&nbsp;&nbsp; reg_expression&amp; assign(<B>const</B> reg_expression&amp; that); 
&nbsp;&nbsp; reg_expression&amp; assign(<B>const</B> charT* ptr, flag_type f = regbase::normal); 
&nbsp;&nbsp; reg_expression&amp; assign(<B>const</B> charT* first, <B>const</B> charT* last, flag_type f = regbase::normal); 
<B>&nbsp;&nbsp; template</B> &lt;<B>class</B> string_traits, <B>class</B> A&gt; 
&nbsp;&nbsp;&nbsp;reg_expression&amp; assign( 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>const</B> std::basic_string&lt;charT, string_traits, A&gt;&amp; s, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flag_type f = regbase::normal); 
&nbsp;&nbsp; <B>template</B> &lt;<B>class</B> iterator&gt; 
&nbsp;&nbsp; reg_expression&amp; assign(iterator first, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator last, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flag_type f = regbase::normal); 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// 
</I>&nbsp;&nbsp; <I>// allocator access: 
</I></FONT>&nbsp;&nbsp; Allocator get_allocator()<B>const</B>; 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// 
</I>&nbsp;&nbsp; <I>// locale: 
</I></FONT>&nbsp;&nbsp; locale_type imbue(<B>const</B> locale_type&amp; l); 
&nbsp;&nbsp; locale_type getloc()<B>const</B>; 
<I><FONT COLOR="#000080">&nbsp;&nbsp; // 
</I>&nbsp;&nbsp; <I>// flags: 
</I></FONT>&nbsp;&nbsp; flag_type getflags()<B>const</B>; 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// 
</I>&nbsp;&nbsp; <I>// str: 
</I></FONT>&nbsp;&nbsp; std::basic_string&lt;charT&gt; str()<B>const</B>; 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// 
</I>&nbsp;&nbsp; <I>// begin, end: 
</I></FONT>&nbsp;&nbsp; const_iterator begin()<B>const</B>; 
&nbsp;&nbsp; const_iterator end()<B>const</B>; 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// 
</I>&nbsp;&nbsp; <I>// swap: 
</I></FONT>&nbsp;&nbsp; <B>void</B> swap(reg_expression&amp;)<B>throw</B>(); 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// 
</I>&nbsp;&nbsp; <I>// size: 
</I></FONT>&nbsp;&nbsp; size_type size()<B>const</B>; 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// 
</I>&nbsp;&nbsp; <I>// max_size: 
</I></FONT>&nbsp;&nbsp; size_type max_size()<B>const</B>; 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// 
</I>&nbsp;&nbsp; <I>// empty: 
</I></FONT>&nbsp;&nbsp; <B>bool</B> empty()<B>const</B>; 
&nbsp;&nbsp; <B>unsigned</B> mark_count()<B>const</B>; 
&nbsp;&nbsp; <B>bool</B> <B>operator</B>==(<B>const</B> reg_expression&amp;)<B>const</B>; 
&nbsp;&nbsp; <B>bool</B> <B>operator</B>&lt;(<B>const</B> reg_expression&amp;)<B>const</B>; 
};
} <I><FONT COLOR="#000080">// namespace boost </PRE>
</I></FONT><FONT SIZE=2><P>Class reg_expression has the following public member functions: <BR>
&nbsp; </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=624>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P><FONT SIZE=2>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>reg_expression(Allocator a = Allocator());</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;Constructs a default instance of reg_expression without any expression.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>reg_expression(charT* p, <B>unsigned</B> f = regbase::normal, Allocator a = Allocator());</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;Constructs an instance of reg_expression from the expression denoted by the null terminated string <B>p</B>, using the flags <B>f</B> to determine regular expression syntax. See class </FONT><A HREF="#regbase"><FONT SIZE=2>regbase</FONT></A><FONT SIZE=2> for allowable flag values.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>reg_expression(charT* p1, charT* p2, <B>unsigned</B> f = regbase::normal, Allocator a = Allocator());</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;Constructs an instance of reg_expression from the expression denoted by pair of iterators <B>p1</B> and <B>p2</B>, using the flags <B>f</B> to determine regular expression syntax. See class </FONT><A HREF="#regbase"><FONT SIZE=2>regbase</FONT></A><FONT SIZE=2> for allowable flag values.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>reg_expression(charT* p, size_type len, <B>unsigned</B> f, Allocator a = Allocator());</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;Constructs an instance of reg_expression from the expression denoted by the string <B>p</B> of length <B>len</B>, using the flags <B>f</B> to determine regular expression syntax. See class </FONT><A HREF="#regbase"><FONT SIZE=2>regbase</FONT></A><FONT SIZE=2> for allowable flag values.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<B><FONT SIZE=2><P>template</B> &lt;class ST, class SA&gt; <BR>
reg_expression(<B>const</B> std::basic_string&lt;charT, ST, SA&gt;&amp; p, jm_uintfast32_t f = regbase::normal, <B>const</B> Allocator&amp; a = Allocator());</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;Constructs an instance of reg_expression from the expression denoted by the string <B>p</B>, using the flags <B>f</B> to determine regular expression syntax. See class </FONT><A HREF="#regbase"><FONT SIZE=2>regbase</FONT></A><FONT SIZE=2> for allowable flag values. </P>
<P>Note - this member may not be available depending upon your compiler capabilities.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>template &lt;class I&gt; <BR>
reg_expression(I first, I last, flag_type f = regbase::normal, const Allocator&amp; a = Allocator());</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;Constructs an instance of reg_expression from the expression denoted by pair of iterators <B>p1</B> and <B>p2</B>, using the flags <B>f</B> to determine regular expression syntax. See class </FONT><A HREF="#regbase"><FONT SIZE=2>regbase</FONT></A><FONT SIZE=2> for allowable flag values.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>reg_expression(<B>const</B> reg_expression&amp;);</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Copy constructor - copies an existing regular expression.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>reg_expression&amp; <B>operator</B>=(<B>const</B> reg_expression&amp;);</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Copies an existing regular expression.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>reg_expression&amp; <B>operator</B>=(<B>const</B> charT* ptr);</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Equivalent to assign(ptr);</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>template &lt;class ST, class SA&gt; </P>
<P>reg_expression&amp; operator=(const std::basic_string&lt;charT, ST, SA&gt;&amp; p);</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Equivalent to assign(p);</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>reg_expression&amp; assign(<B>const</B> reg_expression&amp; that);</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Copies the regular expression contained by <B>that</B>, throws </FONT><A HREF="#bad_expression"><FONT SIZE=2>bad_expression</FONT></A><FONT SIZE=2> if <B>that</B> does not contain a valid expression. Returns *this.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>reg_expression&amp; assign(<B>const</B> charT* p, flag_type f = regbase::normal);</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Compiles a regular expression from the expression denoted by the null terminated string <B>p</B>, using the flags <B>f</B> to determine regular expression syntax. See class </FONT><A HREF="#regbase"><FONT SIZE=2>regbase</FONT></A><FONT SIZE=2> for allowable flag values. Throws </FONT><A HREF="#bad_expression"><FONT SIZE=2>bad_expression</FONT></A><FONT SIZE=2> if <B>p</B> does not contain a valid expression. Returns *this.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>reg_expression&amp; assign(<B>const</B> charT* first, <B>const</B> charT* last, flag_type f = regbase::normal);</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Compiles a regular expression from the expression denoted by the pair of iterators <B>first-last</B>, using the flags <B>f</B> to determine regular expression syntax. See class </FONT><A HREF="#regbase"><FONT SIZE=2>regbase</FONT></A><FONT SIZE=2> for allowable flag values. Throws </FONT><A HREF="#bad_expression"><FONT SIZE=2>bad_expression</FONT></A><FONT SIZE=2> if <B>first-last</B> does not contain a valid expression. Returns *this.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<B><FONT SIZE=2><P>template</B> &lt;<B>class</B> string_traits, <B>class</B> A&gt; <BR>
reg_expression&amp; assign(<B>const</B> std::basic_string&lt;charT, string_traits, A&gt;&amp; s, flag_type f = regbase::normal);</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Compiles a regular expression from the expression denoted by the string <B>s</B>, using the flags <B>f</B> to determine regular expression syntax. See class </FONT><A HREF="#regbase"><FONT SIZE=2>regbase</FONT></A><FONT SIZE=2> for allowable flag values. Throws </FONT><A HREF="#bad_expression"><FONT SIZE=2>bad_expression</FONT></A><FONT SIZE=2> if <B>s</B> does not contain a valid expression. Returns *this.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>template &lt;class iterator&gt; <BR>
reg_expression&amp; assign(iterator first, iterator last, flag_type f = regbase::normal);</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Compiles a regular expression from the expression denoted by the pair of iterators <B>first-last</B>, using the flags <B>f</B> to determine regular expression syntax. See class </FONT><A HREF="#regbase"><FONT SIZE=2>regbase</FONT></A><FONT SIZE=2> for allowable flag values. Throws </FONT><A HREF="#bad_expression"><FONT SIZE=2>bad_expression</FONT></A><FONT SIZE=2> if <B>first-last</B> does not contain a valid expression. Returns *this.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Allocator get_allocator()<B>const</B>;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Returns the allocator used by the expression.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>locale_type imbue(<B>const</B> locale_type&amp; l);</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Imbues the expression with the specified locale, and invalidates the current expression.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>locale_type getloc()<B>const</B>;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Returns the locale used by the expression.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>flag_type getflags()<B>const</B>;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Returns the flags used to compile the current expression.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>std::basic_string&lt;charT&gt; str()<B>const</B>;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Returns the current expression as a string.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>const_iterator begin()<B>const</B>;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Returns a pointer to the first character of the current expression.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>const_iterator end()<B>const</B>;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Returns a pointer to the end of the current expression.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>size_type size()<B>const</B>;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Returns the length of the current expression.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>size_type max_size()<B>const</B>;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Returns the maximum length of a regular expression text.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<B><FONT SIZE=2><P>bool</B> empty()<B>const</B>;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Returns true if the object contains no valid expression.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<B><FONT SIZE=2><P>unsigned</B> mark_count()<B>const</B> ;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Returns the number of sub-expressions in the compiled regular expression. Note that this includes the whole match (subexpression zero), so the value returned is always &gt;= 1.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
</TABLE>

<P><HR></P>
<I><H3><A NAME="regex_char_traits"></A>Class regex_traits</H3>
</I><FONT SIZE=2><P>#include &lt;</FONT><A HREF="../../boost/regex_traits.hpp"><FONT SIZE=2>boost/regex_traits.hpp</FONT></A><FONT SIZE=2>&gt; </P>
<I><P>This is a preliminary version of the regular expression traits class, and is subject to change</I>. </P>
<P>The purpose of the traits class is to make it easier to customise the behaviour of <I>reg_expression </I>and the associated matching algorithms. Custom traits classes can handle special character sets or define additional character classes, for example one could define [[:kanji:]] as the set of all (Unicode) kanji characters. This library provides three traits classes and a wrapper class <I>regex_traits</I>, which inherits from one of these depending upon the default localisation model in use, class <I>c_regex_traits</I> encapsulates the global C locale, class <I>w32_regex_traits</I> encapsulates the global Win32 locale (only available on Win32 systems), and class <I>cpp_regex_traits</I> encapsulates the C++ locale (only provided if std::locale is supported): </P>
</FONT><PRE>template &lt;class charT&gt; class c_regex_traits;
template&lt;&gt; class c_regex_traits&lt;char&gt; { /*details*/ };
template&lt;&gt; class c_regex_traits&lt;wchar_t&gt; { /*details*/ };

template &lt;class charT&gt; class w32_regex_traits;
template&lt;&gt; class w32_regex_traits&lt;char&gt; { /*details*/ };
template&lt;&gt; class w32_regex_traits&lt;wchar_t&gt; { /*details*/ };

template &lt;class charT&gt; class cpp_regex_traits;
template&lt;&gt; class cpp_regex_traits&lt;char&gt; { /*details*/ };
template&lt;&gt; class cpp_regex_traits&lt;wchar_t&gt; { /*details*/ };

template &lt;class charT&gt; class regex_traits : public base_type { /*detailts*/ };</PRE>
<FONT SIZE=2><P>Where "<I>base_type</I>" defaults to <I>w32_regex_traits</I> on Win32 systems, and <I>c_regex_traits</I> otherwise. The default behaviour can be changed by defining one of BOOST_RE_LOCALE_C (forces use of <I>c_regex_traits</I> by default), or BOOST_RE_LOCALE_CPP (forces use of <I>cpp_regex_traits</I> by default). Alternatively a specific traits class can be passed to the <I>reg_expression</I> template. </P>
<P>The requirements for custom traits classes are </FONT><A HREF="traits_class_ref.htm"><FONT SIZE=2>documented separately here....</FONT></A><FONT SIZE=2> </P>
</FONT><P><HR></P>
<I><H3><A NAME="reg_match"></A>Class match_results</H3>
</I><FONT SIZE=2><P>#include &lt;</FONT><A HREF="../../boost/regex.hpp"><FONT SIZE=2>boost/regex.hpp</FONT></A><FONT SIZE=2>&gt; </P>
<P>Regular expressions are different from many simple pattern-matching algorithms in that as well as finding an overall match they can also produce sub-expression matches: each sub-expression being delimited in the pattern by a pair of parenthesis (...). There has to be some method for reporting sub-expression matches back to the user: this is achieved this by defining a class <I>match_results</I> that acts as an indexed collection of sub-expression matches, each sub-expression match being contained in an object of type <I>sub_match</I>. </P>
</FONT><I><FONT COLOR="#000080"><PRE>// 
// class sub_match: 
// denotes one sub-expression match. 
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</I></FONT><B>template</B> &lt;<B>class</B> iterator&gt;
<B>struct</B> sub_match
{
&nbsp;&nbsp; <B>typedef</B> <B>typename</B> std::iterator_traits&lt;iterator&gt;::value_type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_type;
&nbsp;&nbsp; <B>typedef</B> <B>typename</B> std::iterator_traits&lt;iterator&gt;::difference_type&nbsp; difference_type;
&nbsp;&nbsp; <B>typedef</B> iterator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator_type;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; iterator first;
&nbsp;&nbsp; iterator second;
&nbsp;&nbsp; <B>bool</B> matched;

&nbsp;&nbsp; <B>operator</B> std::basic_string&lt;value_type&gt;()<B>const</B>;

&nbsp;&nbsp; <B>bool</B> <B>operator</B>==(<B>const</B> sub_match&amp; that)<B>const</B>;
&nbsp;&nbsp; <B>bool</B> <B>operator</B> !=(<B>const</B> sub_match&amp; that)<B>const</B>;
&nbsp;&nbsp; difference_type length()<B>const</B>;
};

<FONT COLOR="#000080">// 
// class match_results: 
// contains an indexed collection of matched sub-expressions. 
// 
</FONT><B>template</B> &lt;<B>class</B> iterator, <B>class</B> Allocator = std::allocator&lt;<STRONG>typename</STRONG> std::iterator_traits&lt;iterator&gt;::value_type &gt; &gt; 
<B>class</B> match_results 
{ 
<B>public</B>: 
&nbsp;&nbsp; <B>typedef</B> Allocator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alloc_type; 
&nbsp;&nbsp; <B>typedef</B> <B>typename</B> Allocator::<B>template</B> Rebind&lt;iterator&gt;::size_type&nbsp; size_type; 
&nbsp;&nbsp; <B>typedef</B> <B>typename</B> std::iterator_traits&lt;iterator&gt;::value_type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char_type; 
&nbsp;&nbsp; <B>typedef</B> sub_match&lt;iterator&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_type; 
&nbsp;&nbsp; <B>typedef</B> <B>typename</B> std::iterator_traits&lt;iterator&gt;::difference_type&nbsp; difference_type; 
&nbsp;&nbsp; <B>typedef</B> iterator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator_type; 
&nbsp;&nbsp; <STRONG>explicit</STRONG> match_results(<B>const</B> Allocator&amp; a = Allocator()); 
&nbsp;&nbsp; match_results(<B>const</B> match_results&amp; m); 
&nbsp;&nbsp; match_results&amp; <B>operator</B>=(<B>const</B> match_results&amp; m); 
&nbsp;&nbsp; ~match_results(); 
&nbsp;&nbsp; size_type size()<B>const</B>; 
&nbsp;&nbsp; <B>const</B> sub_match&lt;iterator&gt;&amp; <B>operator</B>[](<B>int</B> n) <B>const</B>; 
&nbsp;&nbsp; Allocator allocator()<B>const</B>; 
&nbsp;&nbsp; difference_type length(<B>int</B> sub = 0)<B>const</B>; 
&nbsp;&nbsp; difference_type position(<B>unsigned</B> <B>int</B> sub = 0)<B>const</B>; 
&nbsp;&nbsp; <B>unsigned</B> <B>int</B> line()<B>const</B>; 
&nbsp;&nbsp; iterator line_start()<B>const</B>; 
&nbsp;&nbsp; std::basic_string&lt;char_type&gt; str(<B>int</B> sub = 0)<B>const</B>; 
&nbsp;&nbsp; <B>void</B> swap(match_results&amp; that); 
&nbsp;&nbsp; <B>bool</B> <B>operator</B>==(<B>const</B> match_results&amp; that)<B>const</B>; 
&nbsp;&nbsp; <B>bool</B> <B>operator</B>&lt;(<B>const</B> match_results&amp; that)<B>const</B>; 
};
<STRONG>typedef</STRONG> match_results&lt;<STRONG>const</STRONG> <STRONG>char</STRONG>*&gt; cmatch;
<STRONG>typedef</STRONG> match_results&lt;<STRONG>const</STRONG> <STRONG>wchar_t</STRONG>*&gt; wcmatch; </PRE>
<FONT SIZE=2><P>Class match_results is used for reporting what matched a regular expression, it is passed to the matching algorithms </FONT><A HREF="#query_match"><FONT SIZE=2>regex_match</FONT></A><FONT SIZE=2> and </FONT><A HREF="#reg_search"><FONT SIZE=2>regex_search</FONT></A><FONT SIZE=2>, and is used by </FONT><A HREF="#reg_grep"><FONT SIZE=2>regex_grep</FONT></A><FONT SIZE=2> to notify the callback function (or function object) what matched. Note that the default allocator parameter has been chosen to match the default allocator parameter to reg_expression. match_results has the following public member functions: <BR>
&nbsp; </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=624>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P><FONT SIZE=2>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>match_results(Allocator a = Allocator());</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Constructs an instance of match_results, using allocator instance a.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>match_results(const match_results&amp; m);</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Copy constructor.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>match_results&amp; operator=(const match_results&amp; m);</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Assignment operator.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<B><FONT SIZE=2><P>const</B> sub_match&lt;iterator&gt;&amp; <B>operator</B>[](size_type n) const;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Returns what matched, item 0 represents the whole string, item 1 the first sub-expression and so on.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Allocator&amp; allocator()const;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Returns the allocator used by the class.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>difference_type length(<B>unsigned int</B> sub = 0);</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Returns the length of the matched subexpression, defaults to the length of the whole match, in effect this is equivalent to operator[](sub).second - operator[](sub).first.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>difference_type position(<B>unsigned int</B> sub = 0);</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Returns the position of the matched sub-expression, defaults to the position of the whole match. The returned value is the position of the match relative to the start of the string.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<B><FONT SIZE=2><P>unsigned</B> <B>int</B> line()<B>const</B>;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Returns the index of the line on which the match occurred, indices start with 1, not zero. Equivalent to the number of newline characters prior to operator[](0).first plus one.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>iterator line_start()<B>const;</B></FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Returns an iterator denoting the start of the line on which the match occurred.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>size_type size()<B>const;</B></FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Returns how many sub-expressions are present in the match, including sub-expression zero (the whole match). Returns zero if no matches were found in the search operation.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
</TABLE>

<FONT SIZE=2><P><BR>
&nbsp; </P>
<P>The operator[] member function needs further explanation: it returns a const reference to a structure of type sub_match&lt;iterator&gt;, which has the following public members: <BR>
&nbsp; </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=624>
<TR><TD WIDTH="6%" VALIGN="TOP">
<P><FONT SIZE=2>&nbsp;</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT SIZE=2><P>typedef</B> <B>typename</B> std::iterator_traits&lt;iterator&gt;::value_type value_type;</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>The type pointed to by the iterators.</FONT></TD>
<TD WIDTH="5%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="6%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT SIZE=2><P>typedef</B> <B>typename</B> std::iterator_traits&lt;iterator&gt;::difference_type difference_type;</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>A type that represents the difference between two iterators.</FONT></TD>
<TD WIDTH="5%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="6%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT SIZE=2><P>typedef</B> iterator iterator_type;</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>The iterator type.</FONT></TD>
<TD WIDTH="5%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="6%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>iterator first</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>An iterator denoting the position of the start of the match.</FONT></TD>
<TD WIDTH="5%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="6%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>iterator second</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>An iterator denoting the position of the end of the match.</FONT></TD>
<TD WIDTH="5%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="6%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT SIZE=2><P>bool</B> matched</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>A Boolean value denoting whether this sub-expression participated in the match.</FONT></TD>
<TD WIDTH="5%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="6%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>difference_type length()<B>const;</B></FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>Returns the length of the sub-expression match.</FONT></TD>
<TD WIDTH="5%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="6%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<B><FONT SIZE=2><P>operator</B> std::basic_string&lt;value_type&gt; ()<B>const</B>;</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>Converts the sub-expression match into an instance of std::basic_string&lt;&gt;. Note that this member may be either absent, or present to a more limited degree depending upon your compiler capabilities.</FONT></TD>
<TD WIDTH="5%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
</TABLE>

<FONT SIZE=2><P>Operator[] takes an integer as an argument that denotes the sub-expression for which to return information, the argument can take the following special values: <BR>
&nbsp; </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=624>
<TR><TD WIDTH="6%" VALIGN="TOP">
<P><FONT SIZE=2>&nbsp;</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>-2</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>Returns everything from the end of the match, to the end of the input string, equivalent to $' in perl. If this is a null string, then: </P>
<P>first == second </P>
<P>And </P>
<P>matched == false.</FONT></TD>
<TD WIDTH="5%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="6%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>-1</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>Returns everything from the start of the input string (or the end of the last match if this is a grep operation), to the start of this match. Equivalent to $` in perl. If this is a null string, then: </P>
<P>first == second </P>
<P>And </P>
<P>matched == false.</FONT></TD>
<TD WIDTH="5%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="6%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>0</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>Returns the whole of what matched, equivalent to $&amp; in perl. The matched parameter is always true.</FONT></TD>
<TD WIDTH="5%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="6%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>0 &lt; N &lt; size()</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>Returns what matched sub-expression N, if this sub-expression did not participate in the match then&nbsp; </P>
<P>matched == false </P>
<P>otherwise: </P>
<P>matched == true.</FONT></TD>
<TD WIDTH="5%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="6%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>N &lt; -2 or N &gt;= size()</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>Represents an out-of range non-existent sub-expression. Returns a "null" match in which </P>
<P>first == last </P>
<P>And </P>
<P>matched == false.</FONT></TD>
<TD WIDTH="5%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
</TABLE>

<FONT SIZE=2><P>Note that as well as being parameterised for an allocator, match_results&lt;&gt; also takes an iterator type, this allows any pair of iterators to be searched for a given regular expression, provided the iterators have at least bi-directional properties. </P>
</FONT><P><HR></P>
<H3><A NAME="query_match"></A>Algorithm regex_match</H3>
<FONT SIZE=2><P>#include &lt;</FONT><A HREF="../../boost/regex.hpp"><FONT SIZE=2>boost/regex.hpp</FONT></A><FONT SIZE=2>&gt; </P>
<P>The algorithm regex _match determines whether a given regular expression matches a given sequence denoted by a pair of iterators, the algorithm is defined as follows, note that the result is true only if the expression matches the whole of the input sequence, the main use of this function is data input validation: </P>
</FONT><B><PRE>template</B> &lt;<B>class</B> iterator, <B>class</B> Allocator, <B>class</B> charT, <B>class</B> traits, <B>class</B> Allocator2&gt;
<B>bool</B> regex_match(iterator first,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator last,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match_results&lt;iterator, Allocator&gt;&amp; m,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>const</B> reg_expression&lt;charT, traits, Allocator2&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>unsigned</B> flags = match_default);</PRE>
<FONT SIZE=2><P>The library also defines the following convenience versions, which take either a const charT*, or a const std::basic_string&lt;&gt;&amp; in place of a pair of iterators [note - these versions may not be available, or may be available in a more limited form, depending upon your compilers capabilities]: </P>
</FONT><B><PRE>template</B> &lt;<B>class</B> charT, <B>class</B> Allocator, <B>class</B> traits, <B>class</B> Allocator2&gt;
<B>bool</B> regex_match(<B>const</B> charT* str,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match_results&lt;<B>const</B> charT*, Allocator&gt;&amp; m,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>const</B> reg_expression&lt;charT, traits, Allocator2&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>unsigned</B> flags = match_default)

<B>template</B> &lt;<B>class</B> ST, <B>class</B> SA, <B>class</B> Allocator, <B>class</B> charT, <B>class</B> traits, <B>class</B> Allocator2&gt;
<B>bool</B> regex_match(<B>const</B> std::basic_string&lt;charT, ST, SA&gt;&amp; s,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match_results&lt;<B>typename</B> std::basic_string&lt;charT, ST, SA&gt;::const_iterator, Allocator&gt;&amp; m,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>const</B> reg_expression&lt;charT, traits, Allocator2&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>unsigned</B> flags = match_default);</PRE>
<FONT SIZE=2><P>Finally there is a set of convenience versions that simply return true or false and do not indicate what matched: </P>
</FONT><B><PRE>template</B> &lt;<B>class</B> iterator, <B>class</B> Allocator, <B>class</B> charT, <B>class</B> traits, <B>class</B> Allocator2&gt;
<B>bool</B> regex_match(iterator first,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator last,&nbsp;
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const</B> reg_expression&lt;charT, traits, Allocator2&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>unsigned</B> flags = match_default);

<B>template</B> &lt;<B>class</B> charT, <B>class</B> Allocator, <B>class</B> traits, <B>class</B> Allocator2&gt;
<B>bool</B> regex_match(<B>const</B> charT* str,&nbsp;
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const</B> reg_expression&lt;charT, traits, Allocator2&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>unsigned</B> flags = match_default)

<B>template</B> &lt;<B>class</B> ST, <B>class</B> SA, <B>class</B> Allocator, <B>class</B> charT, <B>class</B> traits, <B>class</B> Allocator2&gt;
<B>bool</B> regex_match(<B>const</B> std::basic_string&lt;charT, ST, SA&gt;&amp; s,&nbsp;
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const</B> reg_expression&lt;charT, traits, Allocator2&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>unsigned</B> flags = match_default);</PRE>
<FONT SIZE=2><P>The parameters for the main function version are as follows: <BR>
&nbsp; </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=624>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P><FONT SIZE=2>&nbsp;</FONT></TD>
<TD WIDTH="51%" VALIGN="MIDDLE">
<FONT SIZE=2><P>iterator first</FONT></TD>
<TD VALIGN="MIDDLE">
<FONT SIZE=2><P>Denotes the start of the range to be matched.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT SIZE=2><P>iterator last</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT SIZE=2><P>Denotes the end of the range to be matched.</FONT></TD>
<TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT SIZE=2><P>match_results&lt;iterator, Allocator&gt;&amp; m</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT SIZE=2><P>An instance of match_results in which what matched will be reported. On exit if a match occurred then m[0] denotes the whole of the string that matched, m[0].first must be equal to first, m[0].second will be less than or equal to last. m[1] denotes the first subexpression m[2] the second subexpression and so on. If no match occurred then m[0].first = m[0].second = last.</FONT></TD>
<TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT SIZE=2><P>const reg_expression&lt;charT, traits, Allocator2&gt;&amp; e</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT SIZE=2><P>Contains the regular expression to be matched.</FONT></TD>
<TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT SIZE=2><P>unsigned flags = match_default</FONT></TD>
<TD WIDTH="51%" VALIGN="TOP">
<FONT SIZE=2><P>Determines the semantics used for matching, a combination of one or more </FONT><A HREF="#match_type"><FONT SIZE=2>match_flags</FONT></A><FONT SIZE=2> enumerators.</FONT></TD>
<TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
</TABLE>

<FONT SIZE=2><P>regex_match returns false if no match occurs or true if it does. A match only occurs if it starts at <B>first</B> and finishes at <B>last</B>. Example: the following </FONT><A HREF="demo/snippets/snip1.cpp"><FONT SIZE=2>example</FONT></A><FONT SIZE=2> processes an ftp response: </P>
</FONT><FONT COLOR="#008000"><PRE>#include &lt;stdlib.h&gt; 
#include &lt;boost/regex.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

</FONT><B>using namespace</B> boost; 

regex expression(<FONT COLOR="#000080">"([0-9]+)(\\-| |$)(.*)"</FONT>); 

<I><FONT COLOR="#000080">// process_ftp: 
// on success returns the ftp response code, and fills 
// msg with the ftp response message. 
</I></FONT><B>int</B> process_ftp(<B>const</B> <B>char</B>* response, std::string* msg) 
{ 
&nbsp;&nbsp; cmatch what; 
&nbsp;&nbsp; <B>if</B>(regex_match(response, what, expression)) 
&nbsp;&nbsp; { 
<FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I>// what[0] contains the whole string 
</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I>// what[1] contains the response code 
</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I>// what[2] contains the separator character 
</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I>// what[3] contains the text message. 
</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>if</B>(msg) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg-&gt;assign(what[3].first, what[3].second); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>return</B> std::atoi(what[1].first); 
&nbsp;&nbsp; } 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// failure did not match 
</I></FONT>&nbsp;&nbsp; <B>if</B>(msg) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg-&gt;erase(); 
&nbsp;&nbsp; <B>return</B> -1; 
}</PRE>
<FONT SIZE=2><P><A NAME="match_type"></A>The value of the flags parameter passed to the algorithm must be a combination of one or more of the following values: <BR>
&nbsp; </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=624>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P><FONT SIZE=2>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>match_default</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>The default value, indicates that <B>first</B> represents the start of a line, the start of a buffer, and (possibly) the start of a word. Also implies that <B>last</B> represents the end of a line, the end of the buffer and (possibly) the end of a word. Implies that a dot sub-expression "." will match both the newline character and a null.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>match_not_bol</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>When this flag is set then <B>first</B> does not represent the start of a new line.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>match_not_eol</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>When this flag is set then <B>last</B> does not represent the end of a line.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>match_not_bob</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>When this flag is set then <B>first</B> is not the beginning of a buffer.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>match_not_eob</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>When this flag is set then <B>last</B> does not represent the end of a buffer.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>match_not_bow</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>When this flag is set then <B>first</B> can never match the start of a word.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>match_not_eow</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>When this flag is set then <B>last</B> can never match the end of a word.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>match_not_dot_newline</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>When this flag is set then a dot expression "." can not match the newline character.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>match_not_dot_null</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>When this flag is set then a dot expression "." can not match a null character.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE" HEIGHT=75>
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=75>
<FONT SIZE=2><P>match_prev_avail</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=75>
<FONT SIZE=2><P>When this flag is set, then *--<B>first</B> is a valid expression and the flags match_not_bol and match_not_bow have no effect, since the value of the previous character can be used to check these.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE" HEIGHT=75>
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE" HEIGHT=15>
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=15>
<FONT SIZE=2><P>match_any</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=15>
<FONT SIZE=2><P>When this flag is set, then the first string matched is returned, rather than the longest possible match. This flag can significantly reduce the time taken to find a match, but what matches is undefined.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE" HEIGHT=15>
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE" HEIGHT=15>
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=15>
<FONT SIZE=2><P>match_not_null</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=15>
<FONT SIZE=2><P>When this flag is set, then the expression will never match a null string.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE" HEIGHT=15>
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE" HEIGHT=15>
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=15>
<FONT SIZE=2><P>match_continuous</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=15>
<FONT SIZE=2><P>When this flags is set, then during a grep operation, each successive match must start from where the previous match finished.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE" HEIGHT=15>
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="5%" VALIGN="MIDDLE" HEIGHT=15><P></P></TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=15>
<FONT SIZE=2><P>match_partial</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP" HEIGHT=15>
<FONT SIZE=2><P>When this flag is set, the regex algorithms will report </FONT><A HREF="#partial_matches">partial matches</A><FONT SIZE=2> - that is where one or more characters at the end of the text input matched some prefix of the regular expression.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE" HEIGHT=15><P></P></TD>
</TR>
</TABLE>

<P>&nbsp;</P>
<P><HR ALIGN="RIGHT"></P>
<H3><A NAME="reg_search"></A>Algorithm regex_search</H3>
<FONT SIZE=2><P>&nbsp;#include &lt;</FONT><A HREF="../../boost/regex.hpp"><FONT SIZE=2>boost/regex.hpp</FONT></A><FONT SIZE=2>&gt; </P>
<P>The algorithm regex_search will search a range denoted by a pair of iterators for a given regular expression. The algorithm uses various heuristics to reduce the search time by only checking for a match if a match could conceivably start at that position. The algorithm is defined as follows: </P>
</FONT><B><PRE>template</B> &lt;<B>class</B> iterator, <B>class</B> Allocator, <B>class</B> charT, <B>class</B> traits, <B>class</B> Allocator2&gt;
<B>bool</B> regex_search(iterator first,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator last,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match_results&lt;iterator, Allocator&gt;&amp; m,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>const</B> reg_expression&lt;charT, traits, Allocator2&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>unsigned</B> flags = match_default);</PRE>
<FONT SIZE=2><P>The library also defines the following convenience versions, which take either a const charT*, or a const std::basic_string&lt;&gt;&amp; in place of a pair of iterators [note - these versions may not be available, or may be available in a more limited form, depending upon your compilers capabilities]: </P>
</FONT><B><PRE>template</B> &lt;<B>class</B> charT, <B>class</B> Allocator, <B>class</B> traits, <B>class</B> Allocator2&gt;
<B>bool</B> regex_search(<B>const</B> charT* str,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match_results&lt;<B>const</B> charT*, Allocator&gt;&amp; m,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>const</B> reg_expression&lt;charT, traits, Allocator2&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>unsigned</B> flags = match_default);

<B>template</B> &lt;<B>class</B> ST, <B>class</B> SA, <B>class</B> Allocator, <B>class</B> charT, <B>class</B> traits, <B>class</B> Allocator2&gt;
<B>bool</B> regex_search(<B>const</B> std::basic_string&lt;charT, ST, SA&gt;&amp; s,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match_results&lt;<B>typename</B> std::basic_string&lt;charT, ST, SA&gt;::const_iterator, Allocator&gt;&amp; m,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>const</B> reg_expression&lt;charT, traits, Allocator2&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>unsigned</B> flags = match_default);</PRE>
<FONT SIZE=2><P>The parameters for the main function version are as follows: <BR>
&nbsp; </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=624>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P><FONT SIZE=2>&nbsp;</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>iterator first</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>The starting position of the range to search.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>iterator last</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>The ending position of the range to search.</FONT></TD>
<TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>match_results&lt;iterator, Allocator&gt;&amp; m</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>An instance of match_results in which what matched will be reported. On exit if a match occurred then m[0] denotes the whole of the string that matched, m[0].first and m[0].second will be less than or equal to last. m[1] denotes the first sub-expression m[2] the second sub-expression and so on. If no match occurred then m[0].first = m[0].second = last.</FONT></TD>
<TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>const reg_expression&lt;charT, traits, Allocator2&gt;&amp; e</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>The regular expression to search for.</FONT></TD>
<TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>unsigned flags = match_default</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>The flags that determine what gets matched, a combination of one or more </FONT><A HREF="#match_type"><FONT SIZE=2>match_flags</FONT></A><FONT SIZE=2> enumerators.</FONT></TD>
<TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
</TABLE>

<FONT SIZE=2><P><BR>
&nbsp; </P>
<P>Example: the following </FONT><A HREF="demo/snippets/snip2.cpp"><FONT SIZE=2>example</FONT></A><FONT SIZE=2>, takes the contents of a file in the form of a string, and searches for all the C++ class declarations in the file. The code will work regardless of the way that std::string is implemented, for example it could easily be modified to work with the SGI rope class, which uses a non-contiguous storage strategy. </P>
</FONT><FONT COLOR="#008000"><PRE>#include &lt;string&gt; 
#include &lt;map&gt; 
#include &lt;boost/regex.hpp&gt; 
</FONT><I><FONT COLOR="#000080">
// purpose: 
// takes the contents of a file in the form of a string 
// and searches for all the C++ class definitions, storing 
// their locations in a map of strings/int's 
</I></FONT><B>typedef</B> std::map&lt;std::string, <B>int</B>, std::less&lt;std::string&gt; &gt; map_type; 

boost::regex expression("^(template[[:space:]]*&lt;[^;:{]+&gt;[[:space:]]*)?(class|struct)[[:space:]]*(\\&lt;\\w+\\&gt;([[:blank:]]*\\([^)]*\\))?[[:space:]]*)*(\\&lt;\\w*\\&gt;)[[:space:]]*(&lt;[^;:{]+&gt;[[:space:]]*)?(\\{|:[^;\\{()]*\\{)"); 
<B>
void</B> IndexClasses(map_type&amp; m, <B>const</B> std::string&amp; file) 
{ 
&nbsp;&nbsp; std::string::const_iterator start, end; 
&nbsp;&nbsp; start = file.begin(); 
&nbsp;&nbsp; end = file.end();&nbsp;
&nbsp;&nbsp; &nbsp;&nbsp; boost::match_results&lt;std::string::const_iterator&gt; what; 
&nbsp;&nbsp; <B>unsigned</B> <B>int</B> flags = boost::match_default; 
&nbsp;&nbsp; <B>while</B>(regex_search(start, end, what, expression, flags))&nbsp;
&nbsp;&nbsp; { 
<FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I>// what[0] contains the whole string 
</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I>// what[5] contains the class name. 
</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I>// what[6] contains the template specialisation if any. 
</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I>// add class name and position to map: 
</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m[std::string(what[5].first, what[5].second) + std::string(what[6].first, what[6].second)] =&nbsp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; what[5].first - file.begin();&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I><FONT COLOR="#000080">// update search position: 
</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start = what[0].second;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I><FONT COLOR="#000080">// update flags: 
</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags |= boost::match_prev_avail;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags |= boost::match_not_bob;&nbsp;
&nbsp;&nbsp; } 
}
 </PRE>
<P><HR></P>
<H3><A NAME="reg_grep"></A>Algorithm regex_grep</H3>
<FONT SIZE=2><P>#include &lt;</FONT><A HREF="../../boost/regex.hpp"><FONT SIZE=2>boost/regex.hpp</FONT></A><FONT SIZE=2>&gt; </P>
<P>&nbsp;Regex_grep allows you to search through an iterator range and locate all the (non-overlapping) matches with a given regular expression. The function is declared as: </P>
</FONT><B><PRE>template</B> &lt;<B>class</B> Predicate, <B>class</B> iterator, <B>class</B> charT, <B>class</B> traits, <B>class</B> Allocator&gt;
<B>unsigned</B> <B>int</B> regex_grep(Predicate foo,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator first,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator last,&nbsp;
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const</B> reg_expression&lt;charT, traits, Allocator&gt;&amp; e,&nbsp;
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned</B> flags = match_default)</PRE>
<FONT SIZE=2><P>The library also defines the following convenience versions, which take either a const charT*, or a const std::basic_string&lt;&gt;&amp; in place of a pair of iterators [note - these versions may not be available, or may be available in a more limited form, depending upon your compilers capabilities]: </P>
</FONT><B><PRE>template</B> &lt;<B>class</B> Predicate, <B>class</B> charT, <B>class</B> Allocator, <B>class</B> traits&gt;
<B>unsigned</B> <B>int</B> regex_grep(Predicate foo,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>const</B> charT* str,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>const</B> reg_expression&lt;charT, traits, Allocator&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>unsigned</B> flags = match_default);

<B>template</B> &lt;<B>class</B> Predicate, <B>class</B> ST, <B>class</B> SA, <B>class</B> Allocator, <B>class</B> charT, <B>class</B> traits&gt;
<B>unsigned</B> <B>int</B> regex_grep(Predicate foo,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>const</B> std::basic_string&lt;charT, ST, SA&gt;&amp; s,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>const</B> reg_expression&lt;charT, traits, Allocator&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>unsigned</B> flags = match_default);</PRE>
<FONT SIZE=2><P>The parameters for the primary version of regex_grep have the following meanings: <BR>
&nbsp; </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=624>
<TR><TD WIDTH="5%" VALIGN="MIDDLE">
<P><FONT SIZE=2>&nbsp;</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>foo</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>A predicate function object or function pointer, see below for more information.</FONT></TD>
<TD WIDTH="5%" VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>first</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>The start of the range to search.</FONT></TD>
<TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>last</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>The end of the range to search.</FONT></TD>
<TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>e</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>The regular expression to search for.</FONT></TD>
<TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>flags</FONT></TD>
<TD WIDTH="50%" VALIGN="TOP">
<FONT SIZE=2><P>The flags that determine how matching is carried out, one of the </FONT><A HREF="#match_type"><FONT SIZE=2>match_flags</FONT></A><FONT SIZE=2> enumerators.</FONT></TD>
<TD VALIGN="MIDDLE">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
</TABLE>

<FONT SIZE=2><P>&nbsp;The algorithm finds all of the non-overlapping matches of the expression e, for each match it fills a </FONT><A HREF="#reg_match"><FONT SIZE=2>match_results</FONT></A><FONT SIZE=2>&lt;iterator, Allocator&gt; structure, which contains information on what matched, and calls the predicate foo, passing the match_results&lt;iterator, Allocator&gt; as a single argument. If the predicate returns true, then the grep operation continues, otherwise it terminates without searching for further matches. The function returns the number of matches found.</P>
<P>The general form of the predicate is: </P>
</FONT><B><PRE>struct</B> grep_predicate
{
<B>&nbsp;&nbsp; bool</B> <B>operator</B>()(<B>const</B> match_results&lt;iterator_type, expression_type::alloc_type&gt;&amp; m);
};</PRE>
<FONT SIZE=2><P>For example the regular expression "a*b" would find one match in the string "aaaaab" and two in the string "aaabb". </P>
<P>Remember this algorithm can be used for a lot more than implementing a version of grep, the predicate can be and do anything that you want, grep utilities would output the results to the screen, another program could index a file based on a regular expression and store a set of bookmarks in a list, or a text file conversion utility would output to file. The results of one regex_grep can even be chained into another regex_grep to create recursive parsers. </P>
</FONT><P><A HREF="demo/snippets/snip3.cpp"><FONT SIZE=2>Example</FONT></A><FONT SIZE=2>: convert the example from <I>regex_search</I> to use <I>regex_grep</I> instead: </P>
</FONT><FONT COLOR="#008000"><PRE>#include &lt;string&gt; 
#include &lt;map&gt; 
#include &lt;boost/regex.hpp&gt; 

</FONT><I><FONT COLOR="#000080">// IndexClasses: 
// takes the contents of a file in the form of a string 
// and searches for all the C++ class definitions, storing 
// their locations in a map of strings/int's 
</I></FONT><B>
typedef</B> std::map&lt;std::string, <B>int</B>, std::less&lt;std::string&gt; &gt; map_type; 

boost::regex expression(<FONT COLOR="#000080">"^(template[[:space:]]*&lt;[^;:{]+&gt;[[:space:]]*)?" 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "(class|struct)[[:space:]]*(\\&lt;\\w+\\&gt;([[:blank:]]*\\([^)]*\\))?[[:space:]]*)*(\\&lt;\\w*\\&gt;)" 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "[[:space:]]*(&lt;[^;:{]+&gt;[[:space:]]*)?(\\{|:[^;\\{()]*\\{)"</FONT>); 
<B>
class</B> IndexClassesPred 
{ 
&nbsp;&nbsp; map_type&amp; m; 
&nbsp;&nbsp; std::string::const_iterator base; 
<B>public</B>: 
&nbsp;&nbsp; IndexClassesPred(map_type&amp; a, std::string::const_iterator b) : m(a), base(b) {} 
&nbsp;&nbsp; <B>bool</B> <B>operator</B>()(<B>const</B> match_results&lt;std::string::const_iterator, regex::alloc_type&gt;&amp; what) 
&nbsp;&nbsp; { 
<FONT COLOR="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I>// what[0] contains the whole string 
</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I>// what[5] contains the class name. 
</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I>// what[6] contains the template specialisation if any. 
</I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <I>// add class name and position to map: 
</I></FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m[std::string(what[5].first, what[5].second) + std::string(what[6].first, what[6].second)] =&nbsp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; what[5].first - base; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>return</B> <B>true</B>; 
&nbsp;&nbsp; } 
}; 
<B>
void</B> IndexClasses(map_type&amp; m, <B>const</B> std::string&amp; file) 
{ 
&nbsp;&nbsp; std::string::const_iterator start, end; 
&nbsp;&nbsp; start = file.begin(); 
&nbsp;&nbsp; end = file.end(); 
&nbsp;&nbsp; regex_grep(IndexClassesPred(m, start), start, end, expression); 
} </PRE>
<P><A HREF="demo/snippets/snip5.cpp"><FONT SIZE=2>Example</FONT></A><FONT SIZE=2>: Use regex_grep to call a global callback function: </P>
</FONT><FONT COLOR="#008000"><PRE>#include &lt;string&gt; 
#include &lt;map&gt; 
#include &lt;boost/regex.hpp&gt; 

</FONT><I><FONT COLOR="#000080">// purpose: 
// takes the contents of a file in the form of a string 
// and searches for all the C++ class definitions, storing 
// their locations in a map of strings/int's 
</I></FONT><B>
typedef</B> std::map&lt;std::string, <B>int</B>, std::less&lt;std::string&gt; &gt; map_type; 

boost::regex expression(<FONT COLOR="#000080">"^(template[[:space:]]*&lt;[^;:{]+&gt;[[:space:]]*)?(class|struct)[[:space:]]*(\\&lt;\\w+\\&gt;([[:blank:]]*\\([^)]*\\))?[[:space:]]*)*(\\&lt;\\w*\\&gt;)[[:space:]]*(&lt;[^;:{]+&gt;[[:space:]]*)?(\\{|:[^;\\{()]*\\{)"</FONT>); 

map_type class_index; 
std::string::const_iterator base; 

<B>bool</B> grep_callback(<B>const</B> boost::match_results&lt;std::string::const_iterator, boost::regex::alloc_type&gt;&amp; what) 
{ 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// what[0] contains the whole string 
</I>&nbsp;&nbsp; <I>// what[5] contains the class name. 
</I>&nbsp;&nbsp; <I>// what[6] contains the template specialisation if any. 
</I>&nbsp;&nbsp; <I>// add class name and position to map: 
</I></FONT>&nbsp;&nbsp; class_index[std::string(what[5].first, what[5].second) + std::string(what[6].first, what[6].second)] =&nbsp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; what[5].first - base; 
&nbsp;&nbsp; <B>return</B> <B>true</B>; 
} 
<B>
void</B> IndexClasses(<B>const</B> std::string&amp; file) 
{ 
&nbsp;&nbsp; std::string::const_iterator start, end; 
&nbsp;&nbsp; start = file.begin(); 
&nbsp;&nbsp; end = file.end(); 
&nbsp;&nbsp; base = start; 
&nbsp;&nbsp; regex_grep(grep_callback, start, end, expression, match_default); 
}
&nbsp; </PRE>
<P><A HREF="demo/snippets/snip6.cpp"><FONT SIZE=2>Example</FONT></A><FONT SIZE=2>: use regex_grep to call a class member function, use the standard library adapters <I>std::mem_fun</I> and <I>std::bind1st</I> to convert the member function into a predicate: </P>
</FONT><FONT COLOR="#008000"><PRE>#include &lt;string&gt; 
#include &lt;map&gt; 
#include &lt;boost/regex.hpp&gt; 
#include &lt;functional&gt; 
</FONT><I><FONT COLOR="#000080">
// purpose: 
// takes the contents of a file in the form of a string 
// and searches for all the C++ class definitions, storing 
// their locations in a map of strings/int's 

</I></FONT><B>typedef</B> std::map&lt;std::string, <B>int</B>, std::less&lt;std::string&gt; &gt; map_type; 
<B>
class</B> class_index 
{ 
&nbsp;&nbsp; boost::regex expression; 
&nbsp;&nbsp; map_type index; 
&nbsp;&nbsp; std::string::const_iterator base; 
&nbsp;&nbsp; <B>bool</B> grep_callback(boost::match_results&lt;std::string::const_iterator, boost::regex::alloc_type&gt; what); 
<B>public</B>: 
<B>&nbsp;&nbsp; void</B> IndexClasses(<B>const</B> std::string&amp; file); 
&nbsp;&nbsp; class_index() 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : index(), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expression(<FONT COLOR="#000080">"^(template[[:space:]]*&lt;[^;:{]+&gt;[[:space:]]*)?" 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "(class|struct)[[:space:]]*(\\&lt;\\w+\\&gt;([[:blank:]]*\\([^)]*\\))?" 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "[[:space:]]*)*(\\&lt;\\w*\\&gt;)[[:space:]]*(&lt;[^;:{]+&gt;[[:space:]]*)?" 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "(\\{|:[^;\\{()]*\\{)" 
</FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ){} 
}; 
<B>
bool</B> class_index::grep_callback(boost::match_results&lt;std::string::const_iterator, boost::regex::alloc_type&gt; what) 
{ 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// what[0] contains the whole string 
</I>&nbsp;&nbsp; <I>// what[5] contains the class name. 
</I>&nbsp;&nbsp; <I>// what[6] contains the template specialisation if any. 
</I>&nbsp;&nbsp; <I>// add class name and position to map: 
</I></FONT>&nbsp;&nbsp; index[std::string(what[5].first, what[5].second) + std::string(what[6].first, what[6].second)] = 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; what[5].first - base; 
&nbsp;&nbsp; <B>return</B> <B>true</B>; 
} 

<B>void</B> class_index::IndexClasses(<B>const</B> std::string&amp; file) 
{ 
&nbsp;&nbsp; std::string::const_iterator start, end; 
&nbsp;&nbsp; start = file.begin(); 
&nbsp;&nbsp; end = file.end(); 
&nbsp;&nbsp; base = start; 
&nbsp;&nbsp; regex_grep(std::bind1st(std::mem_fun(&amp;class_index::grep_callback), <B>this</B>), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   start, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   end, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   expression); 
} 
&nbsp; </PRE>
<P><A HREF="demo/snippets/snip7.cpp"><FONT SIZE=2>Finally</FONT></A><FONT SIZE=2>, C++ Builder users can use C++ Builder's closure type as a callback argument: </P>
</FONT><FONT COLOR="#008000"><PRE>#include &lt;string&gt; 
#include &lt;map&gt; 
#include &lt;boost/regex.hpp&gt; 
#include &lt;functional&gt; 
</FONT><I><FONT COLOR="#000080">
// purpose: 
// takes the contents of a file in the form of a string 
// and searches for all the C++ class definitions, storing 
// their locations in a map of strings/int's 

</I></FONT><B>typedef</B> std::map&lt;std::string, <B>int</B>, std::less&lt;std::string&gt; &gt; map_type; 
<B>class</B> class_index 
{ 
&nbsp;&nbsp; boost::regex expression; 
&nbsp;&nbsp; map_type index; 
&nbsp;&nbsp; std::string::const_iterator base; 
&nbsp;&nbsp; <B>typedef</B> boost::match_results&lt;std::string::const_iterator, boost::regex::alloc_type&gt; arg_type; 
&nbsp;&nbsp; <B>bool</B> grep_callback(<B>const</B> arg_type&amp; what); 
<B>public</B>: 
&nbsp;&nbsp; <B>typedef</B> <B>bool</B> (<B>__closure</B>* grep_callback_type)(<B>const</B> arg_type&amp;); 
&nbsp;&nbsp; <B>void</B> IndexClasses(<B>const</B> std::string&amp; file); 
&nbsp;&nbsp; class_index() 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : index(), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expression(<FONT COLOR="#000080">"^(template[[:space:]]*&lt;[^;:{]+&gt;[[:space:]]*)?" 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "(class|struct)[[:space:]]*(\\&lt;\\w+\\&gt;([[:blank:]]*\\([^)]*\\))?" 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "[[:space:]]*)*(\\&lt;\\w*\\&gt;)[[:space:]]*(&lt;[^;:{]+&gt;[[:space:]]*)?" 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "(\\{|:[^;\\{()]*\\{)" 
</FONT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ){} 
}; 

<B>bool</B> class_index::grep_callback(<B>const</B> arg_type&amp; what) 
{ 
<FONT COLOR="#000080">&nbsp;&nbsp; <I>// what[0] contains the whole string </I>&nbsp;&nbsp; 
<I>// what[5] contains the class name. </I>&nbsp;&nbsp; 
<I>// what[6] contains the template specialisation if any. </I>&nbsp;&nbsp; 
<I>// add class name and position to map: </I></FONT>&nbsp;&nbsp; 
index[std::string(what[5].first, what[5].second) + std::string(what[6].first, what[6].second)] = 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; what[5].first - base; 
&nbsp;&nbsp; <B>return</B> <B>true</B>; 
} 

<B>void</B> class_index::IndexClasses(<B>const</B> std::string&amp; file) 
{ 
&nbsp;&nbsp; std::string::const_iterator start, end; 
&nbsp;&nbsp; start = file.begin(); 
&nbsp;&nbsp; end = file.end(); 
&nbsp;&nbsp; base = start; 
&nbsp;&nbsp; class_index::grep_callback_type cl = &amp;(<B>this</B>-&gt;grep_callback); 
&nbsp;&nbsp; regex_grep(cl, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expression); 
} </PRE>
<P><HR></P>
<H3>&nbsp;<A NAME="reg_format"></A>Algorithm regex_format</H3>
<FONT SIZE=2><P>#include &lt;</FONT><A HREF="../../boost/regex.hpp"><FONT SIZE=2>boost/regex.hpp</FONT></A><FONT SIZE=2>&gt; </P>
<P>The algorithm regex_format takes the results of a match and creates a new string based upon a </FONT><A HREF="format_string.htm#format_string"><FONT SIZE=2>format string</FONT></A><FONT SIZE=2>, regex_format can be used for search and replace operations: </P>
</FONT><B><PRE>template</B> &lt;<B>class</B> OutputIterator, <B>class</B> iterator, <B>class</B> Allocator, <B>class</B> charT&gt;
OutputIterator regex_format(OutputIterator out,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>const</B> match_results&lt;iterator, Allocator&gt;&amp; m,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>const</B> charT* fmt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>unsigned</B> flags = 0);
<B>
template</B> &lt;<B>class</B> OutputIterator, <B>class</B> iterator, <B>class</B> Allocator, <B>class</B> charT&gt;
OutputIterator regex_format(OutputIterator out,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>const</B> match_results&lt;iterator, Allocator&gt;&amp; m,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>const</B> std::basic_string&lt;charT&gt;&amp; fmt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>unsigned</B> flags = 0);</PRE>
<FONT SIZE=2><P>The library also defines the following convenience variation of regex_format, which returns the result directly as a string, rather than outputting to an iterator [note - this version may not be available, or may be available in a more limited form, depending upon your compilers capabilities]: </P>
</FONT><B><PRE>template</B> &lt;<B>class</B> iterator, <B>class</B> Allocator, <B>class</B> charT&gt;
std::basic_string&lt;charT&gt; regex_format
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<B>const</B> match_results&lt;iterator, Allocator&gt;&amp; m,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>const</B> charT* fmt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>unsigned</B> flags = 0);

<B>template</B> &lt;<B>class</B> iterator, <B>class</B> Allocator, <B>class</B> charT&gt;
std::basic_string&lt;charT&gt; regex_format
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<B>const</B> match_results&lt;iterator, Allocator&gt;&amp; m,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>const</B> std::basic_string&lt;charT&gt;&amp; fmt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>unsigned</B> flags = 0);</PRE>
<FONT SIZE=2><P>Parameters to the main version of the function are passed as follows: <BR>
&nbsp; </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=624>
<TR><TD WIDTH="9%" VALIGN="TOP">
<P><FONT SIZE=2>&nbsp;</FONT></TD>
<TD WIDTH="39%" VALIGN="TOP">
<FONT SIZE=2><P>OutputIterator out</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>An output iterator type, the output string is sent to this iterator. Typically this would be a std::ostream_iterator.</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="39%" VALIGN="TOP">
<B><FONT SIZE=2><P>const</B> match_results&lt;iterator, Allocator&gt;&amp; m</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>An instance of match_results&lt;&gt; obtained from one of the matching algorithms above, and denoting what matched.</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="39%" VALIGN="TOP">
<B><FONT SIZE=2><P>const</B> charT* fmt</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>A format string that determines how the match is transformed into the new string.</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="39%" VALIGN="TOP">
<B><FONT SIZE=2><P>unsigned</B> flags</FONT></TD>
<TD WIDTH="44%" VALIGN="TOP">
<FONT SIZE=2><P>Optional flags which describe how the format string is to be interpreted.</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
</TABLE>

<FONT SIZE=2><P><A NAME="format_flags"></A>Format flags are defined as follows: <BR>
&nbsp; </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=624>
<TR><TD WIDTH="9%" VALIGN="TOP">
<P><FONT SIZE=2>&nbsp;</FONT></TD>
<TD WIDTH="39%" VALIGN="TOP">
<FONT SIZE=2><P>format_all</FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<FONT SIZE=2><P>Enables all syntax options (perl-like plus extentions).</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="39%" VALIGN="TOP">
<FONT SIZE=2><P>format_sed</FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<FONT SIZE=2><P>Allows only a sed-like syntax.</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="39%" VALIGN="TOP">
<FONT SIZE=2><P>format_perl</FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<FONT SIZE=2><P>Allows only a perl-like syntax.</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="9%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="39%" VALIGN="TOP">
<FONT SIZE=2><P>format_no_copy</FONT></TD>
<TD WIDTH="43%" VALIGN="TOP">
<FONT SIZE=2><P>Disables copying of unmatched sections to the output string during </FONT><A HREF="#reg_merge"><FONT SIZE=2>regex_merge</FONT></A><FONT SIZE=2> operations.</FONT></TD>
<TD WIDTH="9%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
</TABLE>

<FONT SIZE=2><P><BR>
&nbsp; </P>
<P>The format string syntax (and available options) is described more fully under </FONT><A HREF="format_string.htm#format_string"><FONT SIZE=2>format strings</FONT></A><FONT SIZE=2>. </P>
</FONT><P><HR></P>
<H3><A NAME="reg_merge"></A>Algorithm regex_merge</H3>
<FONT SIZE=2><P>#include &lt;</FONT><A HREF="../../boost/regex.hpp"><FONT SIZE=2>boost/regex.hpp</FONT></A><FONT SIZE=2>&gt; </P>
<P>The algorithm regex_merge is a combination of </FONT><A HREF="#reg_grep"><FONT SIZE=2>regex_grep</FONT></A><FONT SIZE=2> and </FONT><A HREF="#reg_format"><FONT SIZE=2>regex_format</FONT></A><FONT SIZE=2>. That is, it greps through the string finding all the matches to the regular expression, for each match it then calls regex_format to format the string and sends the result to the output iterator. Sections of text that do not match are copied to the output unchanged only if the flags parameter does not have the flag </FONT><A HREF="#format_flags"><FONT SIZE=2>format_no_copy</FONT></A><FONT SIZE=2> set. </P>
</FONT><B><PRE>template</B> &lt;<B>class</B> OutputIterator, <B>class</B> iterator, <B>class</B> traits, <B>class</B> Allocator, <B>class</B> charT&gt;
OutputIterator regex_merge(OutputIterator out,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>const</B> reg_expression&lt;charT, traits, Allocator&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>const</B> charT* fmt,&nbsp;
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned</B> <B>int</B> flags = match_default);

<B>template</B> &lt;<B>class</B> OutputIterator, <B>class</B> iterator, <B>class</B> traits, <B>class</B> Allocator, <B>class</B> charT&gt;
OutputIterator regex_merge(OutputIterator out,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>const</B> reg_expression&lt;charT, traits, Allocator&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::basic_string&lt;charT&gt;&amp; fmt,&nbsp;
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned</B> <B>int</B> flags = match_default);</PRE>
<FONT SIZE=2><P>The library also defines the following convenience variation of regex_merge, which returns the result directly as a string, rather than outputting to an iterator [note - this version may not be available, or may be available in a more limited form, depending upon your compilers capabilities]: </P>
</FONT><B><PRE>template</B> &lt;<B>class</B> traits, <B>class</B> Allocator, <B>class</B> charT&gt;
std::basic_string&lt;charT&gt; regex_merge(<B>const</B> std::basic_string&lt;charT&gt;&amp; text,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>const</B> reg_expression&lt;charT, traits, Allocator&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>const</B> charT* fmt,&nbsp;
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned</B> <B>int</B> flags = match_default);

<B>template</B> &lt;<B>class</B> traits, <B>class</B> Allocator, <B>class</B> charT&gt;
std::basic_string&lt;charT&gt; regex_merge(<B>const</B> std::basic_string&lt;charT&gt;&amp; text,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>const</B> reg_expression&lt;charT, traits, Allocator&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>const</B> std::basic_string&lt;charT&gt;&amp; fmt,&nbsp;
<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned</B> <B>int</B> flags = match_default);</PRE>
<FONT SIZE=2><P>Parameters to the main version of the function are passed as follows: <BR>
&nbsp; </P></FONT>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=624>
<TR><TD WIDTH="7%" VALIGN="TOP">
<P><FONT SIZE=2>&nbsp;</FONT></TD>
<TD WIDTH="40%" VALIGN="TOP">
<FONT SIZE=2><P>OutputIterator out</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>An output iterator type, the output string is sent to this iterator. Typically this would be a std::ostream_iterator.</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="7%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="40%" VALIGN="TOP">
<FONT SIZE=2><P>iterator first</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>The start of the range of text to grep.</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="7%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="40%" VALIGN="TOP">
<FONT SIZE=2><P>iterator last</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>The end of the range of text to grep.</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="7%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="40%" VALIGN="TOP">
<B><FONT SIZE=2><P>const</B> reg_expression&lt;charT, traits, Allocator&gt;&amp; e</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>The expression to search for.</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="7%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="40%" VALIGN="TOP">
<B><FONT SIZE=2><P>const</B> charT* fmt</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>The format string to be applied to sections of text that match.</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
<TR><TD WIDTH="7%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
<TD WIDTH="40%" VALIGN="TOP">
<B><FONT SIZE=2><P>unsigned</B> <B>int</B> flags = match_default</FONT></TD>
<TD WIDTH="45%" VALIGN="TOP">
<FONT SIZE=2><P>Flags which determine how the expression is matched - see </FONT><A HREF="#match_type"><FONT SIZE=2>match_flags</FONT></A><FONT SIZE=2>, and how the format string is interpreted - see </FONT><A HREF="#format_flags"><FONT SIZE=2>format_flags</FONT></A><FONT SIZE=2>.</FONT></TD>
<TD WIDTH="8%" VALIGN="TOP">
<FONT SIZE=2><P>&nbsp;</FONT></TD>
</TR>
</TABLE>

<FONT SIZE=2><P>Example: the following </FONT><A HREF="demo/snippets/snip4.cpp"><FONT SIZE=2>example</FONT></A><FONT SIZE=2> takes C/C++ source code as input, and outputs syntax highlighted HTML code. </P>
</FONT><PRE>
<FONT COLOR="#008080">#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;iterator&gt;
#include &lt;boost/regex.hpp&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
</FONT>
<I><FONT COLOR="#000080">// purpose:
// takes the contents of a file and transform to
// syntax highlighted code in html format
</I></FONT>
boost::regex e1, e2;
<B>extern</B> <B>const</B> <B>char</B>* expression_text;
<B>extern</B> <B>const</B> <B>char</B>* format_string;
<B>extern</B> <B>const</B> <B>char</B>* pre_expression;
<B>extern</B> <B>const</B> <B>char</B>* pre_format;
<B>extern</B> <B>const</B> <B>char</B>* header_text;
<B>extern</B> <B>const</B> <B>char</B>* footer_text;

<B>void</B> load_file(std::string&amp; s, std::istream&amp; is)
{
   s.erase();
   s.reserve(is.rdbuf()-&gt;in_avail());
   <B>char</B> c;
   <B>while</B>(is.get(c))
   {
      <B>if</B>(s.capacity() == s.size())
         s.reserve(s.capacity() * <FONT COLOR="#000080">3</FONT>);
      s.append(<FONT COLOR="#000080">1</FONT>, c);
   }
}

<B>int</B> main(<B>int</B> argc, <B>const</B> <B>char</B>** argv)
{
   e1.set_expression(expression_text);
   e2.set_expression(pre_expression);
   <B>for</B>(<B>int</B> i = <FONT COLOR="#000080">1</FONT>; i &lt; argc; ++i)
   {
      std::cout &lt;&lt; <FONT COLOR="#0000ff">"Processing file "</FONT> &lt;&lt; argv[i] &lt;&lt; std::endl;
      std::ifstream fs(argv[i]);
      std::string in;
      load_file(in, fs);
      std::string out_name(std::string(argv[i]) + std::string(<FONT COLOR="#0000ff">".htm"</FONT>));
      std::ofstream os(out_name.c_str());
      os &lt;&lt; header_text;
      <I><FONT COLOR="#000080">// strip '&lt;' and '&gt;' first by outputting to a
</I></FONT>      <I><FONT COLOR="#000080">// temporary string stream
</I></FONT>      std::ostringstream t(std::ios::out | std::ios::binary);
      std::ostream_iterator&lt;<B>char</B>, <B>char</B>&gt; oi(t);
      boost::regex_merge(oi, in.begin(), in.end(), e2, pre_format);
      <I><FONT COLOR="#000080">// then output to final output stream
</I></FONT>      <I><FONT COLOR="#000080">// adding syntax highlighting:
</I></FONT>      std::string s(t.str());
      std::ostream_iterator&lt;<B>char</B>, <B>char</B>&gt; out(os);
      boost::regex_merge(out, s.begin(), s.end(), e1, format_string);
      os &lt;&lt; footer_text;
   }
   <B>return</B> <FONT COLOR="#000080">0</FONT>;
}

<B>extern</B> <B>const</B> <B>char</B>* pre_expression = <FONT COLOR="#0000ff">"(&lt;)|(&gt;)|\\r"</FONT>;
<B>extern</B> <B>const</B> <B>char</B>* pre_format = <FONT COLOR="#0000ff">"(?1&lt;)(?2&gt;)"</FONT>;


<B>const</B> <B>char</B>* expression_text = <I><FONT COLOR="#000080">// preprocessor directives: index 1
</I></FONT>                              <FONT COLOR="#0000ff">"(^[[:blank:]]*#(?:[^\\\\\\n]|\\\\[^\\n[:punct:][:word:]]*[\\n[:punct:][:word:]])*)|"
</FONT>                              <I><FONT COLOR="#000080">// comment: index 2
</I></FONT>                              <FONT COLOR="#0000ff">"(//[^\\n]*|/\\*.*?\\*/)|"
</FONT>                              <I><FONT COLOR="#000080">// literals: index 3
</I></FONT>                              <FONT COLOR="#0000ff">"\\&lt;([+-]?(?:(?:0x[[:xdigit:]]+)|(?:(?:[[:digit:]]*\\.)?[[:digit:]]+(?:[eE][+-]?[[:digit:]]+)?))u?(?:(?:int(?:8|16|32|64))|L)?)\\&gt;|"
</FONT>                              <I><FONT COLOR="#000080">// string literals: index 4
</I></FONT>                              <FONT COLOR="#0000ff">"('(?:[^\\\\']|\\\\.)*'|\"(?:[^\\\\\"]|\\\\.)*\")|"
</FONT>                              <I><FONT COLOR="#000080">// keywords: index 5
</I></FONT>                              <FONT COLOR="#0000ff">"\\&lt;(__asm|__cdecl|__declspec|__export|__far16|__fastcall|__fortran|__import"
</FONT>                              <FONT COLOR="#0000ff">"|__pascal|__rtti|__stdcall|_asm|_cdecl|__except|_export|_far16|_fastcall"
</FONT>                              <FONT COLOR="#0000ff">"|__finally|_fortran|_import|_pascal|_stdcall|__thread|__try|asm|auto|bool"
</FONT>                              <FONT COLOR="#0000ff">"|break|case|catch|cdecl|char|class|const|const_cast|continue|default|delete"
</FONT>                              <FONT COLOR="#0000ff">"|do|double|dynamic_cast|else|enum|explicit|extern|false|float|for|friend|goto"
</FONT>                              <FONT COLOR="#0000ff">"|if|inline|int|long|mutable|namespace|new|operator|pascal|private|protected"
</FONT>                              <FONT COLOR="#0000ff">"|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_cast"
</FONT>                              <FONT COLOR="#0000ff">"|struct|switch|template|this|throw|true|try|typedef|typeid|typename|union|unsigned"
</FONT>                              <FONT COLOR="#0000ff">"|using|virtual|void|volatile|wchar_t|while)\\&gt;"
</FONT>                              ;

<B>const</B> <B>char</B>* format_string = <FONT COLOR="#0000ff">"(?1&lt;font color=\"#008040\"&gt;$&amp;&lt;/font&gt;)"
</FONT>                            <FONT COLOR="#0000ff">"(?2&lt;I&gt;&lt;font color=\"#000080\"&gt;$&amp;&lt;/font&gt;&lt;/I&gt;)"
</FONT>                            <FONT COLOR="#0000ff">"(?3&lt;font color=\"#0000A0\"&gt;$&amp;&lt;/font&gt;)"
</FONT>                            <FONT COLOR="#0000ff">"(?4&lt;font color=\"#0000FF\"&gt;$&amp;&lt;/font&gt;)"
</FONT>                            <FONT COLOR="#0000ff">"(?5&lt;B&gt;$&amp;&lt;/B&gt;)"</FONT>;

<B>const</B> <B>char</B>* header_text = <FONT COLOR="#0000ff">"&lt;HTML&gt;\n&lt;HEAD&gt;\n"
</FONT>                          <FONT COLOR="#0000ff">"&lt;TITLE&gt;Auto-generated html formated source&lt;/TITLE&gt;\n"
</FONT>                          <FONT COLOR="#0000ff">"&lt;META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=windows-1252\"&gt;\n"
</FONT>                          <FONT COLOR="#0000ff">"&lt;/HEAD&gt;\n"
</FONT>                          <FONT COLOR="#0000ff">"&lt;BODY LINK=\"#0000ff\" VLINK=\"#800080\" BGCOLOR=\"#ffffff\"&gt;\n"
</FONT>                          <FONT COLOR="#0000ff">"&lt;P&gt; &lt;/P&gt;\n&lt;PRE&gt;"</FONT>;

<B>const</B> <B>char</B>* footer_text = <FONT COLOR="#0000ff">"&lt;/PRE&gt;\n&lt;/BODY&gt;\n\n"</FONT>;</PRE>
<P><HR></P>
<H3><A NAME="regex_split"></A>Algorithm regex_split</H3>
<FONT SIZE=2><P>#include &lt;</FONT><A HREF="../../boost/regex.hpp"><FONT SIZE=2>boost/regex.hpp</FONT></A><FONT SIZE=2>&gt; </P>
<P>Algorithm regex_split performs a similar operation to the perl split operation, and comes in three overloaded forms: </P>
</FONT><B><PRE>template</B> &lt;<B>class</B> OutputIterator, <B>class</B> charT, <B>class</B> Traits1, <B>class</B> Alloc1, <B>class</B> Traits2, <B>class</B> Alloc2&gt;
std::size_t regex_split(OutputIterator out,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::basic_string&lt;charT, Traits1, Alloc1&gt;&amp; s,&nbsp;
&nbsp;<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const</B> reg_expression&lt;charT, Traits2, Alloc2&gt;&amp; e,
&nbsp;<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned</B> flags,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::size_t max_split);

<B>template</B> &lt;<B>class</B> OutputIterator, <B>class</B> charT, <B>class</B> Traits1, <B>class</B> Alloc1, <B>class</B> Traits2, <B>class</B> Alloc2&gt;
std::size_t regex_split(OutputIterator out,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::basic_string&lt;charT, Traits1, Alloc1&gt;&amp; s,&nbsp;
&nbsp;<B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const</B> reg_expression&lt;charT, Traits2, Alloc2&gt;&amp; e,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <B>unsigned</B> flags = match_default);

<B>template</B> &lt;<B>class</B> OutputIterator, <B>class</B> charT, <B>class</B> Traits1, <B>class</B> Alloc1&gt;
std::size_t regex_split(OutputIterator out, 
                        std::basic_string&lt;charT, Traits1, Alloc1&gt;&amp; s);</PRE>
<FONT SIZE=2><P>Each version takes an output-iterator for output, and a string for input. If the expression contains no marked sub-expressions, then the algorithm writes one string onto the output-iterator for each section of input that does not match the expression. If the expression does contain marked sub-expressions, then each time a match is found, one string for each marked sub-expression will be written to the output-iterator. No more than <I>max_split </I>strings will be written to the output-iterator. Before returning, all the input processed will be deleted from the string <I>s</I> (if <I>max_split </I>is not reached then all of <I>s</I> will be deleted). Returns the number of strings written to the output-iterator. If the parameter <I>max_split</I> is not specified then it defaults to UINT_MAX. If no expression is specified, then it defaults to "\s+", and splitting occurs on whitespace. </P>
</FONT><P><A HREF="demo/snippets/snip8.cpp"><FONT SIZE=2>Example</FONT></A><FONT SIZE=2>: the following function will split the input string into a series of tokens, and remove each token from the string <I>s</I>: </P>
</FONT><B><PRE>unsigned</B> tokenise(std::list&lt;std::string&gt;&amp; l, std::string&amp; s)
{
<B>&nbsp;&nbsp; return</B> boost::regex_split(std::back_inserter(l), s);
}</PRE>
<P><A HREF="demo/snippets/snip9.cpp"><FONT SIZE=2>Example</FONT></A><FONT SIZE=2>: the following short program will extract all of the URL's from a html file, and print them out to <I>cout</I>: </P>
</FONT><FONT COLOR="#008000"><PRE>#include &lt;list&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;boost/regex.hpp&gt;
</FONT>
boost::regex e(<FONT COLOR="#000080">"&lt;\\s*A\\s+[^&gt;]*href\\s*=\\s*\"([^\"]*)\""</FONT>,
               boost::regbase::normal | boost::regbase::icase);

<B>void</B> load_file(std::string&amp; s, std::istream&amp; is)
{
   s.erase();
   <FONT COLOR="#000080">//
   // attempt to grow string buffer to match file size,
   // this doesn't always work...
</FONT>   s.reserve(is.rdbuf()-&amp;gtin_avail());
   <B>char</B> c;
   <B>while</B>(is.get(c))
   {
      <FONT COLOR="#000080">// use logarithmic growth stategy, in case
      // in_avail (above) returned zero:
</FONT>      <B>if</B>(s.capacity() == s.size())
         s.reserve(s.capacity() * 3);
      s.append(1, c);
   }
}


<B>int</B> main(<B>int</B> argc, <B>char</B>** argv)
{
   std::string s;
   std::list&lt;std::string&gt; l;

   <B>for</B>(<B>int</B> i = 1; i &lt; argc; ++i)
   {
      std::cout &lt;&lt; <FONT COLOR="#000080">"Findings URL's in "</FONT> &lt;&lt; argv[i] &lt;&lt; <FONT COLOR="#000080">":"</FONT> &lt;&lt; std::endl;
      s.erase();
      std::ifstream is(argv[i]);
      load_file(s, is);
      boost::regex_split(std::back_inserter(l), s, e);
      <B>while</B>(l.size())
      {
         s = *(l.begin());
         l.pop_front();
         std::cout &lt;&lt; s &lt;&lt; std::endl;
      }
   }
   <B>return</B> 0;
}</PRE>
<P><HR></P>
<H3><A NAME="partial_matches"></A>Partial Matches</H3>
<P>The match-flag <CODE>match_partial</CODE> can be passed to the following algorithms: <A HREF="#reg_match">regex_match</A>, <A HREF="#reg_search">regex_search</A>, and <A HREF="#reg_grep">regex_grep</A>.  When used it indicates that partial as well as full matches should be found.  A partial match is one that matched one or more characters at the end of the text input, but did not match all of the regular expression (although it may have done so had more input been available).  Partial matches are typically used when either validating data input (checking each character as it is entered on the keyboard), or when searching texts that are either too long to load into memory (or even into a memory mapped file), or are of indeterminate length (for example the source may be a socket or similar).  Partial and full matches can be differentiated as shown in the following table (the variable M represents an instance of match_results&lt;&gt; as filled in by regex_match, regex_search or regex_grep):<BR>
</P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=638>
<TR><TD WIDTH="20%" VALIGN="TOP">&nbsp;</TD>
<TD WIDTH="20%" VALIGN="TOP">
<P>Result</TD>
<TD WIDTH="20%" VALIGN="TOP">
<P>M[0].matched</TD>
<TD WIDTH="20%" VALIGN="TOP">
<P>M[0].first</TD>
<TD WIDTH="20%" VALIGN="TOP">
<P>M[0].second</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<P>No match</TD>
<TD WIDTH="20%" VALIGN="TOP">
<P>False</TD>
<TD WIDTH="20%" VALIGN="TOP">
<P>Undefined</TD>
<TD WIDTH="20%" VALIGN="TOP">
<P>Undefined</TD>
<TD WIDTH="20%" VALIGN="TOP">
<P>Undefined</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<P>Partial match</TD>
<TD WIDTH="20%" VALIGN="TOP">
<P>True</TD>
<TD WIDTH="20%" VALIGN="TOP">
<P>False</TD>
<TD WIDTH="20%" VALIGN="TOP">
<P>Start of partial match.</TD>
<TD WIDTH="20%" VALIGN="TOP">
<P>End of partial match (end of text).</TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<P>Full match</TD>
<TD WIDTH="20%" VALIGN="TOP">
<P>True</TD>
<TD WIDTH="20%" VALIGN="TOP">
<P>True</TD>
<TD WIDTH="20%" VALIGN="TOP">
<P>Start of full match.</TD>
<TD WIDTH="20%" VALIGN="TOP">
<P>End of full match.</TD>
</TR>
</TABLE>

<P>The following <A HREF="demo/snippets/partial_regex_match.cpp">example</A> tests to see whether the text could be a valid credit card number, as the user presses a key, the character entered would be added to the string being built up, and passed to <CODE>is_possible_card_number</CODE>.  If this returns true then the text could be a valid card number, so the user interface's OK button would be enabled.  If it returns false, then this is not yet a valid card number, but could be with more input, so the user interface would disable the OK button.  Finally, if the procedure throws an exception the input could never become a valid number, and the inputted character must be discarded, and a suitable error indication displayed to the user.</P>
<PRE>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;boost/regex.hpp&gt;

boost::regex e("(\\d{3,4})[- ]?(\\d{4})[- ]?(\\d{4})[- ]?(\\d{4})");

bool is_possible_card_number(const std::string&amp; input)
{
   //
   // return false for partial match, true for full match, or throw for
   // impossible match based on what we have so far...
   boost::match_results&lt;std::string::const_iterator&gt; what;
   if(0 == boost::regex_match(input, what, e, boost::match_default | boost::match_partial))
   {
      // the input so far could not possibly be valid so reject it:
      throw std::runtime_error("Invalid data entered - this could not possibly be a valid card number");
   }
   // OK so far so good, but have we finished?
   if(what[0].matched)
   {
      // excellent, we have a result:
      return true;
   }
   // what we have so far is only a partial match...
   return false;
}</PRE>
<P>In the following <A HREF="demo/snippets/partial_regex_match.cpp">example</A>, text input is taken from a stream containing an unknown amount of text; this example simply counts the number of html tags encountered in the stream.  The text is loaded into a buffer and searched a part at a time, if a partial match was encountered, then the partial match gets searched a second time as the start of the next batch of text:</P>
<PRE>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;boost/regex.hpp&gt;

// match some kind of html tag:
boost::regex e("&lt;[^&gt;]*&gt;");
// count how many:
unsigned int tags = 0;
// saved position of partial match:
char* next_pos = 0;

bool grep_callback(const boost::match_results&lt;char*&gt;&amp; m)
{
   if(m[0].matched == false)
   {
      // save position and return:
      next_pos = m[0].first;
   }
   else
      ++tags;
   return true;
}

void search(std::istream&amp; is)
{
   char buf[4096];
   next_pos = buf + sizeof(buf);
   bool have_more = true;
   while(have_more)
   {
      // how much do we copy forward from last try:
      unsigned leftover = (buf + sizeof(buf)) - next_pos;
      // and how much is left to fill:
      unsigned size = next_pos - buf;
      // copy forward whatever we have left:
      memcpy(buf, next_pos, leftover);
      // fill the rest from the stream:
      unsigned read = is.readsome(buf + leftover, size);
      // check to see if we've run out of text:
      have_more = read == size;
      // reset next_pos:
      next_pos = buf + sizeof(buf);
      // and then grep:
      boost::regex_grep(grep_callback,
                        buf,
                        buf + read + leftover,
                        e,
                        boost::match_default | boost::match_partial);
   }
}</PRE>
<FONT SIZE=2><P><HR ALIGN="LEFT"></P>
<I><P>Copyright </I></FONT><A HREF="mailto:John_Maddock@compuserve.com"><I><FONT SIZE=2>Dr John Maddock</I></FONT></A><I><FONT SIZE=2> 1998-2001 all rights reserved.</I> </P></FONT></BODY>
</HTML>
