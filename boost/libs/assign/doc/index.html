<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Boost.Assignment Documentation </title>
<link rel="stylesheet" href="style.css" type="text/css">
</head>

<body>

  <table border="0" >
    <tr>
      <td ><img src="cboost.gif" border="0" ></td>
      <td >
        <h1 align="center">Assignment Library</h1>
      </td>
    </tr>
  </table>

  <p>
  Copyright © 2003-2004 Thorsten Ottosen
  </p>
  <p>
  Use, modification and distribution is subject to the Boost Software License, Version 1.0
  (see <a href=http://www.boost.org/LICENSE_1_0.txt>
   http://www.boost.org/LICENSE_1_0.txt</a>).
  </p>
  <h3>Table of Contents</h3>
  <ul>
    <li><a href="#intro">Introduction</a>
    <li>     
        <p align="left" >
        <a href="#tutorial" >Tutorial</a>
        <ul>
            <li>Function <a href="#operator+="><code>operator+=()</code></a>
            <li>Function <a href="#operator()"><code>operator()()</code></a>
            <li>Function <a href="#list_of"><code>list_of()</code></a>    
            <li>Function <a href="#map_list_of"><code>map_list_of()</code></a> 
            <li>Functions <a href="#repeat"><code>repeat()</code> and <code>repeat_fun()</code> </a> 
            <li>A <a href="#complicated">"complicated"</a> example    
        </ul>
      <li>          
        <p align="left">
        <a href="#reference">Reference</a>
      <ul>
        <li><a href="#headers">Headers</a> </li>
        <li><a href="#std">Standard containers</a> </li>
        <li>Functions <a href="#list_of_ref"><code>list_of()</code> and <code>map_list_of()</code></a></li>
        <li>Functions <a href="#repeat_ref"><code>repeat()</code> and <code>repeat_fun()</code> </a>  
        <li>Class <a href="#list_inserter"><code>list_inserter</code></a></li>
        <li>Function <a href="#make_list_inserter"><code>make_list_inserter()</code></a></li>
        <li><a href="#limit"> Customizing</a> argument list sizes</li>   
     </ul>
    <li> <a href="#exceptions">Exceptions and exception-safety </a></li>
    <li> <a href="#extensions">Extending the library</a>            
    <li> <a href="#examples">Examples</a></li> <ul></ul>
    <li><a href="#portability">Portability</a></li>
    <li><a href="#history">History and Acknowledgment</a>    
    <li><a href="#ref">References</a></li>
  </ul>
  <hr>

 
  
<h2><a name="intro">Introduction</a></h2> <p> <i>There appear to be few 
practical uses of <code>operator,()</code></i>.  <!-- p.  247 --> <br><b>Bjarne 
Stroustrup</b>, The Design and Evolution of C++ </p> <p> The purpose of this 
library is to make it easy to fill containers with data by overloading 
<code>operator,()</code> and <code>operator()()</code>.  These two operators 
makes it possible to construct lists of values which are then copied into a 
container: </p> <ul> <li> A comma-separated list: <p> 
       <!--  vector< int > v; v += 1,2,3,4,5,6,7,8,9; -->
 
<pre><span 
class=identifier>vector</span><span class=special><</span><span 
class=keyword>int</span><span class=special>></span><span 
class=identifier>v</span><span class=special>; </span>
<span class=identifier>v </span><span class=special>+= </span><span 
class=number>1</span><span
class=special>,</span><span class=number>2</span><span 
class=special>,</span><span class=number>3</span><span 
class=special>,</span><span class=number>4</span><span 
class=special>,</span><span class=number>5</span><span 
class=special>,</span><span class=number>6</span><span 
class=special>,</span><span class=number>7</span><span 
class=special>,</span><span class=number>8</span><span 
class=special>,</span><span class=number>9</span><span class=special>;</span></pre></p>
       <li> A parenthesis-separated list: 
             <p>       
             <pre>
<span class=identifier>map</span><span class=special><</span><span 
class=identifier>string</span><span class=special>,</span><span class=keyword>int</span><span class=special>> </span><span class=identifier>m</span><span class=special>; </span>
<span class=identifier>insert</span><span class=special>( </span><span class=identifier>m </span><span class=special>)( </span><span class=string>&quot;Bar&quot;</span><span class=special>, </span><span class=number>1 </span><span class=special>)( </span><span class=string>&quot;Foo&quot;</span><span class=special>, </span><span class=number>2 </span><span class=special>);</span></pre> 
    </ul> 
<p>
    These lists are particularly useful in
    learning, testing, and prototyping situations, but can also be handy otherwise. 
      The library comes with predefined operators for the containers of the  
      standard library, but most functionality will work with any standard 
compliant container. The library also makes it possible to extend user
  defined types so for example a member function can be called for a list of 
values instead of its normal arguments. </p>
   <hr>
   <h2>Tutorial</h2>
   <p>
   Within two minutes you should be able to use this library. The main 
components are:
   <ul>
        <li>Function <a href="#operator+="><code>operator+=()</code></a>
        <li>Function <a href="#operator()"><code>operator()()</code></a>
        <li>Function <a href="#list_of"><code>list_of()</code></a>    
        <li>Function <a href="#map_list_of"><code>map_list_of()</code></a> 
            <li>Functions <a href="#repeat"><code>repeat()</code> and <code>repeat_fun()</code> </a> 
            <li>A <a href="#complicated">"complicated"</a> example    
            
   </ul>
   The two first functions are used for adding elements after a container object
   has been created whereas the next two is used when we need to initialize an 
   object. </p>
   <h3>Function <code>operator+=()</code><a name="operator+="></h3>
   <p>
    To fill a vector (or any standard container) with values using 
    <code>operator+=()</code> you write   
    <blockquote><pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>std</span><span class=special>/</span><span class=identifier>vector</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;; </span><span class=comment>// for 'operator+=()'
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;; 
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>; </span><span class=comment>// bring 'operator+=()' into scope
</span><span class=special>
</span><span class=special>{
    </span><span class=identifier>vector</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>values</span><span class=special>;  
    </span><span class=identifier>values </span><span class=special>+= </span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>,</span><span class=number>4</span><span class=special>,</span><span class=number>5</span><span class=special>,</span><span class=number>6</span><span class=special>,</span><span class=number>7</span><span class=special>,</span><span class=number>8</span><span class=special>,</span><span class=number>9</span><span class=special>; </span><span class=comment>// insert values at the end of the container
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>values</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>9 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>values</span><span class=special>[</span><span class=number>0</span><span class=special>] </span><span class=special>== </span><span class=number>1 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>values</span><span class=special>[</span><span class=number>9</span><span class=special>] </span><span class=special>== </span><span class=number>9 </span><span class=special>);
</span><span class=special>}</span></pre></blockquote>

    Here we only stuffed constants into the container, but the list can
    consists of arbitrary expressions as long as the result of each  
expression is convertible to the <code>value_type</code> of the container.
   </p> 
   <h3>Function <code>operator()()</code> <a name="operator()"></h3>
   <p>
   We do not call <code>operator()()</code> directly, but instead we call a 
   function that returns a proxy-object that defines <code>operator()()</code>.
   The function that returns the proxy object is always named after the member
   function that is used to copy the values in the list into the container.
   So to fill a map with pairs of values you write 
   <blockquote><pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>std</span><span class=special>/</span><span class=identifier>map</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; </span><span class=comment>// for 'insert()'
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; 
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>&gt;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>; </span><span class=comment>// bring 'insert()' into scope
</span><span class=special> 
</span><span class=special>{
    </span><span class=identifier>map</span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>months</span><span class=special>;  
    </span><span class=identifier>insert</span><span class=special>( </span><span class=identifier>months </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;january&quot;</span><span class=special>,   </span><span class=number>31 </span><span class=special>)( </span><span class=string>&quot;february&quot;</span><span class=special>, </span><span class=number>28 </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;march&quot;</span><span class=special>,     </span><span class=number>31 </span><span class=special>)( </span><span class=string>&quot;april&quot;</span><span class=special>,    </span><span class=number>30 </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;may&quot;</span><span class=special>,       </span><span class=number>31 </span><span class=special>)( </span><span class=string>&quot;june&quot;</span><span class=special>,     </span><span class=number>30 </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;july&quot;</span><span class=special>,      </span><span class=number>31 </span><span class=special>)( </span><span class=string>&quot;august&quot;</span><span class=special>,   </span><span class=number>31 </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;september&quot;</span><span class=special>, </span><span class=number>30 </span><span class=special>)( </span><span class=string>&quot;october&quot;</span><span class=special>,  </span><span class=number>31 </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;november&quot;</span><span class=special>,  </span><span class=number>30 </span><span class=special>)( </span><span class=string>&quot;december&quot;</span><span class=special>, </span><span class=number>31 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>m</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>12 </span><span class=special>);    
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>m</span><span class=special>[</span><span class=string>&quot;january&quot;</span><span class=special>] </span><span class=special>== </span><span class=number>31 </span><span class=special>);
</span><span class=special>}</span> </pre></blockquote>
   Note that <code>operator()()</code> is much more handy when
   we need to construct objects using several arguments
   (up to five arguments are supported by default, but the limit can be <a href="#limit">customized</a>).
    This is also true for sequences:
   <blockquote><pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>std</span><span class=special>/</span><span class=identifier>deque</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; </span><span class=comment>// for 'push_front()'
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; 
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>&gt;
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>utility</span><span class=special>&gt;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>; </span><span class=comment>// bring 'push_front()' into scope
</span><span class=special> 
</span><span class=special>{
    </span><span class=keyword>typedef </span><span class=identifier>pair</span><span class=special>&lt; </span><span class=identifier>string</span><span class=special>,</span><span class=identifier>string </span><span class=special>&gt; </span><span class=identifier>str_pair</span><span class=special>;
    </span><span class=identifier>deque</span><span class=special>&lt;</span><span class=identifier>str_pair</span><span class=special>&gt; </span><span class=identifier>deq</span><span class=special>;
    </span><span class=identifier>push_front</span><span class=special>( </span><span class=identifier>deq </span><span class=special>)( </span><span class=string>&quot;foo&quot;</span><span class=special>, </span><span class=string>&quot;bar&quot;</span><span class=special>)( </span><span class=string>&quot;boo&quot;</span><span class=special>, </span><span class=string>&quot;far&quot; </span><span class=special>); 
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>deq</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>2 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>deq</span><span class=special>.</span><span class=identifier>front</span><span class=special>().</span><span class=identifier>first </span><span class=special>== </span><span class=string>&quot;boo&quot; </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>deq</span><span class=special>.</span><span class=identifier>back</span><span class=special>().</span><span class=identifier>second </span><span class=special>== </span><span class=string>&quot;bar&quot; </span><span class=special>);
</span><span class=special>}   </span></pre></blockquote>

   Besides <code>push_front()</code> we could also have used
   <code>push_back()</code> if the container has a corresponding member
   function. Empty parentheses can be used to insert default-constructed 
objects, for example, 
<code>push_front( deq )()()</code> will insert two default-constructed 
<code>str_pair</code> objects. </p>   
   
   <p>
   If <code>operator()()</code> is too cumbersome to use with eg. 
<code>push_front()</code>we can also say </p>

<blockquote>
    <pre>
<span class=identifier>deque</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>di</span><span class=special>;    </span>
<span class=identifier>push_front</span><span class=special>( </span><span class=identifier>di </span><span class=special>) </span><span class=special>= </span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>,</span><span class=number>4</span><span class=special>,</span><span class=number>5</span><span class=special>,</span><span class=number>6</span><span class=special>,</span><span class=number>7</span><span class=special>,</span><span class=number>8</span><span class=special>,</span><span class=number>9</span><span class=special>;</span>
<span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>di</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>9 </span><span class=special>);    </span>
<span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>di</span><span class=special>[</span><span class=number>8</span><span class=special>] </span><span class=special>== </span><span class=number>9 </span><span class=special>);    </span>
</pre>
</blockquote>
<p>
Just to make it perfectly clear, the code above is not restricted to the 
standard containers, but will work with all <i>standard compliant</i> containers 
with the right member function. It is only <code>operator+=()</code> that has been restricted to 
the standard containers. </p>
  
  <h3>Function <code>list_of()</code> <a name="list_of"></h3>
  But what if we need to <i>initialize</i> a container? This is where 
  <code>list_of()</code> comes into play. With <code>list_of()</code>
  we can create anonymous lists that automatically converts to
  any container:
  <blockquote><pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; </span><span class=comment>// for 'list_of()'
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; 
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>list</span><span class=special>&gt;
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>stack</span><span class=special>&gt;
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>&gt;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>; </span><span class=comment>// bring 'list_of()' into scope
</span><span class=special> 
</span><span class=special>{
    </span><span class=keyword>const </span><span class=identifier>list</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>primes </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>)(</span><span class=number>5</span><span class=special>)(</span><span class=number>7</span><span class=special>)(</span><span class=number>11</span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>primes</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>6 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>primes</span><span class=special>.</span><span class=identifier>back</span><span class=special>() </span><span class=special>== </span><span class=number>11 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>primes</span><span class=special>.</span><span class=identifier>front</span><span class=special>() </span><span class=special>== </span><span class=number>1 </span><span class=special>);
   
    </span><span class=keyword>const </span><span 
class=identifier>stack</span><span class=special>&lt;</span><span 
class=identifier>string</span><span class=special>&gt; </span><span 
class=identifier>names </span><span class=special>= </span><span 
class=special></span><span class=identifier>list_of</span><span class=special>( </span><span class=string>&quot;Mr. Foo&quot; </span><span class=special>)( </span><span class=string>&quot;Mr. Bar&quot;</span><span class=special>)( </span><span class=string>&quot;Mrs. FooBar&quot; </span><span
class=special>).</span><span class=identifier>to_adapter();
    </span><span class=keyword>const </span><span 
class=identifier>stack</span><span class=special>&lt;</span><span 
class=identifier>string</span><span class=special>&gt; </span><span 
class=identifier>names2 </span><span class=special>= </span><span 
class=special>(</span><span class=identifier>list_of</span><span class=special>( </span><span class=string>&quot;Mr. Foo&quot; </span><span class=special>), </span><span class=string>&quot;Mr. Bar&quot;</span><span class=special>, </span><span class=string>&quot;Mrs. FooBar&quot; </span><span
class=special>).</span><span class=identifier>to_adapter();
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>names</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>3 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>names</span><span class=special>[</span><span class=number>0</span><span class=special>] </span><span class=special>== </span><span class=string>&quot;Mr. Foo&quot; </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>names</span><span class=special>[</span><span class=number>2</span><span class=special>] </span><span class=special>== </span><span class=string>&quot;Mrs. FooBar&quot; </span><span class=special>);
</span><span class=special>}   </span></pre></blockquote>
  If we need to initialize a container adapter, we need to help the compiler a 
little by calling <code>to_adapter()</code>. As the second example also shows, 
we can use a comma-separated
list with <code>list_of()</code> if we add parenthesis around the 
  entire right hand side. It is worth noticing that the first argument
  of <code>list_of()</code> determines the type of the anonymous list.
  In case of the stack, the anonymous list consists of
  <code>const char*</code> objects which are then converted to 
  a stack of <code>string</code> objects. The conversion is always  
  possible as long as the conversion between the stored types is possible.
 </p>
 <p>
 Please notice that <code>list_of()</code> can even convert to a 
 <code>boost::<a 
href="../../array/index.html">array</a>&lt;T,sz></code>.
 
 <h3>Function <code>map_list_of()</code> <a name="map_list_of"></h3>
 This function is defined for pure convenience when working with
 maps. Its usage is simple:
 <blockquote><pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; </span><span class=comment>// for 'map_list_of()'
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt; 
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>map</span><span class=special>&gt;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
</span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>; </span><span class=comment>// bring 'map_list_of()' into scope
</span><span class=special> 
</span><span class=special>{
    </span><span class=identifier>map</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>next </span><span class=special>= </span><span class=identifier>map_list_of</span><span class=special>(</span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>)(</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>)(</span><span class=number>3</span><span class=special>,</span><span class=number>4</span><span class=special>)(</span><span class=number>4</span><span class=special>,</span><span class=number>5</span><span class=special>)(</span><span class=number>5</span><span class=special>,</span><span class=number>6</span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>next</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>5 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>next</span><span class=special>[ </span><span class=number>1 </span><span class=special>] </span><span class=special>== </span><span class=number>2 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>next</span><span class=special>[ </span><span class=number>5 </span><span class=special>] </span><span class=special>== </span><span class=number>6 </span><span class=special>);
    
    </span><span class=comment>// or we can use 'list_of()' by specifying what type
    // the list consists of
    </span><span class=identifier>next </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>&lt; </span><span class=identifier>pair</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt; </span><span class=special>&gt;(</span><span class=number>6</span><span class=special>,</span><span class=number>7</span><span class=special>)(</span><span class=number>7</span><span class=special>,</span><span class=number>8</span><span class=special>)(</span><span class=number>8</span><span class=special>,</span><span class=number>9</span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>next</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>3 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>next</span><span class=special>[ </span><span class=number>6 </span><span class=special>] </span><span class=special>== </span><span class=number>7 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>next</span><span class=special>[ </span><span class=number>8 </span><span class=special>] </span><span class=special>== </span><span class=number>9 </span><span class=special>);      
</span><span class=special>}   </span></pre></blockquote>

<h3>Functions <code>repeat()</code> and <code>repeat_fun()</code> <a name="repeat"></h3> 
<p>
Sometimes it is too irritating to repeat the same value many times. This is 
where <code>repeat()</code> can be handy:
<blockquote>
    <pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>std</span><span class=special>/</span><span class=identifier>vector</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;
</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;</span>
<span class=special> </span>
<span class=special>{
    </span><span class=identifier>vector</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>v</span><span class=special>;
    </span><span class=identifier>v </span><span class=special>+= </span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>,</span><span class=identifier>repeat</span><span class=special>(</span><span class=number>10</span><span class=special>,</span><span class=number>4</span><span class=special>),</span><span class=number>5</span><span class=special>,</span><span class=number>6</span><span class=special>,</span><span class=number>7</span><span class=special>,</span><span class=number>8</span><span class=special>,</span><span class=number>9</span><span class=special>;
    </span><span class=comment>// v = [1,2,3,4,4,4,4,4,4,4,4,4,4,5,6,7,8,9]
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>3 </span><span class=special>+ </span><span class=number>10 </span><span class=special>+ </span><span class=number>5 </span><span class=special>);
    
    </span><span class=identifier>v </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>).</span><span class=identifier>repeat</span><span class=special>(</span><span class=number>5</span><span class=special>,</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>);
    </span><span class=comment>// v = [1,2,2,2,2,2,3]
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>1 </span><span class=special>+ </span><span class=number>5 </span><span class=special>+ </span><span class=number>3 </span><span class=special>);
    
    </span><span class=identifier>push_back</span><span class=special>( </span><span class=identifier>v </span><span class=special>)(</span><span class=number>1</span><span class=special>).</span><span class=identifier>repeat</span><span class=special>(</span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>);
    </span><span class=comment>// v = old v + [1,2,3]
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>12 </span><span class=special>);</span>
<span class=special>}</span></pre>
</blockquote>
As we can see, then the first argument to <code>repeat()</code> is the number
of times to repeat the second argument.
</p>
<p>
A more general list can be constructed with <code>repeat_fun()</code>:

<blockquote>
    <pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>std</span><span class=special>/</span><span class=identifier>vector</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>cstdlib</span><span class=special>&gt; </span><span class=comment>// for 'rand()'              
</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;</span>
<span class=special> </span>
<span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T </span><span class=special>&gt;</span>
<span class=keyword>struct </span><span class=identifier>next    </span>
<span class=special>{
    </span><span class=identifier>T </span><span class=identifier>seed</span><span class=special>;
    </span><span class=identifier>next</span><span class=special>( </span><span class=identifier>T </span><span class=identifier>seed </span><span class=special>) </span><span class=special>: </span><span class=identifier>seed</span><span class=special>(</span><span class=identifier>seed</span><span class=special>) 
    </span><span class=special>{ </span><span class=special>}
    
    </span><span class=identifier>T </span><span class=keyword>operator</span><span class=special>()() </span><span class=keyword>const
    </span><span class=special>{
        </span><span class=keyword>return </span><span class=identifier>seed</span><span class=special>++;
    </span><span class=special>}</span>
<span class=special>};</span>
<span class=special>     </span>
<span class=special>{
    </span><span class=identifier>vector</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>v</span><span class=special>;
    </span><span class=identifier>v </span><span class=special>+= </span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>,</span><span class=identifier>repeat_fun</span><span class=special>(</span><span class=number>4</span><span class=special>,&amp;</span><span class=identifier>rand</span><span class=special>),</span><span class=number>4</span><span class=special>;
    </span><span class=comment>// v = [1,2,?,?,?,?,4] 
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>7 </span><span class=special>);
    
    </span><span class=identifier>push_back</span><span class=special>( </span><span class=identifier>v </span><span class=special>).</span><span class=identifier>repeat_fun</span><span class=special>(</span><span class=number>4</span><span class=special>,</span><span class=identifier>next</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;(</span><span class=number>0</span><span class=special>))(</span><span class=number>4</span><span class=special>).</span><span class=identifier>repeat_fun</span><span class=special>(</span><span class=number>4</span><span class=special>,</span><span class=identifier>next</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;(</span><span class=number>5</span><span class=special>));
    </span><span class=comment>// v = old v + [0,1,2,3,4,5,6,7,8] 
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>v</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>16 </span><span class=special>);</span>
<span class=special>}</span>        </pre>
</blockquote>
The only requirement of the second argument to <code>repeat_fun()</code> is that 
it is a nullary function. </p>

<h3>A "complicated" example <a name="complicated"></h3>
<p> 
As a last example, let us assume that we need to keep track of the
result of soccer matches. A team will get one point if it wins 
and zero otherwise. If there has been played three games in each group, the code might look
like this:

<blockquote>
    <pre>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>list_of</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>/</span><span class=identifier>std</span><span class=special>/</span><span class=identifier>map</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assert</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>vector</span><span class=special>&gt;
</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;
 </span>
<span class=special>{
    </span><span class=keyword>typedef </span><span class=identifier>vector</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;                   </span><span class=identifier>score_type</span><span class=special>;
    </span><span class=keyword>typedef </span><span class=identifier>map</span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>,</span><span class=identifier>score_type</span><span class=special>&gt;        </span><span class=identifier>team_score_map</span><span class=special>;
    </span><span class=keyword>typedef </span><span class=identifier>pair</span><span class=special>&lt;</span><span class=identifier>string</span><span class=special>,</span><span class=identifier>score_type</span><span class=special>&gt;       </span><span class=identifier>score_pair</span><span class=special>;

    </span><span class=identifier>team_score_map </span><span class=identifier>group1</span><span class=special>, </span><span class=identifier>group2</span><span class=special>;
    
    </span><span class=comment>//
    // method 1: using 'insert()'
    //
    </span><span class=identifier>insert</span><span class=special>( </span><span class=identifier>group1 </span><span class=special>)( </span><span class=string>&quot;Denmark&quot;</span><span class=special>, </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>1</span><span class=special>) </span><span class=special>)
                    </span><span class=special>( </span><span class=string>&quot;Germany&quot;</span><span class=special>, </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>0</span><span class=special>)(</span><span class=number>0</span><span class=special>) </span><span class=special>)
                    </span><span class=special>( </span><span class=string>&quot;England&quot;</span><span class=special>, </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>0</span><span class=special>)(</span><span class=number>1</span><span class=special>) </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>group1</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>3 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>group1</span><span class=special>[ </span><span class=string>&quot;Denmark&quot; </span><span class=special>][</span><span class=number>1</span><span class=special>] </span><span class=special>== </span><span class=number>1 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>group1</span><span class=special>[ </span><span class=string>&quot;Germany&quot; </span><span class=special>][</span><span class=number>0</span><span class=special>] </span><span class=special>== </span><span class=number>0 </span><span class=special>);
    
    </span><span class=comment>//
    // method 2: using 'list_of()'
    //
    </span><span class=identifier>group2 </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>&lt; </span><span class=identifier>score_pair </span><span class=special>&gt;
                        </span><span class=special>( </span><span class=string>&quot;Norway&quot;</span><span class=special>,  </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>0</span><span class=special>) </span><span class=special>)
                        </span><span class=special>( </span><span class=string>&quot;USA&quot;</span><span class=special>,     </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>0</span><span class=special>)(</span><span class=number>0</span><span class=special>) </span><span class=special>)
                        </span><span class=special>( </span><span class=string>&quot;Andorra&quot;</span><span class=special>, </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>1</span><span class=special>) </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>group2</span><span class=special>.</span><span class=identifier>size</span><span class=special>() </span><span class=special>== </span><span class=number>3 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>group2</span><span class=special>[ </span><span class=string>&quot;Norway&quot; </span><span class=special>][</span><span class=number>0</span><span class=special>] </span><span class=special>== </span><span class=number>1 </span><span class=special>);
    </span><span class=identifier>BOOST_ASSERT</span><span class=special>( </span><span class=identifier>group2</span><span class=special>[ </span><span class=string>&quot;USA&quot; </span><span class=special>][</span><span class=number>0</span><span class=special>] </span><span class=special>== </span><span class=number>0 </span><span class=special>);</span>
<span class=special>}</span>
    </pre>
</blockquote>

In the first example, notice how the result of <code>list_of()</code>
can be converted automatically to a <code>vector&lt;int></code> because
<code>insert()</code> knows it expects a <code>vector&lt;int></code>.
In the second example we can see that <code>list_of()</code> is somewhat
less intelligent since here it needs to be told explicitly what arguments to
expect. (In the future it might be possible to introduce a more intelligent
conversion layer in <code>list_of()</code>.)
</p>
</p>
That is all; now you are ready to use this library.
 </p>

  <hr> 
  <h2><a name="reference">Reference</a></h2>
    <p>
  It is worth noticing the way the library is implemented.
  A free-standing function (eg. <code>push_back()</code>
  or <code>operator+=()</code>) returns a proxy
  object which is responsible for the insertion or the assignment. The proxy 
object does the insertion or assignment by overloading <code>operator,()</code>
  and <code>operator()()</code> and by calling the "insert" function from within 
  those operators. The "insert" function is typically stored in the proxy object 
  by using <code>boost::<a href="../../function/index.html">function</a></code>. </p>
  
  <p>
  Often overloading
  of <code>operator,()</code> is discouraged because it can lead to surprising
  results, but the approach taken in this library is safe since the
  user never deals with objects that have overloaded <code>operator,()</code>
  directly.
  </p>
  
    <p>
  Most of the code in this document use <code>int</code> in the examples, 
  but of course it works for arbitrary types as long as they are 
  Copy Constructible. The inserted data need not be constant data,
  but can be variables or data returned from functions; the only requirement 
  is that the type of the data is convertible to the type stored in the 
  container. 
  </p>
  
  <p>
  All forwarding is done by passing objects by value. Originally
  <code>const</code> references was used, but it lead to many problems
  with string-literals. One thing to remember is that references 
  can be passed by using <code>boost::<a href=../../utility/index.html>ref</a></code>.
  </p>
  
  <p>
   Everything is put in namespace 
  <code>boost::assign</code>. </p>

  <p> More details can be found below: </p>
      <ul>
          
        <li><a href="#headers">Headers</a> </li>
        <li><a href="#std">Standard containers</a> </li>
        <li>Functions <a href="#list_of_ref"><code>list_of()</code> and <code>map_list_of()</code></a></li>
        <li>Functions <a href="#repeat_ref"><code>repeat()</code> and <code>repeat_fun()</code></a></li>
        <li>Class <a href="#list_inserter"><code>list_inserter</code></a></li>
        <li>Function <a href="#make_list_inserter"><code>make_list_inserter()</code></a></li>
        <li><a href="#limit">Cutomizing</a> argument list sizes </li>
     </ul>
  <h3>Headers <a name="headers"></h3>      
  
  <table cellpadding=5 border=1 >
     <tr>
         <th>  Header                      </th>
         <th>        Includes              </th> 
     <tr>
         <td> &lt;boost/assign.hpp>               </td>
         <td>     everything  </td>
     <tr>
         <td> &lt;boost/assign/list_of.hpp>       </td>
         <td> <a href="#list_of"><code>list_of()</a>, <a 
href="#map_list_of">map_list_of()</code></a> </td> <tr>
         <td> &lt;boost/assign/std.hpp>       </td>
         <td> <a href="#operator+="><code>operator+=()</code></a> for all 
standard
containers (see below)</td> <tr> <td>  &lt;boost/assign/std/deque.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::deque</code>, <code>&lt;deque></code> 
    <tr> 
        <td>  &lt;boost/assign/std/list.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::list</code>, <code>&lt;list></code>  
    <tr> 
        <td>  &lt;boost/assign/std/map.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::map, std::multimap</code> , <code>&lt;map></code> 
    <tr> 
        <td>  &lt;boost/assign/std/queue.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::queue, std::priority_queue</code>, 
<code>&lt;queue></code> <tr> 
        <td>  &lt;boost/assign/std/set.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::set, std::multiset</code>, <code>&lt;set></code>  
    <tr> 
        <td>  &lt;boost/assign/std/slist.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::slist</code> if the class is available , 
<code>&lt;slist></code> <tr> 
        <td>  &lt;boost/assign/std/stack.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::stack</code>, <code>&lt;stack></code>  
    <tr> 
        <td>  &lt;boost/assign/std/vector.hpp> </td>
        <td>  <code>operator+=()</code> for 
              <code>std::vector</code>, <code>&lt;vector></code>  
    <tr> 
        <td>  &lt;boost/assign/assignment_exception.hpp> </td>
        <td>  Class <a 
href="#assignment_exception"><code>assignment_exception</code></a> which might 
be thrown by the proxy returned by <code>list_of()</code>
    <tr> 
        <td>  &lt;boost/assign/list_inserter.hpp> </td>
            <td>Functions <a
               href="#make_list_inserter"><code>make_list_inserter()</code></a>, <code>push_back()</code>,
                <code>push_front()</code>,<code>insert()</code>,
                <code>
                push()</code> and class <a href="#list_inserter"><code>list_inserter</code></a> 
                which is the back-bone of this entire library.

    </table>
  
  <h3>Standard containers <a name="std"> </h3>
   <p> In the following three dots (...) will mean
       implementation defined.  
       <code>operator+=()</code> returns a proxy that makes it 
       possible to call either
       <code>push_back()</code>,<code>insert()</code>, or <code>push()</code>. 
</p> <b>Synopsis</b>
  <p>
<blockquote>
<pre>
<span class=keyword>namespace </span><span class=identifier>boost</span>
<span class=special>{</span>
<span class=keyword>namespace </span><span class=identifier>assign</span>
<span class=special>{
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>deque</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>list</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>K</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>P </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>map</span><span class=special>&lt;</span><span class=identifier>K</span><span class=special>,</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>C</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>m</span><span class=special>, </span><span class=keyword>const </span><span class=identifier>P</span><span class=special>&amp; </span><span class=identifier>p </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>K</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>P </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>multimap</span><span class=special>&lt;</span><span class=identifier>K</span><span class=special>,</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>C</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>m</span><span class=special>, </span><span class=keyword>const </span><span class=identifier>P</span><span class=special>&amp; </span><span class=identifier>p </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>queue</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>C</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>priority_queue</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>C</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>K</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>K2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt; </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>set</span><span class=special>&lt;</span><span class=identifier>K</span><span class=special>,</span><span class=identifier>C</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>K2 </span><span class=identifier>k </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>K</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>K2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt; </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>multiset</span><span class=special>&lt;</span><span class=identifier>K</span><span class=special>,</span><span class=identifier>C</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>K2 </span><span class=identifier>k </span><span class=special>);
    
    </span><span class=preprocessor>#ifdef </span><span class=identifier>BOOST_HAS_SLIST
              
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>slist</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);
    
    </span><span class=preprocessor>#endif
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>C</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>stack</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>C</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt;    </span><span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>vector</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>);    </span>

<span class=special>} </span><span class=comment>// namespace 'assign'</span>
<span class=special>} </span><span class=comment>// namespace 'boost'</span>  </pre></blockquote>
    Note that the extra template argument <code>V2</code> etc. is 
    necessary to allow for types convertible to <code>V</code>.   
     
  <h3>Functions <code>list_of()</code> and 
      <code>map_list_of()</code> <a name="#list_of_ref"> </h3>
    <p>  
  These two functions are used to construct anonymous    
  list which can be converted to any standard container
  and <code>boost::<a href=../../array/index.html>array</a>&ltT,sz>.</code> 
The object returned by the two
  functions is guaranteed to have the interface described below. 
  </p>
  <b>Synopsis</b>
  <blockquote>  
  <pre><span class=keyword>namespace </span><span class=identifier>boost  </span>
<span class=special>{</span>
<span class=keyword>namespace </span><span class=identifier>assign</span>
<span class=special>{
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T </span><span class=special>&gt;
    </span><span class=keyword>class </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>
    </span><span class=special>{
    </span><span class=keyword>public</span><span class=special>:
        </span><span class=identifier>const_iterator  </span><span class=identifier>begin</span><span class=special>() <span class=keyword>const</span>;
        </span><span class=identifier>const_iterator  </span><span class=identifier>end</span><span class=special>() <span class=keyword>const</span>;
        
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>U </span><span class=special>&gt;
        </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>&amp; </span><span class=keyword>operator</span><span class=special>,( </span><span class=identifier>U </span><span class=identifier>u </span><span class=special>);
        
        </span><span class=comment>// inserts default-constructed object
        </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>&amp; </span><span class=keyword>operator</span><span class=special>()();  

        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>U </span><span class=special>&gt;
        </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>&amp; </span><span class=keyword>operator</span><span class=special>()( </span><span class=identifier>U </span><span class=identifier>u </span><span class=special>);
        
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>U</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U2 </span><span class=special>&gt;
        </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>&amp; </span><span class=keyword>operator</span><span class=special>()( </span><span class=identifier>U </span><span class=identifier>u</span><span class=special>, </span><span class=identifier>U2 </span><span class=identifier>u2 </span><span class=special>);

        </span><span class=comment>//
        // and similarly up to 5 arguments
        //
        
        //
        // Convert to a 'Container'. 'Container' must have have a constructor 
        // which takes two iterators.  
        //
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>Container </span><span class=special>&gt;
        </span><span class=keyword>operator </span><span class=identifier>Container</span><span class=special>() </span><span class=keyword>const</span><span class=special>; 

        </span><span class=comment>//
        // Convert to a container adapter like 'std::stack&lt;&gt;'.
        //
        </span><span class=identifier>Convertible</span><span class=special>-</span><span class=identifier>to</span><span class=special>-</span><span class=identifier>adapter</span> </span><span class=identifier>to_adapter</span><span class=special>() </span><span class=keyword>const</span><span class=special>;
        
        </span><span class=comment>//
        //
        // Convert to eg. 'boost::array&lt;T,std::size_t&gt;'. If the  
        // assigned variable is too small, 
        // a '&lt;a href=&quot;#assignment_exception&quot;&gt;assignment_exception&lt;/a&gt;' is thrown.
        // If the assigned variable it is too big, the rest of the 
        // values are  default-constructed.
        //
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>template </span><span class=special>&lt;</span><span class=keyword>class</span><span class=special>,</span><span class=identifier>std</span><span class=special>::</span><span class=identifier>size_t</span><span class=special>&gt; </span><span class=keyword>class </span><span class=identifier>Array</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U</span><span class=special>, </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>size_t </span><span class=identifier>sz </span><span class=special>&gt; 
        </span><span class=keyword>operator </span><span class=identifier>Array</span><span class=special>&lt;</span><span class=identifier>U</span><span class=special>,</span><span class=identifier>sz</span><span class=special>&gt;() </span><span class=keyword>const</span><span class=special>;
    </span><span class=special>};
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>list_of</span><span class=special>( </span><span class=identifier>T </span><span class=identifier>t </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U2 </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>list_of</span><span class=special>( </span><span class=identifier>U </span><span class=identifier>u</span><span class=special>, </span><span class=identifier>U2 </span><span class=identifier>u2 </span><span class=special>);
    
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U2</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U3 </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>list_of</span><span class=special>( </span><span class=identifier>U </span><span class=identifier>u</span><span class=special>, </span><span class=identifier>U2 </span><span class=identifier>u2</span><span class=special>, </span><span class=identifier>U3 </span><span class=identifier>u3 </span><span class=special>);

    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U2</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U3</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U4 </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>list_of</span><span class=special>( </span><span class=identifier>U </span><span class=identifier>u</span><span class=special>, </span><span class=identifier>U2 </span><span class=identifier>u2</span><span class=special>, </span><span class=identifier>U3 </span><span class=identifier>u3</span><span class=special>, </span><span class=identifier>U4 </span><span class=identifier>u4 </span><span class=special>);
  
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>T</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U2</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U3</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U4</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U5 </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>list_of</span><span class=special>( </span><span class=identifier>U </span><span class=identifier>u</span><span class=special>, </span><span class=identifier>U2 </span><span class=identifier>u2</span><span class=special>, </span><span class=identifier>U3 </span><span class=identifier>u3</span><span class=special>, </span><span class=identifier>U4 </span><span class=identifier>u4</span><span class=special>, </span><span class=identifier>U5 </span><span class=identifier>u5 </span><span class=special>);

    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>Key</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>T </span><span class=special>&gt;
    </span><span class=identifier>Implementation</span><span class=special>-</span><span class=identifier>defined</span>   </span><span class=identifier>map_list_of</span><span class=special>( </span><span class=identifier>Key </span><span class=identifier>k</span><span class=special>, </span><span class=identifier>T </span><span class=identifier>t </span><span class=special>)
    </span><span class=special>{
        </span><span class=keyword>return </span><span class=identifier>list_of</span><span class=special>&lt; </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>pair</span><span class=special>&lt;</span><span class=identifier>Key</span><span class=special>,</span><span class=identifier>T</span><span class=special>&gt; </span><span class=special>&gt;()( </span><span class=identifier>k</span><span class=special>, </span><span class=identifier>t </span><span class=special>);
    </span><span class=special>}</span>
<span class=special>} </span><span class=comment>// namespace 'assign'</span>
<span class=special>} </span><span class=comment>// namespace 'boost'</span>  </pre></blockquote>

  <h3>Functions <code>repeat()</code> and 
     <code>repeat_fun()</code> <a name="#repeat_ref"> </h3>
  <p>
      These two function exist both as free-standing functions and as member functions of the object returned by 
      <code>list_of()</code> and of <code>list_inserter</code>. The free-standing versions are used to create a
      hook for <code>operator,()</code> so we can call the functions in the middle of a comma-list. The member functions
      are used when we need to call the functions in the middle of a parenthesis-list. In both cases we have that
      <ul>
          <li> the return type is always implementation defined for both functions, 
          <li> the argument list of <code>repeat()</code> is <code>(std::size_t,T)</code>, and  
          <li> the argument list of <code>repeat_fun()</code> is <code>(std::size_t,Nullary_function)</code>    
      </ul>
      
  </p>
      
  <h3><a name="list_inserter">Class <code>list_inserter</code></a></h3> 
  
  This class is responsible for inserting elements into containers and 
  it is the key to extending the library to support your favourite class.

    <p>
  <b>Synopsis</b> 
  </p>
  <blockquote><pre>
<span class=keyword>namespace </span><span class=identifier>boost</span>
<span class=special>{</span>
<span class=keyword>namespace </span><span class=identifier>assign</span>
<span class=special>{
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=identifier>Function</span><span class=special>, </span><span class=identifier>Argument </span><span class=special>= </span><span class=keyword>void </span><span class=special>&gt; 
    </span><span class=keyword>class </span><span class=identifier>list_inserter
    </span><span class=special>{
        </span><span class=identifier>Function </span><span class=identifier>fun</span><span class=special>;
        
    </span><span class=keyword>public</span><span class=special>:
        </span><span class=keyword>explicit </span><span class=identifier>list_inserter</span><span class=special>( </span><span class=identifier>Function </span><span class=identifier>fun </span><span class=special>);
        
        </span><span class=comment>// conversion constructor
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>Function2</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>Arg </span><span class=special>&gt;
        </span><span class=identifier>list_inserter</span><span class=special>( </span><span class=keyword>const </span><span class=identifier>list_inserter</span><span class=special>&lt;</span><span class=identifier>Function2</span><span class=special>,</span><span class=identifier>Arg</span><span class=special>&gt;&amp; </span><span class=special>);
        
    </span><span class=keyword>public</span><span class=special>:
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>U </span><span class=special>&gt;
        </span><span class=identifier>list_inserter</span><span class=special>&amp; </span><span class=keyword>operator</span><span class=special>,( </span><span class=identifier>U </span><span class=identifier>u </span><span class=special>);
        
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>U </span><span class=special>&gt;
        </span><span class=identifier>list_inserter</span><span class=special>&amp; </span><span class=keyword>operator</span><span class=special>=( </span><span class=identifier>U </span><span class=identifier>u </span><span class=special>);
        
        </span><span class=comment>// calls 'fun()' with default-constructed object
        </span><span class=identifier>list_inserter</span><span class=special>&amp; </span><span class=keyword>operator</span><span class=special>()();
        
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>U </span><span class=special>&gt;
        </span><span class=identifier>list_inserter</span><span class=special>&amp; </span><span class=keyword>operator</span><span class=special>()( </span><span class=identifier>U </span><span class=identifier>u </span><span class=special>);
        
        </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>U</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>U2 </span><span class=special>&gt;
        </span><span class=identifier>list_inserter</span><span class=special>&amp; </span><span class=keyword>operator</span><span class=special>()( </span><span class=identifier>U </span><span class=identifier>u</span><span class=special>, </span><span class=identifier>U2 </span><span class=identifier>u2 </span><span class=special>)
        </span><span class=special>{
           </span><span class=comment>//
           // if 'Argument' is 'void'
           //     fun( u, u2 );
           // else
           //     fun( Argument( u, u2 ) );
           //
           </span><span class=keyword>return </span><span class=special>*</span><span class=keyword>this</span><span class=special>;
        </span><span class=special>}

        </span><span class=comment>//
        // similarly up to 5 arguments
        //
    </span><span class=special>};</span>
    
    <span class=keyword>template</span><span class=special>&lt; </span><span 
class=keyword>class </span><span class=identifier>C </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt; </span><span class=identifier>push_back</span><span class=special>( </span><span class=identifier>C</span><span class=special>&amp; </span><span class=special>);
      
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>C </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt; </span><span class=identifier>push_front</span><span class=special>( </span><span class=identifier>C</span><span class=special>&amp; </span><span class=special>);

    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>C </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt; </span><span class=identifier>insert</span><span class=special>( </span><span class=identifier>C</span><span class=special>&amp; </span><span class=special>);

    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>C </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=special>... </span><span class=special>&gt; </span><span class=identifier>push</span><span class=special>( </span><span class=identifier>C</span><span class=special>&amp; </span><span class=special>);</span>
      
<span class=special>} </span><span class=comment>// namespace 'assign'</span>
<span class=special>} </span><span class=comment>// namespace 'boost'</span></pre></blockquote>
  <p>
  Notice how the arguments to <code>operator,()</code> and 
  <code>operator()()</code> are passed differently to 
  <code>fun</code> depending of the type of <code>Argument</code>. 
  So if we only pass one template argument to <code>list_inserter,</code>
  we can forward "arbitrary" argument lists of functions. If we pass
  two template arguments to <code>list_inserter</code> we can 
  construct types with "arbitrary" constructors.
  </p> 
   
  <p> 
   And because
  a reference to <code>list_inserter</code> is returned, we can
  chain argument list together in a very space-efficient manner.
  </p>

  <h3><a name="make_list_inserter">Function <code>make_list_inserter()</code></a></h3>
  <p>
  A simple "constructor" function for <code>list_inserter</code>. A typical 
  use of this function is to call it with the result of 
<code>boost::bind()</code>
  which in general returns some unreadable and weird class template.
  </p>
  <b>Synopsis</b>
  <blockquote><pre>
<span class=keyword>namespace </span><span class=identifier>boost </span>
<span class=special>{</span>
<span class=keyword>namespace </span><span class=identifier>assign</span>
<span class=special>{  
    </span><span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>Function </span><span class=special>&gt;
    </span><span class=identifier>list_inserter</span><span class=special>&lt;</span><span class=identifier>Function</span><span class=special>&gt;  </span><span class=identifier>make_list_inserter</span><span class=special>( </span><span class=identifier>Function </span><span class=identifier>fun </span><span class=special>)
    </span><span class=special>{
        </span><span class=keyword>return </span><span class=identifier>list_inserter</span><span class=special>&lt;</span><span class=identifier>Function</span><span class=special>&gt;( </span><span class=identifier>fun </span><span class=special>);
    </span><span class=special>} </span>
<span class=special>}</span>
<span class=special>}  </span>  </pre></blockquote>

   <a name="limit"></a>   
   <h3>Customizing argument list sizes</h3>   
      <p>
    This library uses the boost Preprocessor Library to implement overloaded 
    versions of <code>operator()()</code> and <code>list_of()</code>. By default you 
    can call these functions with five arguments, but you can also customize this 
    number by defining a macros before including a header from this library:
       <blockquote>
       <pre>
<span class=preprocessor>#define </span><span class=identifier>BOOST_ASSIGN_MAX_PARAMS </span><span class=number>10
</span><span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>assign</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
</pre>
       </blockquote>      
       </p>
  <hr>    
  <h2><a name="exceptions">Exceptions and exception-safety</a></h2>
  <p>
  The exception guarantees by the library is the same as guarantee as the 
  guarantee of the function that is forwarded to. For standard 
  containers this means that the
  strong guarantee is given for a single insertions and that the basic guarantee 
  is given for many insertions (provided that the object being copied 
  gives the basic guarantee). 
  </p>
  <p>
  The functions may throw standard exceptions
  like <code>std::bad_alloc</code>. Note however that, unfortunately, the standard does not guarantee allocation-failures
  in standard containers to be reported by <code>std::bad_alloc</code> or exceptions derived from <code>std::exception</code>.
 </p>
  
  <h3><a name="assignment_exception">Class 
  <code>assignment_exception</code></a></h3>
  <p>
   The exception is thrown by the conversion operator in the proxy object
   returned from <code>list_of()</code>.
  </p>

  <blockquote><pre>
<span class=keyword>namespace </span><span class=identifier>boost </span>
<span class=special>{</span>
<span class=keyword>namespace </span><span class=identifier>assign</span>
<span class=special>{
    </span><span class=keyword>class </span><span class=identifier>assignment_exception </span><span class=special>: </span><span class=keyword>public </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>exception
    </span><span class=special>{
    </span><span class=keyword>public</span><span class=special>:
        </span><span class=keyword>explicit </span><span class=identifier>assignment_exception</span><span class=special>( </span><span class=keyword>const </span><span class=keyword>char</span><span class=special>* </span><span class=identifier>what </span><span class=special>); 
        </span><span class=keyword>virtual </span><span class=keyword>const </span><span class=keyword>char</span><span class=special>* </span><span class=identifier>what</span><span class=special>() </span><span class=keyword>const </span><span class=keyword>throw</span><span class=special>();
    </span><span class=special>};</span>
<span class=special>}   </span>
<span class=special>}</span>  </pre></blockquote> 

  <hr>
  <h2><a name="extensions">Extending the library</a></h2> 
  <p>
  It is very simple to make the library work with new classes. 
  This code shows how to use <code>operator+=()</code> with 
  a container:
  <blockquote><pre>
<span class=keyword>template</span><span class=special>&lt; </span><span class=keyword>class </span><span class=identifier>V</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>A</span><span class=special>, </span><span class=keyword>class </span><span class=identifier>V2 </span><span class=special>&gt;</span>
<span class=keyword>inline </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=identifier>function</span><span class=special>&lt; </span><span class=keyword>void </span><span class=special>(</span><span class=identifier>V</span><span class=special>) </span><span class=special>&gt;, </span><span class=identifier>V </span><span class=special>&gt; </span>
<span class=keyword>operator</span><span class=special>+=( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>vector</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;&amp; </span><span class=identifier>c</span><span class=special>, </span><span class=identifier>V2 </span><span class=identifier>v </span><span class=special>)</span>
<span class=special>{
    </span><span class=keyword>return </span><span 
class=identifier>make_list_inserter</span><span class=special>( </span><span 
class=identifier>boost::bind</span><span class=special>( </span><span 
class=special>&amp;</span><span class=identifier>std</span><span class=special>::</span><span class=identifier>vector</span><span class=special>&lt;</span><span class=identifier>V</span><span class=special>,</span><span class=identifier>A</span><span class=special>&gt;::</span><span class=identifier>push_back</span><span class=special>, </span><span class=special>&amp;</span><span class=identifier>c</span><span class=special>, </span><span class=identifier>_1 </span><span class=special>) </span><span class=special>)( </span><span class=identifier>v </span><span class=special>);</span>
<span class=special>}</span>  </pre></blockquote>
  Notice that we use <code>boost::function</code> to avoid troubles with
  specifying the return-type of <code>bind()</code>. Also note that we pass
  a second template argument to <code>list_inserter</code> so argument 
  lists will be used to construct a <code>V</code> object. Otherwise we
  could end up trying to call <code>push_back()</code> with <i>n</i> arguments 
  instead of one.
  </p>
  
  <p>
  On the other hand, calling a function with more that one argument can be
  very useful too. This small example shows how we take advantage of this 
  functionality:
  </p>
  <blockquote><pre>
<span class=comment>//  
// A class representing emails
//</span>
<span class=keyword>class </span><span class=identifier>email</span>
<span class=special>{</span>
<span class=keyword>public</span><span class=special>:
    </span><span class=keyword>enum </span><span class=identifier>address_option
    </span><span class=special>{
        </span><span class=identifier>check_addr_book</span><span class=special>,
        </span><span class=identifier>dont_check_addr_book
    </span><span class=special>};
    </span>
<span class=keyword>private</span><span class=special>:

    </span><span class=comment>//
    // Store list of persons that must be cc'ed
    //
    </span><span class=keyword>mutable </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>map</span><span class=special>&lt; </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>string</span><span class=special>,</span><span class=identifier>address_option </span><span class=special>&gt; </span><span class=identifier>cc_list</span><span class=special>;
        
    </span><span class=comment>//
    // This extra function is necessary since we cannot 
    // use the same function for both returning the 'list_inserter'
    // and doing the work. This one does the work. 
    //
    </span><span class=keyword>void </span><span class=identifier>add_cc_impl</span><span class=special>( </span><span class=keyword>const </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>string</span><span class=special>&amp; </span><span class=identifier>name</span><span class=special>, </span><span class=identifier>address_option </span><span class=identifier>ao </span><span class=special>)
    </span><span class=special>{
        </span><span class=identifier>cc_list</span><span class=special>[ </span><span class=identifier>name </span><span class=special>] </span><span class=special>= </span><span class=identifier>ao</span><span class=special>;
    </span><span class=special>}
</span>
<span class=keyword>public</span><span class=special>:
    
    </span><span class=comment>//
    // This function constructs the appropriate 'list_inserter'.
    // Again we use 'boost::function' because it is easy,
    // though it is not required. 
    //
    </span><span class=identifier>list_inserter</span><span class=special>&lt; </span><span class=identifier>function</span><span class=special>&lt; </span><span class=keyword>void </span><span class=special>( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>string</span><span class=special>, </span><span class=identifier>address_option </span><span class=special>) </span><span class=special>&gt; </span><span class=special>&gt;
    </span><span class=identifier>add_cc</span><span class=special>( </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>string </span><span class=identifier>name</span><span class=special>, </span><span class=identifier>address_option </span><span class=identifier>ao </span><span class=special>)
    </span><span class=special>{
        </span><span class=comment>//
        // Remember to insert first pair.
        //
        </span><span class=identifier>add_cc_impl</span><span class=special>( </span><span class=identifier>name</span><span class=special>, </span><span class=identifier>ao </span><span class=special>);
        
        </span><span class=comment>//
        // Then construct 'list_inserter'.
        // Notice how the conversion constructor in 'list_inserter'
        // allows for conversion as long as the two stored function
        // objects can be assigned. Everything can be assigned to
        // to 'boost::function'.
        //
        </span><span class=keyword>return </span><span class=identifier>make_list_inserter</span><span class=special>( </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>bind</span><span class=special>( </span><span class=special>&amp;</span><span class=identifier>email</span><span class=special>::</span><span class=identifier>add_cc_impl</span><span class=special>, </span><span class=keyword>this</span><span class=special>, </span><span class=identifier>_1</span><span class=special>, </span><span class=identifier>_2 </span><span class=special>) </span><span class=special>);
    </span><span class=special>}</span>
<span class=special>};
</span>
<span class=comment>//
// Now we can use the class like this:
//</span>
<span class=identifier>email </span><span class=identifier>e</span><span class=special>;</span>
<span class=identifier>e</span><span class=special>.</span><span class=identifier>add_cc</span><span class=special>( </span><span class=string>&quot;Mr. Foo&quot;</span><span class=special>, </span><span class=identifier>email</span><span class=special>::</span><span class=identifier>dont_check_addr_book </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;Mr. Bar&quot;</span><span class=special>, </span><span class=identifier>email</span><span class=special>::</span><span class=identifier>check_addr_book </span><span class=special>)
        </span><span class=special>( </span><span class=string>&quot;Mrs. FooBar&quot;</span><span class=special>, </span><span class=identifier>email</span><span class=special>::</span><span class=identifier>check_addr_book </span><span class=special>);</span>  </pre></blockquote>
  The full example can be seen in <a href="../test/email_example.cpp">email_example.cpp</a>      
      </p>
  <hr>
  <h2>Examples <a name="examples"></h2>
  <p>
  Additional examples can be found in the test files:
  <ul>
      <li> <a href="../test/array.cpp">array.cpp</a>      
      <li> <a href="../test/list_of.cpp">list_of.cpp</a>      
      <li> <a href="../test/std.cpp">std.cpp</a>      
      <li> <a href="../test/list_inserter.cpp">list_inserter.cpp</a>      
      <li> <a href="../test/list_of_workaround.cpp">list_of_work_around.cpp</a>      
      <li> <a href="../test/email_example.cpp">email_example.cpp</a>          
      <li> <a href="../test/my_vector_example.cpp">my_vector_example.cpp</a>               
  </ul>
  </p>
  <hr>
  <h2><a name="portability">Portability</a></h2>
  <p>
    Library has been successfully compiled and tested with
    MVC++ 7.1, GCC 3.2 (under Cygwin) Comeau 4.3.3
  </p>
  <p>
    There are known limitation on platforms not supporting templated 
    conversion operators. The solution is to call certain member functions on 
    the object returned by <code>list_of()</code>: </p>
 <blockquote>
     <pre>
<span class=special>{
    </span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
    </span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>;
    </span><span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>assign</span><span class=special>;
    
    </span><span class=keyword></span><span 
class=identifier>vector</span><span
class=special>&lt;</span><span class=keyword>int</span><span 
class=special>&gt;</span>         <span class=identifier>v </span><span 
class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>)(</span><span class=number>4</span><span class=special>).</span><span class=identifier>to_container</span><span class=special>( </span><span class=identifier>v </span><span class=special>);
    </span><span class=identifier>set</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;            </span><span class=identifier>s </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>)(</span><span class=number>4</span><span class=special>).</span><span class=identifier>to_container</span><span class=special>( </span><span class=identifier>s </span><span class=special>);  
    </span><span class=identifier>map</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt;        </span><span class=identifier>m </span><span class=special>= </span><span class=identifier>map_list_of</span><span class=special>(</span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>)(</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>).</span><span class=identifier>to_container</span><span class=special>( </span><span class=identifier>m </span><span class=special>);
    </span><span class=identifier>stack</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;         </span><span class=identifier>st </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>)(</span><span class=number>4</span><span class=special>).</span><span class=identifier>to_adapter</span><span class=special>( </span><span class=identifier>st </span><span class=special>);
    </span><span class=identifier>queue</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>&gt;          </span><span class=identifier>q </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>)(</span><span class=number>4</span><span class=special>).</span><span class=identifier>to_adapter</span><span class=special>( </span><span class=identifier>q </span><span class=special>); 
    </span><span class=identifier>array</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=number>4</span><span class=special>&gt;        </span><span class=identifier>a </span><span class=special>= </span><span class=identifier>list_of</span><span class=special>(</span><span class=number>1</span><span class=special>)(</span><span class=number>2</span><span class=special>)(</span><span class=number>3</span><span class=special>)(</span><span class=number>4</span><span class=special>).</span><span class=identifier>to_array</span><span class=special>( </span><span class=identifier>a </span><span class=special>);</span>
<span class=special>}</span>     </pre>
 </blockquote>
 <p>
 Notice how one must supply the functions with an argument so the right
 return type can be deduced.
 </p>
 <p>Some standard libraries are also broken. One problem is that 
<code>insert()</code> might not work:
<blockquote>
    <pre>
<span class=identifier>map</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>next</span><span class=special>; 
</span><span class=identifier>insert</span><span class=special>( </span><span class=identifier>next </span><span class=special>)(</span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>)(</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>); </span><span class=comment>// compile-time error</span> </pre>
</blockquote>
The solution is to use <code>map_list_of()</code> instead:
<blockquote>
    <pre>
<span class=identifier>map</span><span class=special>&lt;</span><span class=keyword>int</span><span class=special>,</span><span class=keyword>int</span><span class=special>&gt; </span><span class=identifier>next </span><span class=special>= </span><span class=identifier>map_list_of</span><span class=special>(</span><span class=number>1</span><span class=special>,</span><span class=number>2</span><span class=special>)(</span><span class=number>2</span><span class=special>,</span><span class=number>3</span><span class=special>);</span></pre></blockquote>
</p>
 <hr>
  <h2><a name="history">History and Acknowledgment</a></h2>
  <p>
  The idea for an assignment/initialization library is not new. The 
  functionality of this
  library resembles Leor Zolman's STL Container Initialization Library a great 
  deal, but it does not rely on string parsing to achieve its goals. 
  </p> 
  <p>
  The  
  library is non-intrusive and puts only a minimum of requirements 
  on its supported classes.
 Overloading operator comma is sometimes viewed as a bad practice <a 
href=#meyers>[1]</A>. However, it has been done
  with success in eg. the Generative Matrix Computation Library  and Blitz to initialize matrices 
      (see <a href=#gmcl>[2]</A>) and <a href=#blitz>[3]</A>). The 
Initialization Library overloads
      the comma operator in a safe manner by letting free standing functions
 return an object that is responsible for the initialization. Therefore it takes 
explicit
      action from the programmer to begin using the overloaded <code>operator,()</CODE>.
  </p>
  <p>
  There has recently been some discussion about enhancing the language to 
support better initialization (see <a href="#initializer">[4]</a>).
  </p>
  <p>
  Special thanks goes to 
  <ul>
  <li> Leor Zolman for our many discussion that eventually led to this library.
  <li> Tom Brinkman for being review manager.
  <li> Pavel Vozenilek for his countless suggestions, improvements and 
       portability fixes. </ul>
  </p>
  <hr>
  <h2><a name="ref">References</a></h2>
  <p>
  <ol>
      <li> <a name="meyers">     Scott. Meyers, "More Effective C++", Item 7, Addison Wesley, 1996       
      <li> <a name="gmcl">       K. Czarnecki and U.W. Eisenecker, "Generative programming", Addison-Wesley, 2000        
      <li> <a name="blitz">      <a href=http://www.oonumerics.org/blitz/> http://www.oonumerics.org/blitz/ </A>     
      <li> <a name="initializer"> 
          Gabriel Dos Reis and Bjarne Stroustrup, 
          <a href=http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1509.pdf> "Generalized Initializer
            Lists"</a>, 2003  </a>
 </OL> 
 </p>
  <hr>
  <p>
    (C) Copyright Thorsten Ottosen 2003-2004
  </p>

  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
</body>
</html>
