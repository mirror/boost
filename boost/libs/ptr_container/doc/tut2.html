<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.2: http://docutils.sourceforge.net/" />
<title></title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<pre>
<span class=comment>//
// This example is intended to show you how to
// use the 'view_clone_manager'. The idea
// is that we have a container of non-polymorphic
// objects and want to keep then sorted by different
// criteria at the same time. 
//

//
// We'll go for 'ptr_vector' here. Using a node-based 
// container would be a waste of space here.
// All container headers will also include
// the Clone Managers.
// </span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>ptr_container</span><span class=special>/</span><span class=identifier>ptr_vector</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>boost</span><span class=special>/</span><span class=identifier>ptr_container</span><span class=special>/</span><span class=identifier>indirect_fun</span><span class=special>.</span><span class=identifier>hpp</span><span class=special>&gt;
</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>functional</span><span class=special>&gt; </span><span class=comment>// For 'binary_fnuction'</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>cstdlib</span><span class=special>&gt;    </span><span class=comment>// For 'rand()'</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>algorithm</span><span class=special>&gt;  </span><span class=comment>// For 'std::sort()'</span>
<span class=preprocessor>#include </span><span class=special>&lt;</span><span class=identifier>iostream</span><span class=special>&gt;   </span><span class=comment>// For 'std::cout'
</span>
<span class=keyword>using </span><span class=keyword>namespace </span><span class=identifier>std</span><span class=special>;
</span>
<span class=comment>//
// This is our simple example data-structure. It can
// be ordered in three ways.
//</span>
<span class=keyword>struct </span><span class=identifier>photon</span>
<span class=special>{
    </span><span class=identifier>photon</span><span class=special>() </span><span class=special>: </span><span class=identifier>color</span><span class=special>( </span><span class=identifier>rand</span><span class=special>() </span><span class=special>), 
               </span><span class=identifier>direction</span><span class=special>( </span><span class=identifier>rand</span><span class=special>() </span><span class=special>),
               </span><span class=identifier>power</span><span class=special>( </span><span class=identifier>rand</span><span class=special>() </span><span class=special>)
    </span><span class=special>{ </span><span class=special>}
    
    </span><span class=keyword>int </span><span class=identifier>color</span><span class=special>;
    </span><span class=keyword>int </span><span class=identifier>direction</span><span class=special>;
    </span><span class=keyword>int </span><span class=identifier>power</span><span class=special>;</span>
<span class=special>};
</span>
<span class=comment>//
// Our big container is a standard vector
//</span>
<span class=keyword>typedef </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>vector</span><span class=special>&lt;</span><span class=identifier>photon</span><span class=special>&gt;                                 </span><span class=identifier>vector_type</span><span class=special>;
</span>
<span class=comment>//
// Now we define our view type by adding a second template argument.
// The 'view_clone_manager' will implements Cloning by taking address
// of objects.
//
// Notice the first template argument is 'photon' and not
// 'const photon' to allow the view container write access.
//</span>
<span class=keyword>typedef </span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>ptr_vector</span><span class=special>&lt;</span><span class=identifier>photon</span><span class=special>,</span><span class=identifier>boost</span><span class=special>::</span><span class=identifier>view_clone_allocator</span><span class=special>&gt; </span><span class=identifier>view_type</span><span class=special>;
</span>
<span class=comment>//
// Our first sort criterium
//</span>
<span class=keyword>struct </span><span class=identifier>sort_by_color </span><span class=special>: </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>binary_function</span><span class=special>&lt;</span><span class=identifier>photon</span><span class=special>,</span><span class=identifier>photon</span><span class=special>,</span><span class=keyword>bool</span><span class=special>&gt;</span>
<span class=special>{
    </span><span class=keyword>bool </span><span class=keyword>operator</span><span class=special>()( </span><span class=keyword>const </span><span class=identifier>photon</span><span class=special>&amp; </span><span class=identifier>l</span><span class=special>, </span><span class=keyword>const </span><span class=identifier>photon</span><span class=special>&amp; </span><span class=identifier>r </span><span class=special>) </span><span class=keyword>const
    </span><span class=special>{
        </span><span class=keyword>return </span><span class=identifier>l</span><span class=special>.</span><span class=identifier>color </span><span class=special>&lt; </span><span class=identifier>r</span><span class=special>.</span><span class=identifier>color</span><span class=special>;
    </span><span class=special>}</span>
<span class=special>};
</span>
<span class=comment>//
// Our second sort criterium
//</span>
<span class=keyword>struct </span><span class=identifier>sort_by_direction </span><span class=special>: </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>binary_function</span><span class=special>&lt;</span><span class=identifier>photon</span><span class=special>,</span><span class=identifier>photon</span><span class=special>,</span><span class=keyword>bool</span><span class=special>&gt;</span>
<span class=special>{
    </span><span class=keyword>bool </span><span class=keyword>operator</span><span class=special>()( </span><span class=keyword>const </span><span class=identifier>photon</span><span class=special>&amp; </span><span class=identifier>l</span><span class=special>, </span><span class=keyword>const </span><span class=identifier>photon</span><span class=special>&amp; </span><span class=identifier>r </span><span class=special>) </span><span class=keyword>const
    </span><span class=special>{
        </span><span class=keyword>return </span><span class=identifier>l</span><span class=special>.</span><span class=identifier>direction </span><span class=special>&lt; </span><span class=identifier>r</span><span class=special>.</span><span class=identifier>direction</span><span class=special>;
    </span><span class=special>}</span>
<span class=special>};

</span>
<span class=comment>//
// Our third sort criterium
//</span>
<span class=keyword>struct </span><span class=identifier>sort_by_power </span><span class=special>: </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>binary_function</span><span class=special>&lt;</span><span class=identifier>photon</span><span class=special>,</span><span class=identifier>photon</span><span class=special>,</span><span class=keyword>bool</span><span class=special>&gt;</span>
<span class=special>{
    </span><span class=keyword>bool </span><span class=keyword>operator</span><span class=special>()( </span><span class=keyword>const </span><span class=identifier>photon</span><span class=special>&amp; </span><span class=identifier>l</span><span class=special>, </span><span class=keyword>const </span><span class=identifier>photon</span><span class=special>&amp; </span><span class=identifier>r </span><span class=special>) </span><span class=keyword>const
    </span><span class=special>{
        </span><span class=keyword>return </span><span class=identifier>l</span><span class=special>.</span><span class=identifier>power </span><span class=special>&lt; </span><span class=identifier>r</span><span class=special>.</span><span class=identifier>power</span><span class=special>;
    </span><span class=special>}</span>
<span class=special>};
</span>
<span class=comment>//
// This function inserts &quot;Clones&quot; into the
// the view. 
//
// We need to pass the first argument
// as a non-const reference to be able to store
// 'T*' instead of 'const T*' objects. Alternatively,
// we might change the declaration of the 'view_type'
// to 
//     typedef boost::ptr_vector&lt;const photon,boost::view_clone_manager&gt; 
//               view_type;     ^^^^^^
//</span>
<span class=keyword>void </span><span class=identifier>insert</span><span class=special>( </span><span class=identifier>vector_type</span><span class=special>&amp; </span><span class=identifier>from</span><span class=special>, </span><span class=identifier>view_type</span><span class=special>&amp; </span><span class=identifier>to </span><span class=special>)</span>
<span class=special>{
        </span><span class=identifier>to</span><span class=special>.</span><span class=identifier>insert</span><span class=special>( </span><span class=identifier>to</span><span class=special>.</span><span class=identifier>end</span><span class=special>(), 
                   </span><span class=identifier>from</span><span class=special>.</span><span class=identifier>begin</span><span class=special>(),
                   </span><span class=identifier>from</span><span class=special>.</span><span class=identifier>end</span><span class=special>() </span><span class=special>);</span>
<span class=special>}
</span>
<span class=keyword>int </span><span class=identifier>main</span><span class=special>()</span>
<span class=special>{
    </span><span class=keyword>enum </span><span class=special>{ </span><span class=identifier>sz </span><span class=special>= </span><span class=number>10</span><span class=special>, </span><span class=identifier>count </span><span class=special>= </span><span class=number>500 </span><span class=special>};

    </span><span class=comment>//
    // First we create the main container and two views
    //
    </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>vector</span><span class=special>&lt;</span><span class=identifier>vector_type</span><span class=special>&gt;  </span><span class=identifier>photons</span><span class=special>;
    </span><span class=identifier>view_type                 </span><span class=identifier>color_view</span><span class=special>;
    </span><span class=identifier>view_type                 </span><span class=identifier>direction_view</span><span class=special>;

    </span><span class=comment>//
    // Then we fill the main container with some random data
    //
    </span><span class=keyword>for</span><span class=special>( </span><span class=keyword>int </span><span class=identifier>i </span><span class=special>= </span><span class=number>0</span><span class=special>; </span><span class=identifier>i </span><span class=special>!= </span><span class=identifier>sz</span><span class=special>; </span><span class=special>++</span><span class=identifier>i </span><span class=special>)
    </span><span class=special>{
        </span><span class=identifier>photons</span><span class=special>.</span><span class=identifier>push_back</span><span class=special>( </span><span class=identifier>vector_type</span><span class=special>() </span><span class=special>); 

        </span><span class=keyword>for</span><span class=special>( </span><span class=keyword>int </span><span class=identifier>j </span><span class=special>= </span><span class=number>0</span><span class=special>; </span><span class=identifier>j </span><span class=special>!= </span><span class=identifier>count</span><span class=special>; </span><span class=special>++</span><span class=identifier>j </span><span class=special>)
            </span><span class=identifier>photons</span><span class=special>[</span><span class=identifier>i</span><span class=special>].</span><span class=identifier>push_back</span><span class=special>( </span><span class=identifier>photon</span><span class=special>() </span><span class=special>);
    </span><span class=special>}

    </span><span class=comment>//
    // Then we create the two views.
    //
    </span><span class=keyword>for</span><span class=special>( </span><span class=keyword>int </span><span class=identifier>i </span><span class=special>= </span><span class=number>0</span><span class=special>; </span><span class=identifier>i </span><span class=special>!= </span><span class=identifier>sz</span><span class=special>; </span><span class=special>++</span><span class=identifier>i </span><span class=special>)
    </span><span class=special>{
        </span><span class=identifier>insert</span><span class=special>( </span><span class=identifier>photons</span><span class=special>[</span><span class=identifier>i</span><span class=special>], </span><span class=identifier>color_view </span><span class=special>);
        </span><span class=identifier>insert</span><span class=special>( </span><span class=identifier>photons</span><span class=special>[</span><span class=identifier>i</span><span class=special>], </span><span class=identifier>direction_view </span><span class=special>);
    </span><span class=special>}

    </span><span class=comment>//
    // First we sort the original photons, using one of
    // the view classes. This may sound trivial, but consider that
    // the objects are scatered all around 'sz' different vectors;
    // the view makes them act as one big vector.
    //
    </span><span class=identifier>std</span><span class=special>::</span><span class=identifier>sort</span><span class=special>( </span><span class=identifier>color_view</span><span class=special>.</span><span class=identifier>begin</span><span class=special>(), </span><span class=identifier>color_view</span><span class=special>.</span><span class=identifier>end</span><span class=special>(), </span><span class=identifier>sort_by_power</span><span class=special>() </span><span class=special>);
    
    </span><span class=comment>//
    // And now we can sort the views themselves. Notice how
    // we switch to different iterators and different predicates:
    //
    </span><span class=identifier>color_view</span><span class=special>.</span><span class=identifier>sort</span><span class=special>( </span><span class=identifier>sort_by_color</span><span class=special>() </span><span class=special>);

    </span><span class=identifier>direction_view</span><span class=special>.</span><span class=identifier>sort</span><span class=special>( </span><span class=identifier>sort_by_direction</span><span class=special>() </span><span class=special>);

    </span><span class=keyword>return </span><span class=number>0</span><span class=special>;</span>
<span class=special>}</span>
</pre>
</body>
</html>

