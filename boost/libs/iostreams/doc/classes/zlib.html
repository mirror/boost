<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
    <TITLE>Zlib Filters</TITLE>
    <LINK REL="stylesheet" HREF="../../../../boost.css">
    <LINK REL="stylesheet" HREF="../theme/iostreams.css">
</HEAD>
<BODY>

<!-- Begin Banner -->

    <H1 CLASS="title">Zlib Filters</H1>
    <HR CLASS="banner">

<!-- End Banner -->
<DL class="page-index">
  <DT><A href="#overview">Overview</A></DT>
  <DT><A href="#acknowledgments">Acknowledgments</A></DT>
  <DT><A href="#headers">Headers</A></DT>
  <DT><A href="#synopsis">Synopsis</A></DT>
  <DT><A HREF="#reference">Reference</A>
    <DL class="page-index">
      <DT><A HREF="#constants">namespace <CODE>boost::iostreams::zlib</CODE></A></DT>
      <DT><A HREF="#zlib_params">Class <CODE>zlib_params</CODE></A></DT>
      <DT><A HREF="#basic_zlib_compressor">Class template <CODE>zlib_compressor</CODE></A></DT>
      <DT><A HREF="#basic_zlib_decompressor">Class template <CODE>zlib_decompressor</CODE></A></DT>
      <DT><A HREF="#zlib_error">Class <CODE>zlib_error</CODE></A></DT>
    </DL>
  </DT>
  <DT><A href="#examples">Examples</A></DT>
  <DT><A href="#installation">Installation</A></DT>
</DL>

<A NAME="overview">
<H2>Overview</H2>

<P>
    The class templates <A HREF="#basic_zlib_compressor"><CODE>basic_zlib_compressor</CODE></A> and <A HREF="#basic_zlib_decompressor"><CODE>basic_zlib_decompressor</CODE></A> perform compression and decompression in the Z<SPAN STYLE="font-size:80%">LIB</SPAN> format (<A CLASS="bib_ref" HREF="../bibliography.html#deutsch1">[Deutsch1]</A>) using Jean-loup Gailly's and Mark Adler's zlib compression library (<A CLASS="bib_ref" HREF="../bibliography.html#gailly">[Gailly]</A>). 
</P>
<P>
    The zlib Filters are <A HREF="../concepts/dual_use_filter.html">DualUseFilters</A> so that they may be used for either input or output. Most commonly, however, the compression Filters will be used for output and the decompression Filters for input.
</P>

<A NAME="acknowledgments">
<H2>Acknowledgments</H2>

<P>
    The zlib Filters were influences by the work of Jeff Garland (<A CLASS="bib_ref" HREF="../bibliography.html#garland">[Garland]</A>) and Jonathan de Halleux (<A CLASS="bib_ref" HREF="../bibliography.html#de_halleux">[de Halleux]</A>).
</P>

Thanks to <A HREF="mailto:jloup@gailly.net">Jean-loup Gailly</A> and <A HREF="mailto:&#109;&#097;&#100;&#108;&#101;&#114;&#064;&#097;&#108;&#117;&#109;&#110;&#105;&#046;&#099;&#097;&#108;&#116;&#101;&#099;&#104;&#046;&#101;&#100;&#117;">Mark Adler</A> for making their excellent library available to the public with a <A HREF="http://www.boost.org/more/lib_guide.htm#Requirements">Boost-compatible</A> license.

<A NAME="headers">
<H2>Headers</H2>

<DL>
  <DT><A CLASS="header" HREF="../../../../boost/iostreams/filter/zlib.hpp"><CODE>&lt;boost/iostreams/filter/zlib.hpp&gt;</CODE></A></DT>
</DL>

<A NAME="synopsis">
<H2>Synopsis</H2>

<PRE CLASS="broken_ie"><SPAN CLASS="keyword">namespace</SPAN> boost { <SPAN CLASS="keyword">namespace</SPAN> iostreams {

<SPAN CLASS="keyword">namespace</SPAN> <A CLASS="documented" HREF="#constants">zlib</A> {
                    
    <SPAN CLASS="comment">// Compression levels</SPAN>

<SPAN CLASS="keyword">extern</SPAN> <SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#no_compression">no_compression</A>;
<SPAN CLASS="keyword">extern</SPAN> <SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#best_speed">best_speed</A>;
<SPAN CLASS="keyword">extern</SPAN> <SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#best_compression">best_compression</A>;
<SPAN CLASS="keyword">extern</SPAN> <SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#default_compression">default_compression</A>;

    <SPAN CLASS="comment">// Compression methods</SPAN>

<SPAN CLASS="keyword">extern</SPAN> <SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#deflated">deflated</A>;

    <SPAN CLASS="comment">// Compression strategies</SPAN>

<SPAN CLASS="keyword">extern</SPAN> <SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#default_strategy">default_strategy</A>;
<SPAN CLASS="keyword">extern</SPAN> <SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#filtered">filtered</A>;
<SPAN CLASS="keyword">extern</SPAN> <SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#huffman_only">huffman_only</A>;

    <SPAN CLASS="comment">// Status codes</SPAN>

<SPAN CLASS="keyword">extern</SPAN> <SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#stream_error">stream_error</A>;
<SPAN CLASS="keyword">extern</SPAN> <SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#version_error">version_error</A>;
<SPAN CLASS="keyword">extern</SPAN> <SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#data_error">data_error</A>;
<SPAN CLASS="keyword">extern</SPAN> <SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#buf_error">buf_error</A>;

}   <SPAN CLASS="comment">// End namespace boost::iostreams::zlib</SPAN>

<SPAN CLASS="keyword">struct</SPAN> <A CLASS="documented" HREF="#zlib_params">zlib_params</A>;

<SPAN CLASS="keyword">template</SPAN><<SPAN CLASS="keyword">typename</SPAN> Alloc = std::allocator<<SPAN CLASS="keyword">char</SPAN>> >
<SPAN CLASS="keyword">struc</SPAN>t <A CLASS="documented" HREF="#basic_zlib_compressor">basic_zlib_compressor</A>;

<SPAN CLASS="keyword">template</SPAN><<SPAN CLASS="keyword">typename</SPAN> Alloc = std::allocator<<SPAN CLASS="keyword">char</SPAN>> >
<SPAN CLASS="keyword">struct</SPAN> <A CLASS="documented" HREF="#basic_zlib_decompressor">basic_zlib_decompressor</A>;

<SPAN CLASS="keyword">typedef</SPAN> basic_zlib_compressor<>   <SPAN CLASS="defined">zlib_compressor</SPAN>;
<SPAN CLASS="keyword">typedef</SPAN> basic_zlib_decompressor<> <SPAN CLASS="defined">zlib_decompressor</SPAN>;

<SPAN CLASS="keyword">class</SPAN> <A CLASS="documented" HREF="#zlib_error">zlib_error</A>;

} } <SPAN CLASS="comment">// End namespace boost::io</SPAN></PRE>

<A NAME="reference">
<H2>Reference</H2>

<A NAME="constants">
<H3>Namespace <CODE>boost::iostreams::zlib</CODE></H3>

<P>The namespace <CODE>boost::iostreams::zlib</CODE> contains integral constants used to configure zlib Filters and to report errors. The constants have the following interpretations. (<I>See</I> <A CLASS="bib_ref" HREF="../bibliography.html#gailly">[Gailly]</A> for additional details.)</P>

<TABLE STYLE="margin-left:2em" BORDER=1 CELLPADDING=4>
<TR><TH>Constant</TH><TH>Interpretation</TH></TR>
    <TR>
        <TD VALIGN="top"><A NAME="no_compression"></A><CODE>no_compression</CODE></TD>
        <TD>Compression-level constant specifying that no compression should be performed. Equal to <CODE>Z_NO_COMPRESSION</CODE>.</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="best_speed"></A><CODE>best_speed</CODE></TD>
        <TD>Compression-level constant requesting the fasted compression. Equal to <CODE>Z_BEST_SPEED</CODE>.</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="best_compression"></A><CODE>best_compression.</CODE></TD>
        <TD>Compression-level constant requesting the best compression ratio. Equal to <CODE>Z_BEST_COMPRESSION</CODE>.</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="default_compression"></A><CODE>default_compression</CODE></TD>
        <TD>Default compression level. Equal to <CODE>Z_DEFAULT_COMPRESSION</CODE>.</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="deflated"></A><CODE>deflated</CODE></TD>
        <TD>Compression method constant; currently the only supported method. Equal to <CODE>Z_DEFLATED</CODE>.</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="default_strategy"></A><CODE>default_strategy</CODE></TD>
        <TD>Compression strategy constant. Equal to <CODE>Z_DEFAULT_STRATEGY</CODE>.</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="filtered"></A><CODE>filtered</CODE></TD>
        <TD>Compression strategy constant. Equal to <CODE>Z_FILTERED</CODE>.</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="huffman_only"></A><CODE>huffman_only</CODE></TD>
        <TD>Compression strategy constant. Equal to <CODE>Z_HUFFMAN_ONLY</CODE>.</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="stream_error"></A><CODE>stream_error</CODE></TD>
        <TD>Error code used to indicate that one of the members of <CODE>zlib_params</CODE> is invalid; may also indicate an internal Iostreams Library error. Equal to <CODE>Z_STREAM_ERROR</CODE>.</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="version_error"></A><CODE>version_error</CODE></TD>
        <TD>
            Error code used to indicate that data was compressed with an incompatible version of zlib. Equal to <CODE>Z_VERSION_ERROR</CODE>.
        </TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="data_error"></A><CODE>data_error</CODE></TD>
        <TD>
            Error code used to indicate that a compressed datastream is corrupted. Equal to <CODE>Z_DATA_ERROR.</CODE>
        </TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="buf_error"></A><CODE>buf_error</CODE></TD>
        <TD>Error code indicating an internal Iostreams Library error. Equal to <CODE>Z_BUF_ERROR.</CODE></TD>
    </TR>
</TABLE>

<A NAME="zlib_params">
<H3>Class <CODE>zlib_params</CODE></H3>

<H4>Description</H4>

<P>Encapsulates the parameters used to configure <A HREF="#basic_zlib_compressor"><CODE>basic_zlib_compressor</CODE></A> and <A HREF="#basic_zlib_decompressor"><CODE>basic_zlib_decompressor</CODE></A>.</P>

<H4>Synopsis</H4>

<PRE CLASS="broken_ie"><SPAN CLASS="keyword">struct</SPAN> <SPAN CLASS="defined">zlib_params</SPAN> {

    <SPAN CLASS="comment">// Non-explicit constructor</SPAN>
    <A CLASS="documented" HREF="#zlib_params_constructors">zlib_params</A>( <SPAN CLASS="keyword">int</SPAN> level           = zlib::default_compression,
                 <SPAN CLASS="keyword">int</SPAN> method          = zlib::deflated,
                 <SPAN CLASS="keyword">int</SPAN> window_bits     = default value, 
                 <SPAN CLASS="keyword">int</SPAN> mem_level       = default value, 
                 <SPAN CLASS="keyword">int</SPAN> strategy        = zlib::default_strategy,
                 <SPAN CLASS="keyword">bool</SPAN> noheader       = false );
    <SPAN CLASS="keyword">int</SPAN>  level;
    <SPAN CLASS="keyword">int</SPAN>  method;
    <SPAN CLASS="keyword">int</SPAN>  window_bits;
    <SPAN CLASS="keyword">int</SPAN>  mem_level;
    <SPAN CLASS="keyword">int</SPAN>  strategy;
    <SPAN CLASS="keyword">bool</SPAN> noheader;
};</PRE>

<A NAME="zlib_params_constructors">
<H4><CODE>zlib_params::zlib_params</CODE></H4>

<PRE CLASS="broken_ie">    zlib_params( <SPAN CLASS="keyword">int</SPAN> level           = zlib::default_compression,
                 <SPAN CLASS="keyword">int</SPAN> method          = zlib::deflated,
                 <SPAN CLASS="keyword">int</SPAN> window_bits     = default value, 
                 <SPAN CLASS="keyword">int</SPAN> mem_level       = default value, 
                 <SPAN CLASS="keyword">int</SPAN> strategy        = zlib::default_strategy,
                 <SPAN CLASS="keyword">bool</SPAN> noheader       = false );</PRE>

<P>Constructs a <CODE>zlib_params</CODE> object, where the parameters have the following interpretations:</AP>

<TABLE STYLE="margin-left:2em" BORDER=0 CELLPADDING=2>
<TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>level</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>Compression level. Must be equal to <CODE>zlib::default_compression</CODE> or a value in the range <CODE>0-9</CODE>. The value <CODE>0</CODE> yields no compression, while <CODE>9</CODE> yields the best compression ratio. Affects compression only.</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="method"></A><I>method</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>Compression method. Must equal <A HREF="#deflated"><CODE>zlib::deflated</CODE></A>. Affects compression only.</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="window_bits"></A><I>window_bits</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>The base two logarithm of the window size. Must be in the range 8-15; defaults to 15.</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="mem_level"></A><I>mem_level</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>Specifies the amount of memory to be used. Must be in the range 1-9; defaults to 8. Affects compression only.</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="strategy"></A><I>strategy</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>Must be <A HREF="#default_strategy"><CODE>zlib::default_strategy</CODE></A>, <A HREF="#filtered"><CODE>zlib::filtered</CODE></A> or <A HREF="#huffman_only"><CODE>zlib::huffman_only</CODE></A>. Affects compression only. </TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="noheader"></A><I>noheader</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>True if the Z<SPAN STYLE="font-size:80%">LIB</SPAN> header and trailing A<SPAN STYLE="font-size:80%">DLER</SPAN>-32 checksum should be omitted (see <A CLASS="bib_ref" HREF="../bibliography.html#deutsch1">[Deutsch1]</A>). This results in compression according to the <I>deflate</I> specification (see <A CLASS="bib_ref" HREF="../bibliography.html#deutsch2">[Deutsch2]</A>).</TD>
    </TR>
</TABLE>

<P>See <A CLASS="bib_ref" HREF="../bibliography.html#gailly">[Gailly]</A> for additional details.</P>

<A NAME="basic_zlib_compressor">
<H3>Class template <CODE>basic_zlib_compressor</CODE></H3>

<H4>Description</H4>

Model of <A HREF="../concepts/dual_use_filter.html">DualUseFilter</A> which performs compression using zlib (<A CLASS="bib_ref" HREF="../bibliography.html#gailly">[Gailly]</A>).

<H4>Synopsis</H4>

<PRE CLASS="broken_ie"><SPAN CLASS="keyword">template</SPAN>&lt;<SPAN CLASS="keyword">typename</SPAN> <A CLASS="documented" HREF="#basic_zlib_compressor_params">Alloc</A> = std::allocator&lt;<SPAN CLASS="keyword">char</SPAN>&gt; &gt;
<SPAN CLASS="keyword">struct</SPAN> <A CLASS="documented" HREF="#basic_zlib_compressor_params">basic_zlib_compressor</A> {
    <SPAN CLASS="keyword">typedef</SPAN> <SPAN CLASS="keyword">char</SPAN>                    char_type;
    <SPAN CLASS="keyword">typedef</SPAN> <SPAN CLASS="omitted">implementation-defined</SPAN>  io_category;

    <A CLASS="documented" HREF="#basic_zlib_compressor_constructors">basic_zlib_compressor</A>( <SPAN CLASS="keyword">const</SPAN> <A CLASS="documented" HREF="#zlib_params">zlib_params</A>& = <SPAN CLASS="omitted">zlib::default_compression</SPAN>, 
                           std::streamsize buffer_size = <SPAN CLASS="omitted">default value</SPAN> );

    <SPAN CLASS="comment">// DualUseFilter members.</SPAN>
};

<SPAN CLASS="keyword">typedef</SPAN> <A CLASS="documented" HREF="#basic_zlib_compressor">basic_zlib_compressor</A><> <SPAN CLASS="defined">zlib_compressor</SPAN>;</PRE>

<A NAME="basic_zlib_compressor_params"></A>
<H4>Template Parameters</H4>

<TABLE STYLE="margin-left:2em" BORDER=0 CELLPADDING=2>
<TR>
    <TR>
        <TD VALIGN="top"><I>Alloc</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>A C++ standard library allocator type (<A CLASS="bib_ref" HREF="../bibliography.html#iso">[ISO]</A>, 20.1.5), used to allocate a character buffer and to configure zlib.</TD>
    </TR>
</TABLE>

<A NAME="basic_zlib_compressor_constructors"></A>
<H4><CODE>basic_zlib_compressor::basic_zlib_compressor</CODE></H4>

<PRE CLASS="broken_ie">    <B>basic_zlib_compressor</B>( <SPAN CLASS="keyword">const</SPAN> <A CLASS="documented" HREF="#zlib_params">zlib_params</A>& = <SPAN CLASS="omitted">zlib::default_compression</SPAN>, 
                           std::streamsize buffer_size = <SPAN CLASS="omitted">default value</SPAN> );</PRE>

<P>Constructs an instance of <CODE>basic_zlib_compressor</CODE> with the given parameters and buffer size. Since a <A CLASS="documented" HREF="#zlib_params"><CODE>zlib_params</CODE></A> object is implicitly constructible from an <CODE>int</CODE> representing a compression level, an <CODE>int</CODE> may be passed as the first constructor argument.</P>

<A NAME="basic_zlib_decompressor">
<H3>Class template <CODE>basic_zlib_decompressor</CODE></H3>

<H4>Description</H4>

Model of <A HREF="../concepts/dual_use_filter.html">DualUseFilter</A> which performs decompression using zlib (<A CLASS="bib_ref" HREF="../bibliography.html#gailly">[Gailly]</A>).

<H4>Synopsis</H4>

<PRE CLASS="broken_ie"><SPAN CLASS="keyword">template</SPAN>&lt;<SPAN CLASS="keyword">typename</SPAN> <A CLASS="documented" HREF="#basic_zlib_decompressor_params">Alloc</A> = std::allocator&lt;<SPAN CLASS="keyword">char</SPAN>&gt; &gt;
<SPAN CLASS="keyword">struct</SPAN> <A CLASS="documented" HREF="#basic_zlib_decompressor_params">basic_zlib_decompressor</A> {
    <SPAN CLASS="keyword">typedef</SPAN> <SPAN CLASS="keyword">char</SPAN>                    char_type;
    <SPAN CLASS="keyword">typedef</SPAN> <SPAN CLASS="omitted">implementation-defined</SPAN>  io_category;

    <A CLASS="documented" HREF="#basic_zlib_decompressor_constructors">basic_zlib_decompressor</A>( <SPAN CLASS="keyword">int</SPAN> window_bits = <SPAN CLASS="omitted">default value</SPAN>, 
                             std::streamsize buffer_size = 
                                 <SPAN CLASS="omitted">default value</SPAN> );
    <A CLASS="documented" HREF="#basic_zlib_decompressor_constructors">basic_zlib_decompressor</A>( <SPAN CLASS="keyword">const</SPAN> <A CLASS="documented" HREF="#zlib_params">zlib_params</A>&, 
                             std::streamsize buffer_size = 
                                 <SPAN CLASS="omitted">default value</SPAN> );

    <SPAN CLASS="comment">// DualUseFilter members.</SPAN>
};

<SPAN CLASS="keyword">typedef</SPAN> <A CLASS="documented" HREF="#basic_zlib_decompressor">basic_zlib_decompressor</A><> <SPAN CLASS="defined">zlib_decompressor</SPAN>;</PRE>

<A NAME="basic_zlib_decompressor_params"></A>
<H4>Template Parameters</H4>

<TABLE STYLE="margin-left:2em" BORDER=0 CELLPADDING=2>
<TR>
    <TR>
        <TD VALIGN="top"><I>Alloc</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>A C++ standard library allocator type (<A CLASS="bib_ref" HREF="../bibliography.html#iso">[ISO]</A>, 20.1.5), used to allocate a character buffer and to configure zlib.</TD>
    </TR>
</TABLE>

<A NAME="basic_zlib_decompressor_constructors"></A>
<H4><CODE>basic_zlib_decompressor::basic_zlib_decompressor</CODE></H4>

<PRE CLASS="broken_ie">    <A CLASS="documented" HREF="#basic_zlib_decompressor_constructors">basic_zlib_decompressor</A>( <SPAN CLASS="keyword">int</SPAN> window_bits = <SPAN CLASS="omitted">default value</SPAN>, 
                             std::streamsize buffer_size = 
                                 <SPAN CLASS="omitted">default value</SPAN> );
    <A CLASS="documented" HREF="#basic_zlib_decompressor_constructors">basic_zlib_decompressor</A>( <SPAN CLASS="keyword">const</SPAN> <A CLASS="documented" HREF="#zlib_params">zlib_params</A>&, 
                             std::streamsize buffer_size = 
                                 <SPAN CLASS="omitted">default value</SPAN> );</PRE>

<P>The first member constructs an instance of <CODE>basic_zlib_decompressor</CODE> with the given parameters and buffer size.
The second member constructs an instance of <CODE>basic_zlib_decompressor</CODE> with the given <A HREF="#window_bits">window bits</A> value and buffer size. Other parameters affecting decompression are set to default values.</P>

<A NAME="zlib_error">
<H3>Class <CODE>zlib_error</CODE></H3>

<H4>Description</H4>

Used by the zlib Filters to report errors.

<H4>Synopsis</H4>

<PRE CLASS="broken_ie"><SPAN CLASS="keyword">class</SPAN> <SPAN CLASS="defined">zlib_error</SPAN> : <SPAN CLASS="keyword">public</SPAN> std::ios_base::failure {
<SPAN CLASS="keyword">public:</SPAN>
    <A CLASS="documented" HREF="#zlib_error_constructor">zlib_error</A>(<SPAN CLASS="keyword">int</SPAN> error);
    <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#zlib_error_error">error</A>() const;
};</PRE>

<A NAME="zlib_error_constructor"></A>
<H4><CODE>zlib_error::zlib_error</CODE></H4>

<PRE CLASS="broken_ie">    <B>zlib_error</B>(<SPAN CLASS="keyword">int</SPAN> error);</PRE>

<P>Constructs an instance of <CODE>zlib_error</CODE> with the given error code from the namespace <A HREF="#constants"><CODE>boost::iostreams::zlib</CODE></A>.</P>

<A NAME="zlib_error_error"></A>
<H4><CODE>zlib_error::error</CODE></H4>

<PRE CLASS="broken_ie">    <SPAN CLASS="keyword">void</SPAN> <B>error</B>() <SPAN CLASS="keyword">const</SPAN>;</PRE>

<P>Returns an error code from the namespace <A HREF="#constants"><CODE>boost::iostreams::zlib</CODE></A>.</P>

<A NAME="examples">
<H2>Examples</H2>

The following code decompresses data from a file and writes it to standard output.

<PRE CLASS="broken_ie"><SPAN CLASS="preprocessor">#include</SPAN> <SPAN CLASS="literal">&lt;fstream&gt;</SPAN>
<SPAN CLASS="preprocessor">#include</SPAN> <SPAN CLASS="literal">&lt;iostream&gt;</SPAN>
<SPAN CLASS="preprocessor">#include</SPAN> <A CLASS="header" HREF="../../../../boost/iostreams/filtering_streambuf.hpp"><SPAN CLASS="literal">&lt;boost/iostreams/filtering_streambuf.hpp&gt;</SPAN></A>
<SPAN CLASS="preprocessor">#include</SPAN> <A CLASS="header" HREF="../../../../boost/iostreams/copy.hpp"><SPAN CLASS="literal">&lt;boost/iostreams/copy.hpp&gt;</SPAN></A>
<SPAN CLASS="preprocessor">#include</SPAN> <A CLASS="header" HREF="../../../../boost/iostreams/filter/zlib.hpp"><SPAN CLASS="literal">&lt;boost/iostreams/filter/zlib.hpp&gt;</SPAN></A>

int main() 
{
    <SPAN CLASS="keyword">using</SPAN> <SPAN CLASS="keyword">namespace</SPAN> std;

    ifstream file(<SPAN CLASS="literal">"hello.z"</SPAN>, ios_base::in | ios_base::binary);
    filtering_streambuf&lt;input&gt; in;
    in.push(zlib_decompressor());
    in.push(file);
    boost::iostreams::copy(in, cout);
}</PRE>

<A NAME="installation">
<H3>Installation</H3>

<P>
The zlib Filters depend on the source file <A CLASS="header" HREF="../../src/zlib.cpp"><CODE>&lt;libs/src/zlib.cpp&gt;</CODE></A>. This source file uses several headers from the zlib library, included with the Iostreams Library distribution in the directory <A CLASS="header" HREF="../../src/zlib"><CODE>&lt;libs/iostreams/src/zlib&gt;</CODE></A>. Code using these Filters must be linked against zlib binaries, which are available on most UNIX systems and which can be obtained for Windows systems <A HREF="http://www.gzip.org/zlib/contrib/index.html">here</A>. Alternatively, binaries can be build from the source code (<A CLASS="bib_ref" HREF="../bibliography.html#gailly">[Gailly]</A>).
</P>

<!-- Adler's obfuscated address is copied from his homepage -->

<!-- Begin Footer -->

<HR>
<P CLASS="copyright">Revised
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->
20 May, 2004
<!--webbot bot="Timestamp" endspan i-checksum="38504" -->
</P>

<P CLASS="copyright">&copy; Copyright Jonathan Turkanis, 2004</P>
<P CLASS="copyright"> 
    Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
</P>

<!-- End Footer -->

</BODY>