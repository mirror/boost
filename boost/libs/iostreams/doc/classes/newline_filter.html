<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
    <TITLE>Class Template basic_newline_filter</TITLE>
    <LINK REL="stylesheet" HREF="../../../../boost.css">
    <LINK REL="stylesheet" HREF="../theme/iostreams.css">
</HEAD>
<BODY>

<!-- Begin Banner -->

    <H1 CLASS="title">Class Template <CODE>basic_newline_filter</CODE></H1>
    <HR CLASS="banner">

<!-- End Banner -->

<DL class="page-index">
  <DT><A href="#description">Description</A></DT>
  <!-- <DT><A href="#example">Example</A></DT> -->
  <DT><A href="#headers">Headers</A></DT>
  <DT><A href="#reference">Reference</CODE></A></DT>
</DL>

<HR>

<A NAME="description">
<H2>Description</H2>

<P>
    The class templates <CODE>basic_newline_filter</CODE> is a <A HREF="../concepts/dual_use_filter.html">DualUseFilter</A> which converts between the text file formats used by various operating systems. Its sole constructor takes an integral flag parameter used to specify the source and target formats.
</P>
<P>
    Note: It is not known if specializations of <CODE>basic_newline_filter</CODE> other than <CODE>basic_newline_filter&lt;char&gt;</CODE> are useful. If not, the template parameter will be eliminated.
</P>

<!-- <A NAME="example"></A>
<H2>Example</H2>

<P>
    The following example uses a newline_filter to convert a text file to Unix format.
</P>

<PRE CLASS="broken_ie">    <SPAN CLASS="preprocessor">#include</SPAN> <A CLASS="header" HREF="../../../../boost/iostreams/copy.hpp"><SPAN CLASS="literal">&lt;boost/iostreams/copy.hpp&gt;</SPAN></A>   
    <SPAN CLASS="preprocessor">#include</SPAN> <A CLASS="header" HREF="../../../../boost/iostreams/device/file.hpp"><SPAN CLASS="literal">&lt;boost/iostreams/device/file.hpp&gt;</SPAN></A>   
    <SPAN CLASS="preprocessor">#include</SPAN> <A CLASS="header" HREF="../../../../boost/iostreams/filter/newline_filter.hpp"><SPAN CLASS="literal">&lt;boost/iostreams/filter/newline_filter.hpp&gt;</SPAN></A>  

    using namespace boost::iostreams;
    filtering_streambuf in;
    in.push(newline_filter(newline::unixs));
    in.push(file_source("hello.txt", std::ios_base::binary));
    copy(in, file_sink("hello.txt", std::ios_base::binary) );
    
</PRE> -->

<A NAME="headers">
<H2>Headers</H2>

<DL class="page-index">
  <DT><A CLASS="header" HREF="../../../../boost/iostreams/filter/newline_filter.hpp"><CODE>&lt;boost/iostreams/filter/newline_filter.hpp&gt;</CODE></A></DT>
</DL>

<A NAME="reference">
<H2>Reference</H2>

<H4>Synopsis</H4>

<PRE CLASS="broken_ie"><SPAN CLASS="keyword">namespace</SPAN> boost { <SPAN CLASS="keyword">namespace</SPAN> iostreams {

<SPAN CLASS="keyword">namespace</SPAN> newline { 

<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#posix">posix</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#mac">mac</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#windows">windows</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#print_CR">print_CR</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#print_LF">print_LF</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#print_CRLF">print_CRLF</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#accept_CR">accept_CR</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#accept_LF">accept_LF</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#accept_CRLF">accept_CRLF</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#ignore_CR">ignore_CR</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#ignore_LF">ignore_LF</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#greedy">greedy</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS="documented" HREF="#final_newline">final_newline</A>;

} <SPAN CLASS="comment">// End namespace boost::iostreams::newline</SPAN>

<SPAN CLASS="keyword">template</SPAN>&lt;<SPAN CLASS="keyword">typename</SPAN> <A CLASS="documented" HREF="#template_params">Ch</A>&gt;
<SPAN CLASS="keyword">class</SPAN> <A CLASS="documented" HREF="#template_params">basic_newline_filter</A> {
<SPAN CLASS="keyword">public</SPAN>:
    <SPAN CLASS="keyword">typedef</SPAN> Ch                     char_type;
    <SPAN CLASS="keyword">struct</SPAN> <SPAN CLASS="omitted">implementation-defined</SPAN>  io_category
    <A CLASS="documented" HREF="#constructor">basic_newline_filter</A>(<SPAN CLASS="keyword">int</SPAN> flags);
    <SPAN CLASS="omitted">...</SPAN>
};

<SPAN CLASS="keyword">typedef</SPAN> basic_newline_filter&lt;<SPAN CLASS="keyword">char</SPAN>&gt;     <SPAN CLASS="defined">newline_filter</SPAN>;
<SPAN CLASS="keyword">typedef</SPAN> basic_newline_filter&lt;<SPAN CLASS="keyword">wchar_t</SPAN>&gt;  <SPAN CLASS="defined">newline_wfilter</SPAN>;

} } <SPAN CLASS="comment">// End namespace boost::io</PRE></SPAN>

<A NAME="template_params"></A>
<H4>Template Parameters</H4>

<TABLE STYLE="margin-left:2em" BORDER=0 CELLPADDING=2>
<TR>
    <TR>
        <TD VALIGN="top"><I>Ch</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>The character type</TD>
    </TR>
</TABLE>

<A NAME="constructor"></A>
<H4><CODE>basic_newline_filter::basic_newline_filter</CODE></H4>

<A NAME="constructor"></A>
<PRE CLASS="broken_ie">    basic_newline_filter(<SPAN CLASS="keyword">int</SPAN> flags);</PRE>
    
<P>
    Constructs a <CODE>basic_newline_filter</CODE>. The <CODE>flags</CODE> argument must be a bitwise OR of the following constants from the namespace <CODE>boost::iostreams::newline</CODE>, having the interpretation shown in the table below:<SUP><A CLASS="footnote_ref" NAME="note_1_ref" HREF="#note_1">[1]</A></SUP>
    <UL>
        <LI CLASS="square">exactly one of <CODE>print_CR</CODE>, <CODE>print_LF</CODE> and <CODE>print_CRLF</CODE>, and
        <LI CLASS="square">one or more of <CODE>accept_CR</CODE>, <CODE>accept_LF</CODE>, <CODE>ignore_CR</CODE>, <CODE>ignore_LF</CODE>, <CODE>greedy</CODE> and <CODE>final_newline</CODE>.
    </UL>
</P>

<TABLE STYLE="margin-left:2em; margin-bottom:2em" BORDER=1 CELLPADDING=4>
<TR><TH>Constant</TH><TH>Interpretation</TH></TR>
    <TR>
        <TD VALIGN="top"><A NAME="print_CR"></A><CODE>print_CR</CODE></TD>
        <TD>Filtered data uses the ASCII character <CODE>CR</CODE> (<CODE>0x0D</CODE>) as a line terminator</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="print_LF"></A><CODE>print_LF</CODE></TD>
        <TD>Filtered data uses the ASCII character <CODE>LF</CODE> (<CODE>0x0A</CODE>) as a line terminator</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="print_CRLF"></A><CODE>print_CRLF</CODE></TD>
        <TD>Filtered data uses the ASCII character sequence <CODE>CRLF</CODE> as a line terminator</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="accept_CR"></A><CODE>accept_CR</CODE></TD>
        <TD>The ASCII character <CODE>CR</CODE> (<CODE>0x0D</CODE>) encountered in unfiltered data is interpretted as a line terminator</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="accept_LF"></A><CODE>accept_LF</CODE></TD>
        <TD>The ASCII character <CODE>LF</CODE> (<CODE>0x0A</CODE>) encountered in unfiltered data is interpretted as a line terminator</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="accept_CRLF"></A><CODE>accept_CRLF</CODE></TD>
        <TD>The ASCII character sequence <CODE>CRLF</CODE> encountered in unfiltered data is interpretted as a line terminator</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="ignore_CR"></A><CODE>ignore_CR</CODE></TD>
        <TD>Occurrences of the ASCII character <CODE>CR</CODE> (<CODE>0x0D</CODE>) which do not form part of a line terminator are ignored</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="ignore_LF"></A><CODE>ignore_LF</CODE></TD>
        <TD>Occurrences of the ASCII character <CODE>LF</CODE> (<CODE>0x0A</CODE>) which do not form part of a line terminator are ignored</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="greedy"></A><CODE>greedy</CODE></TD>
        <TD>The ASCII character sequence <CODE>CRLF</CODE> is matched in preference to the character <CODE>CR</CODE> if both are accepted as line terminators
        </TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="final_newline"></A><CODE>final_newline</CODE></TD>
        <TD>A newline is added to the end of the filtered data if not already present</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="posix"></A><CODE>posix</CODE></TD>
        <TD>
            Useful for converting data to the Unix format; equivalent to <CODE>print_LF | accept_CR | accept_LF | accept_CRLF | greedy</CODE>
        </TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="mac"></A><CODE>mac</CODE></TD>
        <TD>
            Useful for converting data to the Classic Mac format; equivalent to <CODE>print_CR | accept_CR | accept_LF | accept_CRLF | greedy</CODE>
        </TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="windows"></A><CODE>windows</CODE></TD>
        <TD>
            Useful for converting data to the Windows format; equivalent to <CODE>print_CRLF | accept_CR | accept_LF | accept_CRLF | greedy</CODE>
        </TD>
    </TR>
</TABLE>

<!-- Begin Footnotes -->

<HR>

<P>
    <SUP><A CLASS="footnote_ref" NAME="note_1" HREF="#note_1_ref">[1]</A></SUP>Notice that <CODE>flags</CODE> has no default value. It would be convenient for a default-constructed <CODE>basic_newline_filter</CODE> to convert text files to the format used by the current platform, but it is not clear how to handle Mac OS X.
</P>

<!-- End Footnotes -->

<!-- Begin Footer -->

<HR>
<P CLASS="copyright">Revised
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->
20 May, 2004
<!--webbot bot="Timestamp" endspan i-checksum="38504" -->
</P>

<P CLASS="copyright">&copy; Copyright Jonathan Turkanis, 2004</P>
<P CLASS="copyright"> 
    Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
</P>

<!-- End Footer -->

</BODY>